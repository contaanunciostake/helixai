# üîå GUIA: Integra√ß√£o Multi-Tenant com Sistemas Externos

## üéØ Objetivo
Sincronizar ve√≠culos de m√∫ltiplas lojas (multi-tenant) que usam plataformas como ShopCar, Webmotors, etc.

---

## üìã ESTRAT√âGIAS DE INTEGRA√á√ÉO (em ordem de prefer√™ncia)

### **1. API Oficial (IDEAL)** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Como verificar:**
- Acessar site do ShopCar ‚Üí "Desenvolvedores" ou "Integra√ß√µes"
- Contatar suporte t√©cnico do ShopCar
- Verificar se cliente tem "API Key" na conta dele

**Vantagens:**
- ‚úÖ Legal e permitido
- ‚úÖ Est√°vel (n√£o quebra)
- ‚úÖ Documenta√ß√£o oficial
- ‚úÖ Suporte t√©cnico

**Desvantagens:**
- ‚ùå Pode ter custo adicional
- ‚ùå Nem sempre existe

---

### **2. Reverse Engineering da API (RECOMENDADO)** ‚≠ê‚≠ê‚≠ê‚≠ê

**Como fazer:**

1. **Abrir o site do ShopCar no navegador**
2. **Abrir DevTools (F12)**
3. **Ir na aba Network**
4. **Navegar pela plataforma:**
   - Listar ve√≠culos
   - Cadastrar ve√≠culo
   - Editar ve√≠culo
   - Deletar ve√≠culo
5. **Analisar as requisi√ß√µes:**
   - Procurar por chamadas XHR/Fetch
   - Ver URLs (ex: `api.shopcar.com/v1/vehicles`)
   - Ver Headers (Authorization, API Keys)
   - Ver Payloads (formato JSON)

**Exemplo do que procurar:**
```javascript
// Requisi√ß√£o encontrada no DevTools:
POST https://api.shopcar.com/v1/vehicles
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "store_id": 123,
  "model": "Civic",
  "brand": "Honda",
  "year": 2023,
  "price": 120000
}
```

**Vantagens:**
- ‚úÖ Geralmente funciona
- ‚úÖ Mais est√°vel que scraping
- ‚úÖ Dados estruturados (JSON)
- ‚úÖ Sem custo adicional

**Desvantagens:**
- ‚ö†Ô∏è Pode quebrar em atualiza√ß√µes
- ‚ö†Ô∏è √Årea cinzenta legal
- ‚ö†Ô∏è Sem suporte oficial

---

### **3. Web Scraping (√öLTIMA OP√á√ÉO)** ‚≠ê‚≠ê

**Como fazer:**
```javascript
// Usar Puppeteer ou Cheerio
import puppeteer from 'puppeteer';

async function scrapVehicles(storeUrl) {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto(storeUrl);

  const vehicles = await page.evaluate(() => {
    // Extrair dados do HTML
    return Array.from(document.querySelectorAll('.vehicle-card')).map(card => ({
      title: card.querySelector('.title').textContent,
      price: card.querySelector('.price').textContent,
      image: card.querySelector('img').src
    }));
  });

  await browser.close();
  return vehicles;
}
```

**Vantagens:**
- ‚úÖ Funciona quando n√£o h√° API

**Desvantagens:**
- ‚ùå Quebra facilmente
- ‚ùå Lento (precisa renderizar HTML)
- ‚ùå Pode ser bloqueado
- ‚ùå Contra termos de uso
- ‚ùå Dif√≠cil de manter

---

### **4. Export Manual + Automa√ß√£o (H√çBRIDO)** ‚≠ê‚≠ê‚≠ê

**Processo:**
1. Cliente exporta CSV/XML do ShopCar diariamente
2. Upload autom√°tico para servidor (FTP/S3)
3. Cron job importa o arquivo

**Vantagens:**
- ‚úÖ 100% confi√°vel
- ‚úÖ Legal
- ‚úÖ Simples

**Desvantagens:**
- ‚ö†Ô∏è Requer a√ß√£o manual do cliente
- ‚ö†Ô∏è N√£o √© tempo real

---

## üèóÔ∏è ARQUITETURA MULTI-TENANT RECOMENDADA

### **Estrutura do Banco de Dados:**

```sql
-- Tabela de empresas (j√° existe)
CREATE TABLE empresas (
  id INT PRIMARY KEY,
  nome VARCHAR(255),
  shopcar_store_id VARCHAR(100),    -- ID da loja no ShopCar
  shopcar_api_key VARCHAR(255),     -- API Key (se tiver)
  shopcar_url VARCHAR(500),         -- URL p√∫blica da loja
  sync_enabled BOOLEAN DEFAULT 1,   -- Habilitar sincroniza√ß√£o?
  sync_interval INT DEFAULT 60,     -- Intervalo em minutos
  last_sync TIMESTAMP
);

-- Tabela centralizada de ve√≠culos (multi-tenant)
CREATE TABLE veiculos (
  id INT PRIMARY KEY AUTO_INCREMENT,
  empresa_id INT NOT NULL,          -- FK para empresas
  external_id VARCHAR(100),         -- ID no sistema externo

  -- Dados do ve√≠culo
  marca VARCHAR(100),
  modelo VARCHAR(255),
  ano_fabricacao INT,
  ano_modelo INT,
  quilometragem INT,
  preco DECIMAL(12,2),
  descricao TEXT,
  cor VARCHAR(50),
  cambio VARCHAR(50),
  combustivel VARCHAR(50),

  -- Controle de sincroniza√ß√£o
  sync_status ENUM('synced', 'pending', 'error', 'deleted'),
  sync_error TEXT,
  last_synced TIMESTAMP,

  -- Timestamps
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  FOREIGN KEY (empresa_id) REFERENCES empresas(id),
  UNIQUE KEY unique_external (empresa_id, external_id),
  INDEX idx_empresa_status (empresa_id, sync_status)
);

-- Tabela de fotos (separada para m√∫ltiplas imagens)
CREATE TABLE veiculo_fotos (
  id INT PRIMARY KEY AUTO_INCREMENT,
  veiculo_id INT NOT NULL,
  url VARCHAR(500),
  external_url VARCHAR(500),        -- URL original no ShopCar
  ordem INT DEFAULT 0,
  is_principal BOOLEAN DEFAULT 0,

  FOREIGN KEY (veiculo_id) REFERENCES veiculos(id) ON DELETE CASCADE,
  INDEX idx_veiculo (veiculo_id)
);

-- Tabela de log de sincroniza√ß√£o
CREATE TABLE sync_logs (
  id INT PRIMARY KEY AUTO_INCREMENT,
  empresa_id INT NOT NULL,
  sync_type ENUM('full', 'incremental'),
  vehicles_added INT DEFAULT 0,
  vehicles_updated INT DEFAULT 0,
  vehicles_deleted INT DEFAULT 0,
  status ENUM('success', 'partial', 'error'),
  error_message TEXT,
  started_at TIMESTAMP,
  finished_at TIMESTAMP,

  FOREIGN KEY (empresa_id) REFERENCES empresas(id),
  INDEX idx_empresa_date (empresa_id, started_at)
);
```

---

## üîÑ SISTEMA DE SINCRONIZA√á√ÉO

### **Arquivo: `sync-manager.js`**

```javascript
/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * SYNC MANAGER - Sincronizador Multi-Tenant de Ve√≠culos
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

import mysql from 'mysql2/promise';
import axios from 'axios';
import cron from 'node-cron';

class SyncManager {
  constructor() {
    this.dbPool = mysql.createPool({
      host: 'localhost',
      user: 'root',
      password: '',
      database: 'helixai_db'
    });
  }

  /**
   * üöÄ Iniciar sincronizador autom√°tico
   */
  start() {
    console.log('üîÑ [SYNC-MANAGER] Iniciando sincronizador multi-tenant...');

    // Rodar a cada 30 minutos
    cron.schedule('*/30 * * * *', async () => {
      console.log('\n‚è∞ [SYNC] Executando sincroniza√ß√£o programada...');
      await this.syncAllCompanies();
    });

    // Sincronizar na inicializa√ß√£o
    setTimeout(() => this.syncAllCompanies(), 5000);
  }

  /**
   * üè¢ Sincronizar todas as empresas
   */
  async syncAllCompanies() {
    try {
      const [empresas] = await this.dbPool.execute(
        `SELECT id, nome, shopcar_store_id, shopcar_api_key, sync_enabled
         FROM empresas
         WHERE sync_enabled = 1 AND shopcar_store_id IS NOT NULL`
      );

      console.log(`üìä [SYNC] ${empresas.length} empresa(s) para sincronizar`);

      for (const empresa of empresas) {
        await this.syncCompany(empresa);
        // Aguardar 2 segundos entre empresas
        await new Promise(r => setTimeout(r, 2000));
      }

      console.log('‚úÖ [SYNC] Sincroniza√ß√£o completa!\n');
    } catch (error) {
      console.error('‚ùå [SYNC] Erro na sincroniza√ß√£o:', error);
    }
  }

  /**
   * üîÑ Sincronizar uma empresa espec√≠fica
   */
  async syncCompany(empresa) {
    const startTime = new Date();
    let stats = { added: 0, updated: 0, deleted: 0 };

    try {
      console.log(`\nüè¢ [SYNC] Empresa: ${empresa.nome} (ID ${empresa.id})`);

      // 1. BUSCAR VE√çCULOS DO SHOPCAR (API ou Scraping)
      const externalVehicles = await this.fetchVehiclesFromShopCar(empresa);
      console.log(`   üì• ${externalVehicles.length} ve√≠culos encontrados no ShopCar`);

      // 2. BUSCAR VE√çCULOS LOCAIS
      const [localVehicles] = await this.dbPool.execute(
        'SELECT id, external_id FROM veiculos WHERE empresa_id = ?',
        [empresa.id]
      );

      const localMap = new Map(localVehicles.map(v => [v.external_id, v.id]));

      // 3. PROCESSAR CADA VE√çCULO
      for (const extVehicle of externalVehicles) {
        if (localMap.has(extVehicle.id)) {
          // Atualizar existente
          await this.updateVehicle(empresa.id, extVehicle);
          stats.updated++;
          localMap.delete(extVehicle.id);
        } else {
          // Inserir novo
          await this.insertVehicle(empresa.id, extVehicle);
          stats.added++;
        }
      }

      // 4. MARCAR VE√çCULOS DELETADOS (que n√£o vieram na sincroniza√ß√£o)
      for (const [externalId, localId] of localMap) {
        await this.dbPool.execute(
          `UPDATE veiculos SET sync_status = 'deleted'
           WHERE id = ? AND empresa_id = ?`,
          [localId, empresa.id]
        );
        stats.deleted++;
      }

      // 5. REGISTRAR LOG
      await this.logSync(empresa.id, stats, 'success', startTime);

      console.log(`   ‚úÖ Adicionados: ${stats.added} | Atualizados: ${stats.updated} | Deletados: ${stats.deleted}`);

    } catch (error) {
      console.error(`   ‚ùå Erro ao sincronizar ${empresa.nome}:`, error.message);
      await this.logSync(empresa.id, stats, 'error', startTime, error.message);
    }
  }

  /**
   * üåê Buscar ve√≠culos do ShopCar (ADAPTAR CONFORME API DESCOBERTA)
   */
  async fetchVehiclesFromShopCar(empresa) {
    // OP√á√ÉO A: API Oficial
    if (empresa.shopcar_api_key) {
      const response = await axios.get(
        `https://api.shopcar.com/v1/stores/${empresa.shopcar_store_id}/vehicles`,
        {
          headers: {
            'Authorization': `Bearer ${empresa.shopcar_api_key}`,
            'Content-Type': 'application/json'
          }
        }
      );
      return response.data.vehicles || [];
    }

    // OP√á√ÉO B: Reverse Engineering
    // TODO: Implementar ap√≥s descobrir endpoints reais

    // OP√á√ÉO C: Scraping (√∫ltima op√ß√£o)
    // return await this.scrapVehicles(empresa.shopcar_url);

    return [];
  }

  /**
   * ‚ûï Inserir novo ve√≠culo
   */
  async insertVehicle(empresaId, vehicle) {
    const [result] = await this.dbPool.execute(
      `INSERT INTO veiculos (
        empresa_id, external_id, marca, modelo, ano_fabricacao,
        ano_modelo, preco, quilometragem, descricao, cor,
        cambio, combustivel, sync_status, last_synced
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'synced', NOW())`,
      [
        empresaId,
        vehicle.id,
        vehicle.brand || '',
        vehicle.model || '',
        vehicle.year || null,
        vehicle.year_model || null,
        vehicle.price || 0,
        vehicle.mileage || 0,
        vehicle.description || '',
        vehicle.color || '',
        vehicle.transmission || '',
        vehicle.fuel || ''
      ]
    );

    // Inserir fotos
    if (vehicle.images && vehicle.images.length > 0) {
      for (let i = 0; i < vehicle.images.length; i++) {
        await this.dbPool.execute(
          `INSERT INTO veiculo_fotos (veiculo_id, url, external_url, ordem, is_principal)
           VALUES (?, ?, ?, ?, ?)`,
          [result.insertId, vehicle.images[i], vehicle.images[i], i, i === 0 ? 1 : 0]
        );
      }
    }
  }

  /**
   * üîÑ Atualizar ve√≠culo existente
   */
  async updateVehicle(empresaId, vehicle) {
    await this.dbPool.execute(
      `UPDATE veiculos SET
        marca = ?, modelo = ?, ano_fabricacao = ?, ano_modelo = ?,
        preco = ?, quilometragem = ?, descricao = ?, cor = ?,
        cambio = ?, combustivel = ?, sync_status = 'synced',
        last_synced = NOW()
       WHERE empresa_id = ? AND external_id = ?`,
      [
        vehicle.brand || '',
        vehicle.model || '',
        vehicle.year || null,
        vehicle.year_model || null,
        vehicle.price || 0,
        vehicle.mileage || 0,
        vehicle.description || '',
        vehicle.color || '',
        vehicle.transmission || '',
        vehicle.fuel || '',
        empresaId,
        vehicle.id
      ]
    );
  }

  /**
   * üìù Registrar log de sincroniza√ß√£o
   */
  async logSync(empresaId, stats, status, startTime, errorMsg = null) {
    await this.dbPool.execute(
      `INSERT INTO sync_logs (
        empresa_id, sync_type, vehicles_added, vehicles_updated,
        vehicles_deleted, status, error_message, started_at, finished_at
      ) VALUES (?, 'full', ?, ?, ?, ?, ?, ?, NOW())`,
      [
        empresaId,
        stats.added,
        stats.updated,
        stats.deleted,
        status,
        errorMsg,
        startTime
      ]
    );
  }
}

export default SyncManager;
```

---

## üöÄ COMO USAR

### **1. Descobrir a API Real do ShopCar:**

**Passo a passo:**
```bash
1. Acesse o painel do ShopCar com login de um cliente
2. Abra DevTools (F12) ‚Üí Aba Network
3. Navegue e cadastre um ve√≠culo
4. Veja as requisi√ß√µes XHR/Fetch
5. Copie:
   - URL base (ex: api.shopcar.com.br)
   - Headers necess√°rios
   - Formato dos dados
```

### **2. Criar as Tabelas:**

```bash
cd D:\Helix\HelixAI\VendeAI\bot_engine
mysql -u root helixai_db < migrations/create_sync_tables.sql
```

### **3. Integrar no main.js:**

```javascript
import SyncManager from './sync-manager.js';

// Depois de iniciar o bot
const syncManager = new SyncManager();
syncManager.start();
```

---

## üìä DASHBOARD NO CRM

Adicionar tela para mostrar:
- Status da √∫ltima sincroniza√ß√£o
- Total de ve√≠culos sincronizados
- Erros (se houver)
- Bot√£o "Sincronizar Agora"

---

## üéØ PR√ìXIMOS PASSOS

1. ‚úÖ **Investigar API do ShopCar** (usar DevTools)
2. ‚úÖ **Criar tabelas de sincroniza√ß√£o**
3. ‚úÖ **Implementar sync-manager.js**
4. ‚úÖ **Testar com 1 cliente**
5. ‚úÖ **Adicionar dashboard no CRM**
6. ‚úÖ **Escalar para todos os clientes**

---

**Essa arquitetura funciona para QUALQUER plataforma externa!** üöÄ
