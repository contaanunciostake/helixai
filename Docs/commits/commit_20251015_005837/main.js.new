import makeWASocket, { DisconnectReason, useMultiFileAuthState, fetchLatestBaileysVersion, makeCacheableSignalKeyStore, downloadMediaMessage } from '@whiskeysockets/baileys';
import { Boom } from '@hapi/boom';
import pino from 'pino';
import OpenAI from 'openai';
// import Groq from "groq-sdk";
import Anthropic from '@anthropic-ai/sdk';
import NodeCache from 'node-cache';
import qrcode from 'qrcode-terminal';
import 'dotenv/config';
import axios from 'axios';
import FormData from 'form-data';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import ffmpeg from 'fluent-ffmpeg';
import { ElevenLabsClient } from 'elevenlabs';
import mysql from 'mysql2/promise';

// ‚ùå IA MASTER DESATIVADA (n√£o est√° sendo usada)
// import { IAMaster } from './ia-modules/00-ia-master.js';

// ‚úÖ IMPORTAR SIMULADOR DE FINANCIAMENTO
import { SimuladorFinanciamento, GerenciadorFinanciamento } from './simulador-financiamento.js';

// ‚úÖ IMPORTAR API FIPE
import { consultarValorFipe, compararComFipe } from './fipe-wrapper.js';

// ‚úÖ IMPORTAR BOT ADAPTER (Integra√ß√£o com Backend Flask)
import botAdapter from './bot-adapter.js';

// ‚úÖ IMPORTAR GERENCIADOR DE AGENDAMENTOS
import { GerenciadorAgendamentos } from './modulo-agendamento.js';

// ‚úÖ IMPORTAR MESSAGE TRACKER (Sistema de Debug e Rastreamento)
// Adicionado em: 2025-01-13 por Helix AI Developer
// Prop√≥sito: Resolver problema de mensagens n√£o entregues
import messageTracker from './message-tracker.js';


// ========== FUN√á√ÉO HELPER PARA SUBSTITUIR OPENAI POR CLAUDE ==========
/**
 * Converte chamadas OpenAI para Claude
 * @param {Object} anthropic - Inst√¢ncia do cliente Anthropic
 * @param {Object} config - Configura√ß√£o da chamada OpenAI {model, messages, temperature, max_tokens}
 * @returns {Promise<string>} - Texto da resposta
 */
async function callClaudeInsteadOfOpenAI(anthropic, config) {
  const { messages, temperature = 0.7, max_tokens = 150 } = config;

  // Separar system message das outras mensagens
  const systemMessage = messages.find(m => m.role === 'system')?.content || '';
  const userMessages = messages.filter(m => m.role !== 'system');

  // Converter mensagens para formato Claude
  const claudeMessages = userMessages.map(m => ({
    role: m.role,
    content: m.content
  }));

  // Se tiver system message, adicionar ao primeiro user message
  if (systemMessage && claudeMessages.length > 0) {
    if (claudeMessages[0].role === 'user') {
      claudeMessages[0].content = `${systemMessage}\n\n${claudeMessages[0].content}`;
    } else {
      claudeMessages.unshift({ role: 'user', content: systemMessage });
    }
  }

  const response = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20241022',
    max_tokens,
    temperature,
    messages: claudeMessages
  });

  return response.content[0].text.trim();
}

// ========== ADICIONE ESTA FUN√á√ÉO LOGO AP√ìS A CLASSE FormatadorFala ==========
class FormatadorFala {
  static prepararParaTTS(texto) {
    let textoFormatado = texto;

    // -1. REMOVER ANOTA√á√ïES INTERNAS/T√âCNICAS (CR√çTICO!)
    // Remove qualquer texto entre colchetes que s√£o instru√ß√µes para a IA
    // Exemplos: [CHAMA buscar_carros], [ENVIA FOTOS], [GERA PLANILHA], etc.
    textoFormatado = textoFormatado.replace(/\[.*?\]/g, '');

    // Remove tamb√©m poss√≠veis instru√ß√µes t√©cnicas que escaparam
    textoFormatado = textoFormatado.replace(/\bCHAMA\s+\w+\s*\(.*?\)/gi, '');
    textoFormatado = textoFormatado.replace(/\bENVIA\s+.*?(FOTOS?|IMAGENS?|DADOS|INFORMA√á√ïES)/gi, '');

    // 0. REMOVER GAGUEJADAS E REPETI√á√ïES
    textoFormatado = this.removerGaguejadas(textoFormatado);

    // 0.1. FON√âTICA ESPECIAL PARA MODELOS DE VE√çCULOS
    textoFormatado = this.aplicarFoneticaVeiculos(textoFormatado);

    // 1. ANOS (ex: "2008" ‚Üí "dois mil e oito", "ano 2023" ‚Üí "ano dois mil e vinte e tr√™s")
    // Detecta anos de 1900 a 2099 (sozinhos ou depois de "ano")
    textoFormatado = textoFormatado.replace(/\b(ano\s+)?((19|20)\d{2})\b/gi, (match, prefixoAno, ano) => {
      const anoNum = parseInt(ano);
      const anoTexto = this.anoParaTexto(anoNum);
      return prefixoAno ? `ano ${anoTexto}` : anoTexto;
    });

    // 2. VELOCIDADE KM/H (ex: "200 km/h" ‚Üí "duzentos quil√¥metros por hora")
    // DEVE VIR ANTES da regra de "km" sozinho
    textoFormatado = textoFormatado.replace(/(\d+)\s*(km\/h|kmh|km por hora)/gi, (match, num) => {
      return `${this.numeroParaTexto(parseInt(num))} quil√¥metros por hora`;
    });

    // 3. QUIL√îMETROS / KM (ex: "45000 km" ‚Üí "quarenta e cinco mil quil√¥metros")
    textoFormatado = textoFormatado.replace(/(\d+)\s*(km|quil√¥metros|quilometros)(?!\s*\/|por)/gi, (match, num) => {
      return `${this.numeroParaTexto(parseInt(num))} quil√¥metros`;
    });

    // 3. HOR√ÅRIOS (ex: "8h" ‚Üí "oito horas", "14h30" ‚Üí "quatorze horas e trinta minutos")
    textoFormatado = textoFormatado.replace(/(\d{1,2})h(\d{2})?/gi, (match, hora, minutos) => {
      const horaTexto = this.numeroParaTexto(parseInt(hora));
      if (minutos && parseInt(minutos) > 0) {
        const minutoTexto = this.numeroParaTexto(parseInt(minutos));
        return `${horaTexto} horas e ${minutoTexto} minutos`;
      }
      return `${horaTexto} horas`;
    });

    // 4. VALORES EM REAIS (ex: "R$ 85.000" ‚Üí "oitenta e cinco mil reais")
    textoFormatado = textoFormatado.replace(/R\$\s*(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)/g, (match, valor) => {
      const valorLimpo = valor.replace(/\./g, '').replace(',', '.');
      const valorNum = parseFloat(valorLimpo);
      return `${this.numeroParaTexto(Math.round(valorNum))} reais`;
    });

    // 5. PRE√áOS SEM S√çMBOLO (ex: "85000" seguido de "reais" ou isolado em contexto de pre√ßo)
    // Detecta n√∫meros grandes que provavelmente s√£o pre√ßos
    textoFormatado = textoFormatado.replace(/\b(\d{5,})\s*(reais)?/gi, (match, num, reais) => {
      const numTexto = this.numeroParaTexto(parseInt(num));
      return reais ? `${numTexto} reais` : numTexto;
    });

    // 6. REMOVER ENUMERA√á√ïES ROB√ìTICAS (Op√ß√£o 1:, Op√ß√£o 2:, etc)
    // Remove padr√µes como "Op√ß√£o 1:", "Op√ß√£o 2:", "1.", "2.", "Item 1:", etc
    textoFormatado = textoFormatado
      .replace(/\n\s*üì±\s*Op√ß√£o\s+\d+:\s*/gi, '\n') // Remove "üì± Op√ß√£o 1:"
      .replace(/\n\s*üè¢\s*Op√ß√£o\s+\d+:\s*/gi, '\n') // Remove "üè¢ Op√ß√£o 2:"
      .replace(/\n\s*Op√ß√£o\s+\d+:\s*/gi, '\n')      // Remove "Op√ß√£o 1:" gen√©rico
      .replace(/\n\s*\d+\)\s*/g, '\n')              // Remove "1) ", "2) "
      .replace(/\n\s*\d+\.\s*/g, '\n')              // Remove "1. ", "2. "
      .replace(/\n\s*Item\s+\d+:\s*/gi, '\n');      // Remove "Item 1:", "Item 2:"

    // 7. REMOVER MARKDOWN
    textoFormatado = textoFormatado
      .replace(/\*\*/g, '')
      .replace(/\*/g, '')
      .replace(/_/g, '')
      .replace(/#{1,6}\s/g, ''); // Remove headers markdown

    return textoFormatado;
  }

  // Converte ano para texto natural (ex: 2008 ‚Üí "dois mil e oito")
  static anoParaTexto(ano) {
    if (ano < 1000 || ano > 2999) {
      return ano.toString(); // Fora do intervalo esperado
    }

    const milhar = Math.floor(ano / 1000);
    const resto = ano % 1000;

    if (resto === 0) {
      return `${this.numeroParaTexto(milhar)} mil`;
    }

    if (resto < 100) {
      return `${this.numeroParaTexto(milhar)} mil e ${this.numeroParaTexto(resto)}`;
    }

    return `${this.numeroParaTexto(milhar)} mil e ${this.numeroParaTexto(resto)}`;
  }

  // Converte n√∫mero para texto por extenso
  static numeroParaTexto(num) {
    if (num === 0) return 'zero';

    const unidades = ['', 'um', 'dois', 'tr√™s', 'quatro', 'cinco', 'seis', 'sete', 'oito', 'nove'];
    const dezenas = ['', '', 'vinte', 'trinta', 'quarenta', 'cinquenta', 'sessenta', 'setenta', 'oitenta', 'noventa'];
    const especiais = ['dez', 'onze', 'doze', 'treze', 'quatorze', 'quinze', 'dezesseis', 'dezessete', 'dezoito', 'dezenove'];
    const centenas = ['', 'cento', 'duzentos', 'trezentos', 'quatrocentos', 'quinhentos', 'seiscentos', 'setecentos', 'oitocentos', 'novecentos'];

    if (num < 10) return unidades[num];
    if (num >= 10 && num < 20) return especiais[num - 10];
    if (num >= 20 && num < 100) {
      const dez = Math.floor(num / 10);
      const uni = num % 10;
      return dezenas[dez] + (uni > 0 ? ` e ${unidades[uni]}` : '');
    }
    if (num >= 100 && num < 1000) {
      const cent = Math.floor(num / 100);
      const resto = num % 100;
      if (num === 100) return 'cem';
      return centenas[cent] + (resto > 0 ? ' e ' + this.numeroParaTexto(resto) : '');
    }
    if (num >= 1000 && num < 1000000) {
      const mil = Math.floor(num / 1000);
      const resto = num % 1000;
      const milTexto = mil === 1 ? 'mil' : `${this.numeroParaTexto(mil)} mil`;
      return milTexto + (resto > 0 ? ' e ' + this.numeroParaTexto(resto) : '');
    }
    if (num >= 1000000) {
      const milhao = Math.floor(num / 1000000);
      const resto = num % 1000000;
      const milhaoTexto = milhao === 1 ? 'um milh√£o' : `${this.numeroParaTexto(milhao)} milh√µes`;
      if (resto === 0) return milhaoTexto;
      if (resto < 1000) return `${milhaoTexto} e ${this.numeroParaTexto(resto)}`;
      return `${milhaoTexto}, ${this.numeroParaTexto(resto)}`;
    }

    return num.toString();
  }

  // ========== REMOVER GAGUEJADAS E REPETI√á√ïES ==========
  static removerGaguejadas(texto) {
    let textoLimpo = texto;

    // 1. Remover palavras repetidas consecutivas (ex: "o o carro" ‚Üí "o carro")
    textoLimpo = textoLimpo.replace(/\b(\w+)\s+\1\b/gi, '$1');

    // 2. Remover frases/fragmentos repetidos (ex: "vou enviar vou enviar" ‚Üí "vou enviar")
    // Detecta sequ√™ncias de 2-5 palavras repetidas
    textoLimpo = textoLimpo.replace(/\b((?:\w+\s+){2,5})\1+/gi, '$1');

    // 3. Remover espa√ßos m√∫ltiplos
    textoLimpo = textoLimpo.replace(/\s{2,}/g, ' ');

    // 4. Remover pontua√ß√£o duplicada (ex: "!!" ‚Üí "!", "??" ‚Üí "?")
    textoLimpo = textoLimpo.replace(/([!?.]){2,}/g, '$1');

    return textoLimpo.trim();
  }

  // ========== FON√âTICA ESPECIAL PARA MODELOS DE VE√çCULOS ==========
  static aplicarFoneticaVeiculos(texto) {
    let textoComFonetica = texto;

    // Array de substitui√ß√µes [padr√£o regex, substitui√ß√£o]
    const substituicoes = [
      // BMW - Modelos com n√∫meros (ex: 530i, 320i, M3)
      [/\bBMW\s*530i?\b/gi, 'BMW quinhentos e trinta i'],
      [/\bBMW\s*520i?\b/gi, 'BMW quinhentos e vinte i'],
      [/\bBMW\s*320i?\b/gi, 'BMW trezentos e vinte i'],
      [/\bBMW\s*118i?\b/gi, 'BMW cento e dezoito i'],
      [/\bBMW\s*120i?\b/gi, 'BMW cento e vinte i'],
      [/\bBMW\s*M3\b/gi, 'BMW M tr√™s'],
      [/\bBMW\s*M5\b/gi, 'BMW M cinco'],
      [/\bBMW\s*X1\b/gi, 'BMW X um'],
      [/\bBMW\s*X3\b/gi, 'BMW X tr√™s'],
      [/\bBMW\s*X5\b/gi, 'BMW X cinco'],
      [/\bBMW\s*X6\b/gi, 'BMW X seis'],

      // Mercedes-Benz - Modelos (ex: C180, E200, GLA200)
      [/\b(Mercedes[- ]?Benz|Mercedes)\s*C180\b/gi, 'Mercedes-Benz C cento e oitenta'],
      [/\b(Mercedes[- ]?Benz|Mercedes)\s*C200\b/gi, 'Mercedes-Benz C duzentos'],
      [/\b(Mercedes[- ]?Benz|Mercedes)\s*E200\b/gi, 'Mercedes-Benz E duzentos'],
      [/\b(Mercedes[- ]?Benz|Mercedes)\s*GLA200\b/gi, 'Mercedes-Benz GLA duzentos'],
      [/\b(Mercedes[- ]?Benz|Mercedes)\s*GLC300\b/gi, 'Mercedes-Benz GLC trezentos'],

      // Audi - Modelos (ex: A3, A4, Q3, Q5)
      [/\bAudi\s*A3\b/gi, 'Audi A tr√™s'],
      [/\bAudi\s*A4\b/gi, 'Audi A quatro'],
      [/\bAudi\s*A5\b/gi, 'Audi A cinco'],
      [/\bAudi\s*A6\b/gi, 'Audi A seis'],
      [/\bAudi\s*Q3\b/gi, 'Audi Q tr√™s'],
      [/\bAudi\s*Q5\b/gi, 'Audi Q cinco'],
      [/\bAudi\s*Q7\b/gi, 'Audi Q sete'],

      // Volkswagen - Modelos (ex: Gol 1.0, Polo 1.6)
      [/\b(VW|Volkswagen)\s*Gol\s*1\.0\b/gi, 'Volkswagen Gol um ponto zero'],
      [/\b(VW|Volkswagen)\s*Polo\s*1\.6\b/gi, 'Volkswagen Polo um ponto seis'],
      [/\b(VW|Volkswagen)\s*T-Cross\b/gi, 'Volkswagen T-Cross'],

      // Chevrolet - Modelos (ex: Onix 1.0, S10 2.8)
      [/\bOnix\s*1\.0\b/gi, 'Onix um ponto zero'],
      [/\bOnix\s*1\.4\b/gi, 'Onix um ponto quatro'],
      [/\bS10\s*2\.8\b/gi, 'S dez dois ponto oito'],

      // Ford - Modelos (ex: Ranger 3.2, EcoSport 2.0)
      [/\bRanger\s*3\.2\b/gi, 'Ranger tr√™s ponto dois'],
      [/\bEcoSport\s*2\.0\b/gi, 'EcoSport dois ponto zero'],

      // Honda - Modelos (ex: Civic 2.0, HR-V)
      [/\bCivic\s*2\.0\b/gi, 'Civic dois ponto zero'],
      [/\bHR-V\b/gi, 'HR-V'],

      // Toyota - Modelos (ex: Corolla 2.0, Hilux 2.8)
      [/\bCorolla\s*2\.0\b/gi, 'Corolla dois ponto zero'],
      [/\bHilux\s*2\.8\b/gi, 'Hilux dois ponto oito'],

      // Jeep - Modelos (ex: Compass 2.0, Renegade 1.8)
      [/\bCompass\s*2\.0\b/gi, 'Compass dois ponto zero'],
      [/\bRenegade\s*1\.8\b/gi, 'Renegade um ponto oito'],

      // Fiat - Modelos (ex: Toro 2.0)
      [/\bToro\s*2\.0\b/gi, 'Toro dois ponto zero'],
      [/\bMobi\s*1\.0\b/gi, 'Mobi um ponto zero'],

      // Porsche - Modelos (ex: 911, Cayenne)
      [/\bPorsche\s*911\b/gi, 'Porsche nove onze'],
      [/\bPorsche\s*718\b/gi, 'Porsche sete dezoito']
    ];

    // Aplicar todas as substitui√ß√µes
    for (const [pattern, replacement] of substituicoes) {
      textoComFonetica = textoComFonetica.replace(pattern, replacement);
    }

    // Padr√£o gen√©rico para outros modelos com motor (ex: "Tucson 2.0" ‚Üí "Tucson dois ponto zero")
    textoComFonetica = textoComFonetica.replace(/\b(\w+)\s*(\d)\.(\d)\b/gi, (match, modelo, int, dec) => {
      return `${modelo} ${this.numeroParaTexto(parseInt(int))} ponto ${this.numeroParaTexto(parseInt(dec))}`;
    });

    return textoComFonetica;
  }
}


const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Inicializar o cliente Groq
// const groq = new Groq({
//     apiKey: process.env.GROQ_API_KEY // Adicione no .env
// });

// =====================================================
// üîí MODO TESTE - WHITELIST DE N√öMEROS
// =====================================================
// ‚ö†Ô∏è ATEN√á√ÉO: Este c√≥digo limita o bot a responder apenas n√∫meros espec√≠ficos
//
// PARA ATIVAR MODO TESTE:
//   1. Mude MODO_TESTE para true
//   2. Adicione n√∫meros em NUMEROS_PERMITIDOS
//
// PARA DESATIVAR (liberar para todos):
//   1. Mude MODO_TESTE para false
//   2. OU delete/comente todo este bloco
//
const MODO_TESTE = false; // ‚Üê MUDE PARA false QUANDO QUISER LIBERAR PARA TODOS

const NUMEROS_PERMITIDOS = [
  '554299300611',    // Seu n√∫mero (formato: c√≥digo pa√≠s + DDD + n√∫mero)
  '556799222756',    // Segundo n√∫mero autorizado
  '556796239079',
  '556799883484',
  '556796600884',
  '556792097672',
  '556796122238',
  '556791391890',
  '556599999806',   // Terceiro n√∫mero autorizado (67 9623-9079)
  // Adicione mais n√∫meros aqui se precisar testar com outras pessoas:
  // '5511999999999',
  // '5521888888888',
];

/**
 * Verifica se n√∫mero est√° autorizado a usar o bot
 * @param {string} numeroCompleto - N√∫mero no formato: 5542999300611@s.whatsapp.net
 * @returns {boolean} true se autorizado
 */
function numeroEstaAutorizado(numeroCompleto) {
  // Se modo teste est√° DESATIVADO, libera para todos
  if (!MODO_TESTE) {
    return true;
  }

  // Extrair apenas o n√∫mero (remover @s.whatsapp.net ou @lid)
  const numeroLimpo = numeroCompleto.split('@')[0];

  // Verificar se est√° na whitelist
  const autorizado = NUMEROS_PERMITIDOS.includes(numeroLimpo);

  if (!autorizado) {
    console.log(`üö´ [WHITELIST] N√∫mero bloqueado: ${numeroLimpo}`);
    console.log(`üìã [WHITELIST] N√∫meros permitidos: ${NUMEROS_PERMITIDOS.join(', ')}`);
  } else {
    console.log(`‚úÖ [WHITELIST] N√∫mero autorizado: ${numeroLimpo}`);
  }

  return autorizado;
}

console.log('=== BOT AIRA v10.0 - FUNCTION CALLING GPT ===');

// Mostrar status do modo teste
if (MODO_TESTE) {
  console.log('\n‚ö†Ô∏è  ========================================');
  console.log('‚ö†Ô∏è  üîí MODO TESTE ATIVADO');
  console.log('‚ö†Ô∏è  ========================================');
  console.log('‚ö†Ô∏è  Bot responder√° APENAS para:');
  NUMEROS_PERMITIDOS.forEach(num => {
    console.log(`‚ö†Ô∏è    ‚úì ${num}`);
  });
  console.log('‚ö†Ô∏è  ========================================');
  console.log('‚ö†Ô∏è  Para desativar: mude MODO_TESTE = false');
  console.log('‚ö†Ô∏è  (linha ~163 em bot-lucas.js)');
  console.log('‚ö†Ô∏è  ========================================\n');
} else {
  console.log('\n‚úÖ MODO PRODU√á√ÉO: Bot responde para todos\n');
}


// =====================================================
// CONFIGURA√á√ÉO
// =====================================================
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const BASE_URL = process.env.BASE_URL || 'https://feiraoshowcar.com.br';

/**
 * üöó SIMPLIFICA NOME DO VE√çCULO
 * Extrai apenas: Marca + Modelo + Ano
 * Remove detalhes t√©cnicos como 1.6, hatch, sedan, etc.
 *
 * @param {string} nomeCompleto - Nome completo do ve√≠culo
 * @param {number} ano - Ano do ve√≠culo
 * @returns {string} Nome simplificado
 *
 * Exemplos:
 * "FIAT ARGO DRIVE 1.0 6V FLEX" 2022 ‚Üí "Fiat Argo 2022"
 * "VOLKSWAGEN GOL 1.6 MSI TOTAL FLEX" 2020 ‚Üí "Volkswagen Gol 2020"
 * "GM - CHEVROLET S10 2.8" 2015 ‚Üí "Chevrolet S10 2015"
 * "VW - VOLKSWAGEN POLO 1.6" 2016 ‚Üí "Volkswagen Polo 2016"
 */
function simplificarNomeVeiculo(nomeCompleto, ano = '') {
  if (!nomeCompleto) return '';

  // Remove textos entre par√™nteses
  let nome = nomeCompleto.replace(/\([^)]*\)/g, '').trim();

  // Divide em palavras
  let palavras = nome.split(/\s+/).filter(p => p.length > 0);

  // ‚úÖ REMOVER tra√ßos isolados e palavras redundantes (GM -, VW -, etc)
  palavras = palavras.filter(p => p !== '-' && p !== '‚Äì');

  // ‚úÖ REMOVER siglas redundantes no in√≠cio (GM, VW, FIAT duplicados)
  // Ex: "GM - CHEVROLET" ‚Üí remove "GM", fica "CHEVROLET"
  if (palavras.length >= 2 && palavras[0].length <= 3 && palavras[0] !== palavras[1]) {
    const siglas = ['GM', 'VW', 'FIAT'];
    if (siglas.includes(palavras[0].toUpperCase())) {
      palavras = palavras.slice(1); // Remove primeira palavra (sigla)
    }
  }

  // ‚úÖ PEGAR marca + modelo (2 a 3 palavras dependendo do caso)
  // Alguns modelos t√™m 2 palavras (ex: Land Rover, Range Rover, New Fiesta)
  let nomeSimples;

  // Lista de marcas com 2 palavras
  const marcasDuasPalavras = ['land rover', 'range rover'];
  const primeiraDuasPalavras = palavras.slice(0, 2).join(' ').toLowerCase();

  if (marcasDuasPalavras.includes(primeiraDuasPalavras)) {
    // Marca com 2 palavras + modelo (3 palavras no total)
    nomeSimples = palavras.slice(0, 3).join(' ');
  } else {
    // Marca + modelo (2 palavras)
    nomeSimples = palavras.slice(0, 2).join(' ');
  }

  // Capitaliza corretamente
  const nomeCapitalizado = nomeSimples
    .toLowerCase()
    .split(' ')
    .map(palavra => palavra.charAt(0).toUpperCase() + palavra.slice(1))
    .join(' ');

  // Retorna com ano se fornecido
  return ano ? `${nomeCapitalizado} ${ano}` : nomeCapitalizado;
}


async function conectarDB() {
  try {
    // ‚úÖ HABILITADO: Conex√£o com MySQL localhost
    console.log('‚ÑπÔ∏è  [INFO] Conectando ao banco de dados MySQL localhost...');

    db = new DatabaseMySQL();
    await db.connect();
    await db.ping();

    // Testar conex√£o
    const teste = await db.query('SELECT DATABASE() as db, COUNT(*) as total FROM cars');
    console.log('‚úÖ [MySQL] Banco:', teste[0]?.db || 'desconhecido');
    console.log('‚úÖ [MySQL] Total de carros:', teste[0]?.total || 0);

    log.success('Banco de dados MySQL conectado com sucesso!');
    return true;
  } catch (error) {
    log.error(`Erro ao conectar no banco de dados: ${error.message}`);
    console.error('‚ö†Ô∏è [MySQL] Verifique se o XAMPP est√° rodando e o MySQL est√° ativo');
    return false;
  }
}
// Credenciais ElevenLabs
// const GROQ_API_KEY = process.env.GROQ_API_KEY;
const ELEVENLABS_API_KEY = process.env.ELEVENLABS_API_KEY;
const ELEVENLABS_VOICE_ID = process.env.ELEVENLABS_VOICE_ID || 'pNInz6obpgDQGcFmaJgB';

// if (!GROQ_API_KEY) {
//   console.error('‚ö†Ô∏è GROQ_API_KEY n√£o configurada no .env');
// }

if (!ELEVENLABS_API_KEY) {
  console.error('‚ö†Ô∏è ELEVENLABS_API_KEY n√£o configurada no .env');
}

if (!OPENAI_API_KEY) {
  console.error('[ERRO] Configure OPENAI_API_KEY no .env');
  process.exit(1);
}

// if (!GROQ_API_KEY) {
//   console.error('[ERRO] Configure GROQ_API_KEY no .env');
// }

const openai = new OpenAI({ apiKey: OPENAI_API_KEY });
const cache = new NodeCache({ stdTTL: 3600 });

// ‚úÖ Anthropic Claude
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;
const anthropic = ANTHROPIC_API_KEY ? new Anthropic({ apiKey: ANTHROPIC_API_KEY }) : null;

if (ANTHROPIC_API_KEY && ANTHROPIC_API_KEY !== 'sua_chave_anthropic_aqui') {
  console.log('‚úÖ Anthropic Claude configurado');
} else {
  console.log('‚ÑπÔ∏è  Anthropic Claude n√£o configurado (opcional)');
}

const log = {
  info: (msg) => console.log(`[INFO] ${msg}`),
  error: (msg) => console.error(`[ERRO] ${msg}`),
  success: (msg) => console.log(`[‚úì] ${msg}`),
  warning: (msg) => console.warn(`[‚ö†Ô∏è] ${msg}`),
  gpt: (msg) => console.log(`[ü§ñ GPT] ${msg}`),
  function: (msg) => console.log(`[‚öôÔ∏è FUNC] ${msg}`),
};

// =====================================================
// ü§ñ HELPER: Converter Tools OpenAI -> Claude
// =====================================================
/**
 * Converte ferramentas do formato OpenAI para Claude
 * @param {Array} openaiTools - Array de tools no formato OpenAI
 * @returns {Array} Tools no formato Claude
 */
function convertOpenAIToolsToClaude(openaiTools) {
  return openaiTools.map(tool => {
    const func = tool.function;

    // Converter propriedades recursivamente (remover type: ['string', 'null'])
    const convertProperties = (props) => {
      if (!props) return {};

      const converted = {};
      for (const [key, value] of Object.entries(props)) {
        converted[key] = {
          ...value,
          // Claude n√£o aceita array de types, apenas string
          type: Array.isArray(value.type) ? value.type[0] : value.type
        };

        // Remover campos que Claude n√£o aceita
        delete converted[key].default;
      }
      return converted;
    };

    return {
      name: func.name,
      description: func.description,
      input_schema: {
        type: 'object',
        properties: convertProperties(func.parameters.properties),
        required: func.parameters.required || []
      }
    };
  });
}

// ü§ñ HELPER: Chamar Claude (Anthropic) com Tools
// =====================================================
/**
 * Chama Claude da Anthropic com suporte a tools/function calling
 * @param {Object} config - Configura√ß√£o da chamada
 * @param {Array} config.messages - Array de mensagens [{role: 'user', content: '...'}]
 * @param {Array} config.tools - Array de tools (opcional)
 * @param {string} config.model - Modelo (padr√£o: claude-sonnet-4-20250514)
 * @param {number} config.max_tokens - M√°ximo de tokens (padr√£o: 4096)
 * @param {number} config.temperature - Temperatura (padr√£o: 1)
 * @returns {Object} Resposta do Claude no formato compat√≠vel com OpenAI
 */
async function callClaude({ messages, tools = null, model = 'claude-sonnet-4-20250514', max_tokens = 4096, temperature = 1 }) {
  if (!anthropic) {
    throw new Error('Claude n√£o configurado. Adicione ANTHROPIC_API_KEY no .env');
  }

  // Separar system message e adaptar tool messages
  let systemMessage = '';
  const conversationMessages = messages
    .filter(msg => {
      if (msg.role === 'system') {
        systemMessage = msg.content;
        return false;
      }
      return true;
    })
    .map(msg => {
      // Adaptar tool result messages para formato Claude
      if (msg.role === 'tool') {
        return {
          role: 'user',
          content: [{
            type: 'tool_result',
            tool_use_id: msg.tool_call_id,
            content: msg.content
          }]
        };
      }

      // Adaptar assistant messages com tool_calls para formato Claude
      if (msg.role === 'assistant' && msg.tool_calls) {
        const content = [];

        // Adicionar texto se houver
        if (msg.content) {
          content.push({
            type: 'text',
            text: msg.content
          });
        }

        // Adicionar tool_use blocks
        msg.tool_calls.forEach(toolCall => {
          content.push({
            type: 'tool_use',
            id: toolCall.id,
            name: toolCall.function.name,
            input: JSON.parse(toolCall.function.arguments)
          });
        });

        return {
          role: 'assistant',
          content: content
        };
      }

      return msg;
    });

  // Montar config da chamada
  const config = {
    model,
    max_tokens,
    temperature,
    system: systemMessage || undefined,
    messages: conversationMessages
  };

  // Adicionar tools se fornecidas
  if (tools && tools.length > 0) {
    config.tools = convertOpenAIToolsToClaude(tools);
  }

  const response = await anthropic.messages.create(config);

  // Converter resposta Claude para formato OpenAI
  const hasToolUse = response.content.some(block => block.type === 'tool_use');

  if (hasToolUse) {
    // Claude quer chamar fun√ß√£o(√µes)
    const toolCalls = response.content
      .filter(block => block.type === 'tool_use')
      .map(block => ({
        id: block.id,
        type: 'function',
        function: {
          name: block.name,
          arguments: JSON.stringify(block.input)
        }
      }));

    // Pegar texto se houver
    const textBlock = response.content.find(block => block.type === 'text');

    return {
      choices: [{
        message: {
          role: 'assistant',
          content: textBlock ? textBlock.text : null,
          tool_calls: toolCalls
        }
      }],
      usage: {
        prompt_tokens: response.usage.input_tokens,
        completion_tokens: response.usage.output_tokens,
        total_tokens: response.usage.input_tokens + response.usage.output_tokens
      }
    };
  } else {
    // Resposta normal (texto)
    const textContent = response.content
      .filter(block => block.type === 'text')
      .map(block => block.text)
      .join('\n');

    return {
      choices: [{
        message: {
          role: 'assistant',
          content: textContent,
          tool_calls: null
        }
      }],
      usage: {
        prompt_tokens: response.usage.input_tokens,
        completion_tokens: response.usage.output_tokens,
        total_tokens: response.usage.input_tokens + response.usage.output_tokens
      }
    };
  }
}


// ‚úÖ ADICIONE AQUI (antes de "let db = null"):
// =====================================================
// API DO BANCO DE DADOS
// =====================================================
const DB_API_URL = process.env.DB_API_URL || 'https://feiraoshowcar.com.br/db_api.php';
const DB_API_TOKEN = process.env.DB_API_TOKEN || 'bot_aira_xyz';

class DatabaseAPI {
  async connect() {
    console.log('üîå [API] Conectando...');
    return this;
  }

  async ping() {
    console.log('üèì [API] Ping...');
    return true;
  }

 async query(sql, tentativa = 1) {
  console.log(`üì§ [API] Tentativa ${tentativa}/5 - Enviando SQL...`);
  console.log('üìù [API] SQL:', sql.substring(0, 150));
  
  try {
    const params = new URLSearchParams();
    params.append('token', DB_API_TOKEN);
    params.append('sql', sql);
    
    const response = await axios.post(DB_API_URL, params.toString(), {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
        'Accept': 'application/json',
        'Referer': 'https://feiraoshowcar.com.br/'
      },
      timeout: 30000,
      maxContentLength: Infinity,
      maxBodyLength: Infinity
    });
    
    console.log('‚úÖ [API] Status:', response.status);
    
    let data = response.data;
    
    if (typeof data === 'string') {
      if (data.length === 0) {
        throw new Error('Resposta vazia');
      }
      data = JSON.parse(data);
    }
    
    if (data.erro) {
      throw new Error(data.erro);
    }
    
    console.log('‚úÖ [API]', data.dados?.length || 0, 'linhas recebidas');
    return data.dados || [];
    
  } catch (error) {
    console.error(`‚ùå [API] Tentativa ${tentativa} falhou:`, error.message);
    
    // Se for ECONNRESET e n√£o √© a √∫ltima tentativa, retry
    if (error.code === 'ECONNRESET' && tentativa < 5) {
      const delay = Math.min(1000 * Math.pow(2, tentativa), 10000); // 2s, 4s, 8s, 10s
      console.log(`‚è≥ [API] Aguardando ${delay}ms antes de tentar novamente...`);
      await new Promise(r => setTimeout(r, delay));
      return this.query(sql, tentativa + 1);
    }
    
    throw error;
  }
}


  async execute(sql, params = []) {
    let sqlFormatado = sql;
    params.forEach(param => {
      const valor = typeof param === 'string' ? `'${param.replace(/'/g, "''")}'` : param;
      sqlFormatado = sqlFormatado.replace('?', valor);
    });

    const resultado = await this.query(sqlFormatado);
    return [resultado];
  }
}

// =====================================================
// CLASSE MYSQL - CONEX√ÉO LOCAL
// =====================================================
class DatabaseMySQL {
  constructor() {
    this.connection = null;
    this.config = {
      host: process.env.DB_HOST || 'localhost',
      port: parseInt(process.env.DB_PORT) || 3306,
      user: process.env.DB_USER || 'root',
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'u161861600_feiraoshow',
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0,
      enableKeepAlive: true,
      keepAliveInitialDelay: 0
    };
  }

  async connect() {
    try {
      console.log('üîå [MySQL] Conectando ao MySQL localhost...');
      console.log(`üìç [MySQL] Host: ${this.config.host}:${this.config.port}`);
      console.log(`üìç [MySQL] Database: ${this.config.database}`);
      console.log(`üìç [MySQL] User: ${this.config.user}`);

      this.connection = await mysql.createPool(this.config);

      console.log('‚úÖ [MySQL] Pool de conex√µes criado com sucesso!');
      return this;
    } catch (error) {
      console.error('‚ùå [MySQL] Erro ao conectar:', error.message);
      throw error;
    }
  }

  async ping() {
    try {
      console.log('üèì [MySQL] Testando conex√£o...');
      await this.connection.query('SELECT 1');
      console.log('‚úÖ [MySQL] Conex√£o ativa!');
      return true;
    } catch (error) {
      console.error('‚ùå [MySQL] Erro no ping:', error.message);
      return false;
    }
  }

  async query(sql, params = []) {
    try {
      console.log(`üì§ [MySQL] Executando query...`);
      console.log(`üìù [MySQL] SQL: ${sql.substring(0, 150)}${sql.length > 150 ? '...' : ''}`);

      const [rows] = await this.connection.query(sql, params);

      console.log(`‚úÖ [MySQL] Query executada: ${Array.isArray(rows) ? rows.length : 0} linhas`);
      return rows;
    } catch (error) {
      console.error(`‚ùå [MySQL] Erro na query:`, error.message);
      throw error;
    }
  }

  async execute(sql, params = []) {
    return this.query(sql, params);
  }

  async close() {
    if (this.connection) {
      await this.connection.end();
      console.log('üîå [MySQL] Conex√£o fechada');
    }
  }
}


let db = null;
let gerenciadorAgendamentos = null;

// =====================================================
// DEFINI√á√ÉO DAS FUN√á√ïES (FORMATO NOVO - TOOLS)
// =====================================================
const FUNCOES_DISPONIVEIS = [
  {
    type: "function",
    function: {
      name: 'buscar_carros',
      description: `üöó USE ESTA FUN√á√ÉO SEMPRE que o cliente perguntar sobre ve√≠culos, pedir recomenda√ß√µes ou demonstrar interesse em comprar.

Esta fun√ß√£o:
1. Busca ve√≠culos no estoque do banco de dados
2. ENVIA AS FOTOS AUTOMATICAMENTE para o WhatsApp do cliente
3. Cada foto j√° inclui TODAS as informa√ß√µes (pre√ßo, ano, km, c√¢mbio, etc) na legenda

‚ö†Ô∏è IMPORTANTE: Ap√≥s chamar esta fun√ß√£o, voc√™ N√ÉO precisa descrever os ve√≠culos em detalhes no √°udio.
Apenas confirme que enviou (BREVE!) e pergunte qual interessou.

Exemplos de uso:
- Cliente: "Quero um carro" ‚Üí buscar_carros({})
- Cliente: "Tem Gol?" ‚Üí buscar_carros({ modelo: "Gol" })
- Cliente: "SUV at√© 80k" ‚Üí buscar_carros({ preco_max: 80000 })
- Cliente: "Carro autom√°tico 2020+" ‚Üí buscar_carros({ cambio: "automatico", ano_min: 2020 })
- Cliente: "Quero ver carros" ‚Üí buscar_carros({})

A fun√ß√£o retorna os ve√≠culos encontrados E j√° envia as fotos. Voc√™ s√≥ precisa confirmar e engajar o cliente com mensagem CURTA!

‚ö†Ô∏è Se voc√™ J√Å ENVIOU uma lista nesta conversa, N√ÉO BUSQUE NOVAMENTE a menos que cliente EXPLICITAMENTE pe√ßa "quero ver mais", "mostre outros", "tem outros carros?". Ajude ele a escolher entre os j√° mostrados.`,
      parameters: {
        type: 'object',
        properties: {
         marca: {
        type: ['string', 'null'],
        description: 'Marca do ve√≠culo (ex: Volkswagen, Fiat, Chevrolet, Honda, Toyota)'
    },
          modelo: {
        type: ['string', 'null'],
        description: 'Modelo espec√≠fico do ve√≠culo (ex: Gol, Civic, Onix, Corolla). Use SEMPRE quando cliente mencionar modelo espec√≠fico!'
    },
            tipo_veiculo: {
            type: ['string', 'null'],
            description: 'Tipo/categoria do ve√≠culo',
            enum: ['suv', 'sedan', 'hatch', 'pickup',  'luxo', 'economico', null]
          },
          preco_min: {
            type: ['number', 'null'],
            description: 'Pre√ßo m√≠nimo em reais'
          },
          preco_max: {
            type: ['number', 'null'],
            description: 'Pre√ßo m√°ximo em reais'
          },
          ano_min: {
            type: ['number', 'null'],
            description: 'Ano m√≠nimo do ve√≠culo (ex: 2018)'
          },
          ano_max: {
            type: ['number', 'null'],
            description: 'Ano m√°ximo do ve√≠culo (ex: 2024)'
          },
          cambio: {
            type: ['string', 'null'],
            description: 'Tipo de c√¢mbio',
            enum: ['automatico', 'manual', 'ambos', null]
          },
          ordenar_por: {
            type: 'string',
            description: 'Como ordenar os resultados. ‚ö†Ô∏è IMPORTANTE: Use "mais_barato" SEMPRE que cliente especificar pre√ßo m√°ximo (ex: "at√© 50 mil", "carros de at√© 30 mil") OU quando pedir explicitamente o mais barato. Use "mais_caro" quando pedir o mais caro. Use "mais_novo" quando pedir os mais novos.',
            enum: ['mais_barato', 'mais_caro', 'mais_novo', 'menor_km', 'aleatorio']
          },
          limite: {
            type: 'number',
            description: 'M√°ximo de ve√≠culos a retornar (padr√£o: 3, m√°ximo: 5)',
            default: 3,
            maximum: 3
          }
        },
        required: []
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'calcular_financiamento',
      description: 'Calcula parcelas de financiamento. Use quando cliente perguntar "quanto fica parcelado", "financiamento", "parcelas".',
      parameters: {
        type: 'object',
        properties: {
          valor_veiculo: {
            type: 'number',
            description: 'Valor total do ve√≠culo em reais'
          },
          entrada: {
            type: 'number',
            description: 'Valor da entrada em reais (padr√£o: 20% do valor)'
          },
          parcelas: {
            type: 'number',
            description: 'N√∫mero de parcelas',
            enum: [12, 24, 36, 48, 60]
          },
          taxa_juros: {
            type: 'number',
            description: 'Taxa de juros mensal em porcentagem (padr√£o: 1.5%)',
            default: 1.5
          }
        },
        required: ['valor_veiculo', 'parcelas', 'taxa_juros']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'simular_financiamento_detalhado',
      description: 'Simula financiamento completo com m√∫ltiplos cen√°rios e recomenda√ß√µes. Use quando cliente pedir simula√ß√£o detalhada ou comparar prazos.',
      parameters: {
        type: 'object',
        properties: {
          valor_veiculo: {
            type: 'number',
            description: 'Valor total do ve√≠culo em reais'
          },
          entrada: {
            type: 'number',
            description: 'Valor da entrada em reais'
          },
          parcelas: {
            type: 'number',
            description: 'N√∫mero de parcelas desejado',
            enum: [12, 24, 36, 48, 60]
          },
          renda_mensal: {
            type: 'number',
            description: 'Renda mensal do cliente (opcional, para calcular entrada ideal)'
          }
        },
        required: ['valor_veiculo']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'obter_detalhes_veiculo',
      description: 'Obt√©m detalhes completos e ENVIA FOTOS de um ve√≠culo espec√≠fico da lista enviada anteriormente. Use quando cliente pedir para ver/mostrar um ve√≠culo ("me mostra a ranger", "quero ver o primeiro", "me fala do civic 2020").',
      parameters: {
        type: 'object',
        properties: {
          identificacao: {
            type: 'string',
            description: 'Como identificar o ve√≠culo: pode ser o nome/marca/modelo (ex: "Ranger", "Honda City"), a posi√ß√£o na lista (ex: "primeiro", "segundo", "op√ß√£o 1"), ou o ano (ex: "2020") se for √∫nico na lista'
          },
          incluir_fotos: {
            type: 'boolean',
            description: 'Se deve incluir URLs das fotos do ve√≠culo',
            default: true
          }
        },
        required: ['identificacao']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'comparar_veiculos',
      description: 'Compara dois ou tr√™s ve√≠culos lado a lado. Use quando cliente perguntar "qual a diferen√ßa", "compare", "qual vale mais".',
      parameters: {
        type: 'object',
        properties: {
          veiculos_ids: {
            type: 'array',
            items: { type: 'number' },
            description: 'Array com 2 ou 3 IDs dos ve√≠culos para comparar',
            minItems: 2,
            maxItems: 3
          },
          criterios: {
            type: 'array',
            items: { type: 'string' },
            description: 'Crit√©rios de compara√ß√£o (preco, ano, km, cambio)',
            default: ['preco', 'ano', 'km', 'cambio']
          }
        },
        required: ['veiculos_ids']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'consultar_score',
      description: 'Consulta o score de cr√©dito do cliente no Serasa/SPC para avaliar aprova√ß√£o de financiamento. Use IMEDIATAMENTE quando: 1) Cliente pedir financiamento/parcelamento, 2) Perguntar sobre parcelas, 3) Demonstrar interesse em comprar com cr√©dito. SEMPRE reforce seguran√ßa ("sistema seguro", "avalia√ß√£o r√°pida") antes de pedir CPF.',
      parameters: {
        type: 'object',
        properties: {
          cpf: {
            type: 'string',
            description: 'CPF do cliente (com ou sem formata√ß√£o - pontos e tra√ßos s√£o removidos automaticamente)'
          },
          nome_cliente: {
            type: 'string',
            description: 'Nome do cliente para personalizar a resposta'
          },
          tel: {
            type: 'string',
            description: 'Telefone do cliente (para salvar dados no contexto)'
          }
        },
        required: ['cpf']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'consultar_valor_fipe',
      description: 'Consulta o valor FIPE (tabela oficial de pre√ßos) de um ve√≠culo. SEMPRE USE esta fun√ß√£o quando o cliente: 1) Perguntar "quanto vale na FIPE", "qual o valor FIPE", "t√° na FIPE", "pre√ßo de mercado"; 2) Mencionar que tem carro para dar de entrada E perguntar quanto vale. Use IMEDIATAMENTE se marca, modelo e ano forem mencionados, n√£o pe√ßa confirma√ß√£o.',
      parameters: {
        type: 'object',
        properties: {
          marca: {
            type: 'string',
            description: 'Marca do ve√≠culo (ex: Honda, Chevrolet, Fiat, Volkswagen). Inferir da mensagem do cliente.'
          },
          modelo: {
            type: 'string',
            description: 'Modelo do ve√≠culo (ex: Civic, Onix, Palio, Gol). Inferir da mensagem do cliente.'
          },
          ano: {
            type: 'number',
            description: 'Ano do ve√≠culo. Inferir da mensagem do cliente. Se n√£o informado, deixar null para usar ano mais recente.'
          }
        },
        required: ['marca', 'modelo']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'comparar_preco_fipe',
      description: 'Compara o pre√ßo de venda de um ve√≠culo com o valor da tabela FIPE. Use quando cliente perguntar se o pre√ßo est√° bom, abaixo ou acima da FIPE.',
      parameters: {
        type: 'object',
        properties: {
          marca: {
            type: 'string',
            description: 'Marca do ve√≠culo'
          },
          modelo: {
            type: 'string',
            description: 'Modelo do ve√≠culo'
          },
          ano: {
            type: 'number',
            description: 'Ano do ve√≠culo'
          },
          preco_venda: {
            type: 'number',
            description: 'Pre√ßo de venda do ve√≠culo em reais'
          }
        },
        required: ['marca', 'modelo', 'ano', 'preco_venda']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'obter_estatisticas_estoque',
      description: 'Retorna estat√≠sticas do estoque. Use quando cliente perguntar "quantos carros tem", "quais marcas dispon√≠veis", "mais vendidos".',
      parameters: {
        type: 'object',
        properties: {
          tipo_estatistica: {
            type: 'string',
            description: 'Tipo de estat√≠stica a retornar',
            enum: ['geral', 'por_marca', 'por_ano', 'por_preco', 'mais_vendidos']
          }
        },
        required: ['tipo_estatistica']
      }
    }
  },
  {
    type: "function",
    function: {
      name: 'agendar_visita',
      description: `üìÖ AGENDE UMA VISITA quando o cliente demonstrar interesse em fechar a venda de um ve√≠culo espec√≠fico.

‚ö†Ô∏è IMPORTANTE: Use esta fun√ß√£o quando:
- Cliente quer ver o ve√≠culo pessoalmente
- Cliente est√° pronto para fechar neg√≥cio/financiamento mas precisa ver presencialmente
- Cliente pede para marcar visita/test drive
- Cliente confirma interesse em comprar mas quer ir at√© a loja

NUNCA use esta fun√ß√£o se:
- Cliente ainda est√° apenas pesquisando
- Ainda n√£o escolheu ve√≠culo espec√≠fico
- Est√° apenas comparando pre√ßos

O sistema ir√°:
1. Registrar o agendamento no banco de dados
2. Notificar o vendedor respons√°vel pelo ve√≠culo
3. Aguardar aprova√ß√£o do vendedor
4. Confirmar com o cliente quando aprovado`,
      parameters: {
        type: 'object',
        properties: {
          veiculo_id: {
            type: 'number',
            description: 'ID do ve√≠culo de interesse (obtido de buscar_carros ou obter_detalhes_veiculo)'
          },
          data_agendamento: {
            type: 'string',
            description: 'Data da visita no formato YYYY-MM-DD (ex: 2025-10-15)'
          },
          hora_agendamento: {
            type: 'string',
            description: 'Hor√°rio da visita no formato HH:MM (ex: 14:30)'
          },
          tipo_interesse: {
            type: 'string',
            description: 'Tipo de interesse do cliente',
            enum: ['financiamento', 'visita_loja', 'test_drive'],
            default: 'visita_loja'
          },
          valor_entrada: {
            type: 'number',
            description: 'Valor de entrada se for financiamento (opcional)'
          },
          numero_parcelas: {
            type: 'number',
            description: 'N√∫mero de parcelas se for financiamento (opcional)'
          },
          tem_veiculo_troca: {
            type: 'boolean',
            description: 'Se o cliente tem ve√≠culo para dar como parte do pagamento',
            default: false
          },
          observacoes: {
            type: 'string',
            description: 'Observa√ß√µes adicionais sobre a visita ou prefer√™ncias do cliente'
          }
        },
        required: ['veiculo_id', 'data_agendamento', 'hora_agendamento']
      }
    }
  }
];

// =====================================================
// IMPLEMENTA√á√ÉO DAS FUN√á√ïES
// =====================================================
class FuncoesVeiculos {
  constructor(repo) {
    this.repo = repo;
    this.simulador = new SimuladorFinanciamento();
  }

  // Fun√ß√£o 1: Buscar Carros
  async buscar_carros(params) {
    log.function(`Buscando carros: ${JSON.stringify(params)}`);

    // ‚õî BLOQUEAR SE J√Å ENVIOU LISTA (a menos que cliente pe√ßa explicitamente mais op√ß√µes)
    const tel = params.tel || this.currentTel; // Pegar telefone do contexto
    if (tel && this.listaEnviada?.get(tel)) {
      const mensagemCliente = (params.mensagem || '').toLowerCase();
      const pedindoMaisOpcoes = /\b(mais|outros?|diferentes|outras op√ß√µes|ver mais|mostre mais|tem mais|quero ver)\b/i.test(mensagemCliente);

      if (!pedindoMaisOpcoes) {
        log.warning('‚õî [BLOQUEIO] Lista j√° foi enviada! Cliente n√£o pediu explicitamente mais op√ß√µes.');
        return {
          erro: 'lista_ja_enviada',
          mensagem: 'Voc√™ j√° viu os ve√≠culos que separei! Qual deles te interessou mais? Posso enviar mais fotos ou detalhes de algum espec√≠fico.',
          bloqueio: true
        };
      } else {
        log.info('‚úÖ [PERMISS√ÉO] Cliente pediu explicitamente mais op√ß√µes, liberando nova busca...');
        this.listaEnviada.delete(tel); // Resetar flag para permitir nova lista
      }
    }

    let veiculos = [...this.repo.veiculos];
    
    // Filtro por marca
if (params.marca) {
  veiculos = veiculos.filter(v =>
    v.marca && v.marca.toLowerCase().includes(params.marca.toLowerCase())
  );
}

// Filtro por modelo (PRIORIDADE M√ÅXIMA - deve filtrar exatamente o modelo)
if (params.modelo) {
  veiculos = veiculos.filter(v => {
    // Busca no campo modelo OU no nome completo
    const modelo = (v.modelo || '').toLowerCase();
    const nome = (v.nome || '').toLowerCase();
    const parametroModelo = params.modelo.toLowerCase();

    return modelo.includes(parametroModelo) || nome.includes(parametroModelo);
  });
}

// Filtro por tipo (mant√©m os j√° filtrados)
if (params.tipo_veiculo) {
  const veiculosTemp = veiculos; // ‚Üê salva os j√° filtrados
  
  switch (params.tipo_veiculo) {
    case 'pickup':
      veiculos = veiculosTemp.filter(v => { // ‚Üê usa veiculosTemp
        const n = (v.nome || '').toLowerCase();
        return ['hilux', 's10', 'ranger', 'amarok', 'toro'].some(p => n.includes(p));
      });
      break;
    case 'suv':
      veiculos = veiculosTemp.filter(v => {
        const n = (v.nome || '').toLowerCase();
        return ['compass', 'tucson', 'creta', 'duster', 'kicks', 'tracker', 'ecosport'].some(s => n.includes(s));
      });
      break;
      }
    }
    
    // Filtro por ano
    if (params.ano_min) {
      veiculos = veiculos.filter(v => parseInt(v.ano) >= params.ano_min);
    }
    if (params.ano_max) {
      veiculos = veiculos.filter(v => parseInt(v.ano) <= params.ano_max);
    }
    
    // Filtro por pre√ßo
    if (params.preco_min) {
      veiculos = veiculos.filter(v => v.preco >= params.preco_min);
    }
    if (params.preco_max) {
      // Incluir ve√≠culos at√© 10% acima do pre√ßo (para oferecer op√ß√µes melhores)
      const precoComMargem = params.preco_max * 1.1;
      veiculos = veiculos.filter(v => v.preco <= precoComMargem);
    }
    
    // Filtro por c√¢mbio
    if (params.cambio && params.cambio !== 'ambos') {
      if (params.cambio === 'automatico') {
        veiculos = veiculos.filter(v => v.cambio.toLowerCase().includes('auto'));
      } else {
        veiculos = veiculos.filter(v => v.cambio.toLowerCase().includes('manual'));
      }
    }

    // ========== ORDENAR RESULTADOS ==========
    if (params.ordenar_por) {
      switch (params.ordenar_por) {
        case 'mais_barato':
          // Se tem pre√ßo m√°ximo, ordenar DECRESCENTE (do limite para baixo)
          if (params.preco_max) {
            veiculos.sort((a, b) => b.preco - a.preco);
            log.info('üí∞ Ordenado por pre√ßo DECRESCENTE (do limite para baixo)');
          } else {
            veiculos.sort((a, b) => a.preco - b.preco);
            log.info('üí∞ Ordenado por pre√ßo: mais barato primeiro');
          }
          break;
        case 'mais_caro':
          veiculos.sort((a, b) => b.preco - a.preco);
          log.info('üíé Ordenado por pre√ßo: mais caro primeiro');
          break;
        case 'mais_novo':
          veiculos.sort((a, b) => parseInt(b.ano) - parseInt(a.ano));
          log.info('üìÖ Ordenado por ano: mais novo primeiro');
          break;
        case 'menor_km':
          veiculos.sort((a, b) => parseInt(a.km) - parseInt(b.km));
          log.info('üõ£Ô∏è Ordenado por quilometragem: menor km primeiro');
          break;
        case 'aleatorio':
        default:
          // Embaralhar array usando Fisher-Yates
          for (let i = veiculos.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [veiculos[i], veiculos[j]] = [veiculos[j], veiculos[i]];
          }
          log.info('üé≤ Ve√≠culos aleatorizados');
          break;
      }
    } else {
      // Se n√£o especificar ordena√ß√£o, aleatorizar (comportamento padr√£o)
      const temFiltrosEspecificos = params.preco_min || params.preco_max || params.ano_min || params.ano_max;

      if (!temFiltrosEspecificos && veiculos.length > 3) {
        // Embaralhar array usando Fisher-Yates
        for (let i = veiculos.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [veiculos[i], veiculos[j]] = [veiculos[j], veiculos[i]];
        }
        log.info('üé≤ Ve√≠culos aleatorizados (sem filtros espec√≠ficos)');
      } else if (temFiltrosEspecificos) {
        log.info('üéØ Filtros espec√≠ficos aplicados, mantendo ordem original');
      }
    }

    // ========== VALIDA√á√ÉO: SE N√ÉO ENCONTROU NADA ==========
    if (veiculos.length === 0) {
      log.warning('‚ö†Ô∏è Nenhum ve√≠culo encontrado com os filtros especificados');
      return {
        erro: 'nao_encontrado',
        mensagem: 'Desculpa, n√£o encontrei nenhum ve√≠culo com essas caracter√≠sticas. Pode me contar de novo o que voc√™ procura?',
        filtros_usados: params
      };
    }

    // ========== FILTRAR VE√çCULOS J√Å MOSTRADOS ==========
    const lucas = params.lucas || this.lucas; // Refer√™ncia ao objeto principal
    if (tel && lucas) {
      const veiculosJaMostrados = lucas.getVeiculosJaMostrados(tel);
      const totalAntesFiltro = veiculos.length;

      if (veiculosJaMostrados.size > 0) {
        log.info(`[MEMORIA] üìã Cliente j√° viu ${veiculosJaMostrados.size} ve√≠culos antes`);

        // Filtrar ve√≠culos que ainda n√£o foram mostrados
        veiculos = veiculos.filter(v => !veiculosJaMostrados.has(v.id));

        const totalDepoisFiltro = veiculos.length;
        log.info(`[MEMORIA] ‚úÖ Filtrados: ${totalAntesFiltro} total ‚Üí ${totalDepoisFiltro} novos (removidos ${totalAntesFiltro - totalDepoisFiltro} j√° mostrados)`);

        // ‚ö†Ô∏è SE N√ÉO HOUVER MAIS VE√çCULOS NOVOS
        if (veiculos.length === 0) {
          log.warning('‚ö†Ô∏è [MEMORIA] Todos os ve√≠culos com esse crit√©rio j√° foram mostrados!');

          // Oferecer limpar hist√≥rico para ver novamente ou mudar crit√©rio
          return {
            erro: 'todos_ja_mostrados',
            mensagem: 'Opa! Eu j√° mostrei todos os ve√≠culos que temos com essas caracter√≠sticas. Quer que eu mostre novamente os mesmos, ou prefere buscar com outro crit√©rio (outra marca, pre√ßo, ano)?',
            total_ja_mostrados: veiculosJaMostrados.size,
            bloqueio: true
          };
        }
      }
    }

    // Limitar resultados
    const limite = Math.min(params.limite || 3, 3);
    const veiculosParaEnviar = veiculos.slice(0, limite);

    log.success(`Encontrados ${veiculosParaEnviar.length} ve√≠culos NOVOS para mostrar`);

    // ========== SALVAR IDS DOS VE√çCULOS QUE SER√ÉO MOSTRADOS ==========
    if (tel && lucas) {
      const idsParaSalvar = veiculosParaEnviar.map(v => v.id);
      lucas.salvarVeiculosMostrados(tel, idsParaSalvar);
    }

    return {
    total_encontrado: veiculosParaEnviar.length,
    veiculos: veiculosParaEnviar.map(v => ({
      id: v.id,
      nome: v.nome,
      marca: v.marca,
      modelo: v.modelo,
      ano: v.ano,
      preco: v.preco,
      km: v.km,
      cambio: v.cambio,
      tipo_carroceria: v.tipo_carroceria,
      foto: v.foto, // ‚Üê CAMPO FALTANTE!
      destaque: v.is_featured === '1',
      oferta: v.is_special_offer === 1,
      resumo: `${v.nome} ${v.ano} - R$ ${v.preco.toLocaleString('pt-BR')}`
    }))
  };
  }

  // Fun√ß√£o 2: Detalhes do Ve√≠culo
  async obter_detalhes_veiculo(params) {
    log.function(`Obtendo detalhes do ve√≠culo ${params.veiculo_id}`);
    
    const veiculo = this.repo.porId(params.veiculo_id);
    if (!veiculo) {
      return { erro: 'Ve√≠culo n√£o encontrado' };
    }
    
    let fotos = [];
    if (params.incluir_fotos) {
      fotos = await this.repo.buscarFotosVeiculo(params.veiculo_id);
    }
    
    return {
      ...veiculo,
      fotos: fotos,
      url: `${BASE_URL}/car/${params.veiculo_id}`
    };
  }

  // Fun√ß√£o 3: Calcular Financiamento
  async calcular_financiamento(params) {
    log.function(`Calculando financiamento: R$ ${params.valor_veiculo}`);

    // ‚úÖ VERIFICAR SE CLIENTE TEM VE√çCULO DE TROCA
    const tel = this.tel; // Telefone do cliente atual
    const dadosTroca = this.lucas?.veiculoTroca?.get(tel);

    // ========== ENTRADA ==========
    let entrada = params.entrada;

    // Se n√£o especificou entrada MAS tem ve√≠culo de troca, usar valor FIPE
    if (!entrada && dadosTroca && dadosTroca.valorFipe) {
      entrada = dadosTroca.valorFipe;
      log.info(`‚úÖ [FINANCIAMENTO] Usando ve√≠culo de troca como entrada: ${dadosTroca.modelo} ${dadosTroca.ano} = R$ ${entrada.toLocaleString('pt-BR')}`);
    } else if (!entrada) {
      entrada = params.valor_veiculo * 0.2; // Entrada m√≠nima padr√£o (20%)
      log.info(`üí∞ [FINANCIAMENTO] Usando entrada padr√£o de 20%: R$ ${entrada.toLocaleString('pt-BR')}`);
    }

    // Validar entrada m√≠nima
    const entradaMinima = params.valor_veiculo * 0.2;
    if (entrada < entradaMinima) {
      log.warning(`‚ö†Ô∏è [FINANCIAMENTO] Entrada abaixo do m√≠nimo! Exigida: R$ ${entradaMinima.toLocaleString('pt-BR')}`);
      entrada = entradaMinima;
    }

    // ========== TAXA DE JUROS ==========
    // Taxa padr√£o: 1.99% ao m√™s (se n√£o especificada)
    const taxaJuros = params.taxa_juros || 1.99;
    const taxaMensal = taxaJuros / 100;

    // ========== PARCELAS ==========
    const parcelas = params.parcelas || 48;

    // ========== VALOR FINANCIADO ==========
    const valorFinanciado = params.valor_veiculo - entrada;

    // ========== IOF (0.38% do valor financiado) ==========
    const iof = valorFinanciado * 0.0038;
    const valorFinanciadoComIOF = valorFinanciado + iof;

    // ========== F√ìRMULA PRICE ==========
    const fatorPrice = (taxaMensal * Math.pow(1 + taxaMensal, parcelas)) /
                       (Math.pow(1 + taxaMensal, parcelas) - 1);

    const valorParcela = valorFinanciadoComIOF * fatorPrice;

    // ========== TOTAIS ==========
    const totalParcelas = valorParcela * parcelas;
    const totalPago = entrada + totalParcelas;
    const totalJuros = totalParcelas - valorFinanciado; // Juros sobre o valor original (sem IOF)

    log.success(`‚úÖ [FINANCIAMENTO] ${parcelas}x de R$ ${valorParcela.toFixed(2)} (Total: R$ ${totalPago.toFixed(2)})`);

    return {
      sucesso: true,
      valor_veiculo: params.valor_veiculo,
      entrada: {
        valor: entrada,
        percentual: ((entrada / params.valor_veiculo) * 100).toFixed(1) + '%',
        veiculo_troca: dadosTroca ? `${dadosTroca.modelo} ${dadosTroca.ano}` : null
      },
      valor_financiado: valorFinanciado,
      iof: iof,
      valor_financiado_com_iof: valorFinanciadoComIOF,
      numero_parcelas: parcelas,
      valor_parcela: Math.round(valorParcela * 100) / 100,
      taxa_juros_mensal: taxaJuros + '%',
      taxa_juros_anual: (taxaJuros * 12).toFixed(2) + '%',
      total_a_pagar: Math.round(totalPago * 100) / 100,
      total_juros: Math.round(totalJuros * 100) / 100,
      observacoes: [
        'üí∞ IOF de R$ ' + iof.toFixed(2) + ' j√° inclu√≠do nas parcelas',
        'üìä Sistema PRICE (parcelas fixas)',
        '‚ö†Ô∏è Valores sujeitos √† aprova√ß√£o banc√°ria'
      ]
    };
  }

  // Fun√ß√£o 3.5: Simular Financiamento Detalhado
  async simular_financiamento_detalhado(params) {
    log.function(`Simulando financiamento detalhado: R$ ${params.valor_veiculo}`);

    const simulador = this.simulador;

    // ‚úÖ VERIFICAR SE CLIENTE TEM VE√çCULO DE TROCA
    const tel = this.tel;
    const dadosTroca = this.lucas?.veiculoTroca?.get(tel);

    let entrada = params.entrada;

    // Se n√£o especificou entrada MAS tem ve√≠culo de troca, usar valor FIPE
    if (!entrada && dadosTroca && dadosTroca.valorFipe) {
      entrada = dadosTroca.valorFipe;
      log.info(`‚úÖ [SIMULA√á√ÉO] Usando ve√≠culo de troca: ${dadosTroca.modelo} ${dadosTroca.ano} = R$ ${entrada}`);
    }

    // Se tem entrada e parcelas espec√≠ficas
    if (entrada && params.parcelas) {
      const resultado = simulador.simular(
        params.valor_veiculo,
        entrada,
        params.parcelas,
        'bom'
      );

      // ‚úÖ Adicionar info da troca no resultado
      if (dadosTroca) {
        resultado.entrada_veiculo_troca = `${dadosTroca.modelo} ${dadosTroca.ano}`;
      }

      return resultado;
    }

    // Se tem renda mensal, calcular entrada ideal
    if (params.renda_mensal) {
      const entradaIdeal = simulador.calcularEntradaIdeal(
        params.valor_veiculo,
        params.renda_mensal
      );

      if (entradaIdeal.entrada_numero) {
        const resultado = simulador.simular(
          params.valor_veiculo,
          entradaIdeal.entrada_numero,
          48,
          'bom'
        );

        // ‚úÖ Adicionar info da troca no resultado
        if (dadosTroca) {
          resultado.entrada_veiculo_troca = `${dadosTroca.modelo} ${dadosTroca.ano}`;
        }

        return resultado;
      }
    }

    // Comparar cen√°rios - usar entrada da troca se dispon√≠vel
    if (!entrada) {
      // ‚ö†Ô∏è PADRONIZADO: 20% (antes estava 30%)
      entrada = params.valor_veiculo * 0.2;
      log.info(`üí∞ [SIMULA√á√ÉO] Usando entrada padr√£o de 20%: R$ ${entrada.toLocaleString('pt-BR')}`);
    }

    const resultado = simulador.compararCenarios(params.valor_veiculo, entrada);

    // ‚úÖ Adicionar info da troca no resultado
    if (dadosTroca) {
      resultado.entrada_veiculo_troca = `${dadosTroca.modelo} ${dadosTroca.ano}`;
    }

    return resultado;
  }

  // Fun√ß√£o 3.6: Gerar Planilha de Financiamento (3 op√ß√µes)
  async gerarPlanilhaFinanciamento(valorVeiculo, tel) {
    log.function(`Gerando planilha de financiamento: R$ ${valorVeiculo}`);

    const dadosTroca = this.veiculoTroca?.get(tel);
    const veiculoNome = this.veiculoInteresse?.get(tel)?.nome || 'o ve√≠culo';

    // ========== ENTRADA ==========
    let entrada = 0;
    let textoEntrada = '';

    if (dadosTroca && dadosTroca.valorFipe) {
      entrada = dadosTroca.valorFipe;
      textoEntrada = `\nüí∞ Entrada: R$ ${this.formatarMoeda(entrada)} (${dadosTroca.modelo} ${dadosTroca.ano})`;
    } else {
      // Se n√£o tem troca, usar entrada m√≠nima padr√£o (20%)
      entrada = valorVeiculo * 0.2;
      textoEntrada = `\nüí∞ Entrada m√≠nima (20%): R$ ${this.formatarMoeda(entrada)}`;
    }

    // ========== C√ÅLCULOS COM IOF ==========
    const valorFinanciado = valorVeiculo - entrada;
    const iof = valorFinanciado * 0.0038; // 0.38% do valor financiado
    const valorFinanciadoComIOF = valorFinanciado + iof;

    // Gerar 3 op√ß√µes de parcelas
    const opcoes = [
      { parcelas: 36, taxa: 1.99 },
      { parcelas: 48, taxa: 1.99 },
      { parcelas: 60, taxa: 1.99 }
    ];

    let planilha = `üìä *SIMULA√á√ÉO DE FINANCIAMENTO*\n`;
    planilha += `üöó Ve√≠culo: ${veiculoNome}\n`;
    planilha += `üíµ Valor: R$ ${this.formatarMoeda(valorVeiculo)}${textoEntrada}\n`;
    planilha += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

    opcoes.forEach((opcao, index) => {
      const taxaMensal = opcao.taxa / 100;

      // ‚ö†Ô∏è CORRIGIDO: Aplicar IOF no c√°lculo (valorFinanciadoComIOF)
      const fatorPrice = (taxaMensal * Math.pow(1 + taxaMensal, opcao.parcelas)) /
                         (Math.pow(1 + taxaMensal, opcao.parcelas) - 1);
      const valorParcela = valorFinanciadoComIOF * fatorPrice;

      planilha += `*Op√ß√£o ${index + 1}:*\n`;
      planilha += `   ${opcao.parcelas}x de *R$ ${this.formatarMoeda(Math.round(valorParcela))}*\n`;
      planilha += `   Taxa: ${opcao.taxa}% ao m√™s\n\n`;
    });

    planilha += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    planilha += `üí° *Qual dessas op√ß√µes fica melhor pra voc√™?*\n`;
    planilha += `\n‚ö†Ô∏è IOF de R$ ${this.formatarMoeda(iof)} j√° inclu√≠do`;

    return planilha;
  }

  // Fun√ß√£o 4: Comparar Ve√≠culos
  async comparar_veiculos(params) {
    log.function(`Comparando ${params.veiculos_ids.length} ve√≠culos`);
    
    const veiculos = params.veiculos_ids.map(id => this.repo.porId(id)).filter(Boolean);
    
    if (veiculos.length < 2) {
      return { erro: 'Pelo menos 2 ve√≠culos s√£o necess√°rios para compara√ß√£o' };
    }
    
    return {
      comparacao: veiculos.map(v => ({
        id: v.id,
        nome: v.nome,
        marca: v.marca,
        ano: v.ano,
        preco: v.preco,
        km: v.km,
        cambio: v.cambio,
        tipo: v.tipo_carroceria
      })),
      resumo: {
        mais_barato: veiculos.reduce((prev, curr) => prev.preco < curr.preco ? prev : curr),
        mais_novo: veiculos.reduce((prev, curr) => parseInt(prev.ano) > parseInt(curr.ano) ? prev : curr),
        menor_km: veiculos.reduce((prev, curr) => parseInt(prev.km) < parseInt(curr.km) ? prev : curr)
      }
    };
  }

  // Fun√ß√£o 5: Consultar Score de Cr√©dito
  async consultar_score(params) {
    log.function(`Consultando score para CPF: ${params.cpf.substring(0, 3)}.***.***-${params.cpf.substring(9)}`);

    const serasa = new ConsultaSerasaService();
    const resultado = await serasa.consultarScorePorCPF(params.cpf);

    if (resultado.sucesso) {
      const nomeCliente = params.nome_cliente || 'Cliente';

      // Salvar score no contexto (se lucas estiver dispon√≠vel)
      if (this.scoreCliente) {
        this.scoreCliente.set(params.tel || 'current', resultado);
      }

      // Gerar resposta personalizada com IA
      const { score, analise_credito, pendencias } = resultado;

      let contextoScore = `Score: ${score.pontuacao} (${score.classificacao})
Aprovado: ${analise_credito.aprovado ? 'SIM' : 'N√ÉO'}
Pend√™ncias: ${pendencias.total_pendencias}
Recomenda√ß√£o: ${analise_credito.recomendacao}`;

      // ‚úÖ Usar Claude para gerar resposta natural
      // const respostaIA = await openai.chat.completions.create({
      //   model: 'gpt-4o',
      //   messages: [{
      //     role: 'system',
      //     content: `Voc√™ √© Aira, vendedora HUMANA emp√°tica e consultiva.
      //   ...
      //   }],
      //   temperature: 0.9,
      //   max_tokens: 120
      // });

      const respostaFinal = await callClaudeInsteadOfOpenAI(this.anthropic, {
        messages: [{
          role: 'system',
          content: `Voc√™ √© Aira, vendedora HUMANA emp√°tica e consultiva.

Acabou de consultar o score do cliente ${nomeCliente}.

DADOS DA CONSULTA:
${contextoScore}

INSTRU√á√ïES:
1. ${analise_credito.aprovado ?
  'APROVADO: Seja empolgada! Confirme que t√° tudo certo e mencione a entrada recomendada de forma positiva' :
  'N√ÉO APROVADO: Seja emp√°tica, n√£o assuste o cliente. Ofere√ßa alternativas (familiar no CPF, entrada maior, ve√≠culo de troca)'}

2. Se houver pend√™ncias: mencione de forma leve, sem drama

3. SEMPRE ofere√ßa pr√≥ximo passo concreto

4. Seja HUMANA e NATURAL (voc√™ n√£o √© rob√¥!)

5. M√°ximo 3 linhas

EXEMPLO SE APROVADO:
"${nomeCliente}, deu tudo certo! Seu score t√° √≥timo (${score.pontuacao} pontos)! Posso fazer com entrada de 30%, que tal?"

EXEMPLO SE REPROVADO:
"${nomeCliente}, o score t√° um pouco baixo (${score.pontuacao} pontos). Mas calma! Voc√™ tem um familiar que poderia ceder o CPF? Ou consegue dar uma entrada maior? A gente resolve!"

Sua resposta natural:`
        }],
        temperature: 0.9,
        max_tokens: 120
      });

      return {
        resposta: respostaFinal,
        tipo: 'texto',
        dados_score: {
          pontuacao: score.pontuacao,
          classificacao: score.classificacao,
          aprovado: analise_credito.aprovado,
          pendencias: pendencias.total_pendencias,
          entrada_recomendada: this.extrairEntradaRecomendada(analise_credito.recomendacao)
        }
      };

    } else {
      // ‚úÖ Fallback com Claude
      // const respostaErro = await openai.chat.completions.create({ ... });

      const respostaErro = await callClaudeInsteadOfOpenAI(this.anthropic, {
        messages: [{
          role: 'system',
          content: `Voc√™ √© Aira. A consulta de score falhou.

Seja natural e ofere√ßa alternativas:
- Perguntar se tem familiar com CPF
- Oferecer entrada maior
- Oferecer ve√≠culo de troca

M√°ximo 2 linhas, seja emp√°tica!`
        }],
        temperature: 0.9,
        max_tokens: 80
      });

      return {
        resposta: respostaErro,
        tipo: 'texto',
        erro: resultado.erro
      };
    }
  }

  // M√©todo auxiliar para extrair percentual de entrada
  extrairEntradaRecomendada(recomendacao) {
    const match = recomendacao.match(/(\d+)%/);
    return match ? parseInt(match[1]) : 30; // Padr√£o 30%
  }

  // Fun√ß√£o 6: Consultar Valor FIPE
  async consultar_valor_fipe(params) {
    log.function(`Consultando FIPE: ${params.marca} ${params.modelo} ${params.ano || 'ano recente'}`);

    // ========== DEBUG COMPLETO FIPE ==========
    console.log('\nüîç ========== DEBUG FIPE ==========');
    console.log('üìã Par√¢metros recebidos:', JSON.stringify(params, null, 2));
    console.log(`üöó Marca: "${params.marca}"`);
    console.log(`üöô Modelo: "${params.modelo}"`);
    console.log(`üìÖ Ano: "${params.ano}"`);
    console.log(`‚õΩ Combust√≠vel: "${params.combustivel || 'n√£o informado'}"`);
    console.log(`üîß Motor: "${params.motor || 'n√£o informado'}"`);

    try {
      console.log('\nüì° Chamando API FIPE...');
      const resultado = await consultarValorFipe(params.marca, params.modelo, params.ano);

      console.log('\nüì• Resposta da API FIPE:');
      console.log(JSON.stringify(resultado, null, 2));

      if (!resultado) {
        console.log('‚ùå FIPE retornou NULL');
        return {
          erro: true,
          erro_tipo: 'nao_encontrado',
          info: 'N√£o encontrei esse ve√≠culo na tabela FIPE. Preciso de mais detalhes t√©cnicos.',
          pedir_detalhes: true,
          detalhes_necessarios: 'motor (ex: 1.0, 1.6, 2.0), combust√≠vel (flex, gasolina, etc) e vers√£o (LT, LTZ, EX, etc)',
          marca: params.marca,
          modelo: params.modelo,
          ano: params.ano
        };
      }

      if (resultado.erro) {
        console.log('‚ùå FIPE retornou ERRO:', resultado.erro);
        return {
          erro: true,
          erro_tipo: 'api_error',
          info: 'Problema ao acessar tabela FIPE. Pe√ßa detalhes t√©cnicos do ve√≠culo para tentar novamente.',
          pedir_detalhes: true,
          detalhes_necessarios: 'motor (ex: 1.0, 1.6, 2.0), combust√≠vel (flex, gasolina, etc) e vers√£o completa',
          marca: params.marca,
          modelo: params.modelo,
          ano: params.ano,
          erro_original: resultado.erro
        };
      }

      console.log('‚úÖ FIPE consultada com sucesso!');
      console.log(`üí∞ Valor encontrado: ${resultado.valor_formatado}`);
      console.log('====================================\n');

      return {
        sucesso: true,
        valor_fipe: resultado.valor,
        valor_formatado: resultado.valor_formatado,
        marca: resultado.marca,
        modelo: resultado.modelo,
        ano: resultado.ano,
        combustivel: resultado.combustivel,
        mes_referencia: resultado.mes_referencia,
        codigo_fipe: resultado.codigo_fipe
      };

    } catch (error) {
      console.log('\n‚ùå EXCE√á√ÉO ao consultar FIPE:', error.message);
      console.log('Stack:', error.stack);
      console.log('====================================\n');

      log.error('[FIPE] Erro ao consultar:', error.message);
      return {
        erro: true,
        erro_tipo: 'exception',
        info: 'Erro t√©cnico ao consultar FIPE. Pe√ßa a vers√£o completa do ve√≠culo para tentar novamente.',
        pedir_detalhes: true,
        detalhes_necessarios: 'motor (ex: 1.0, 1.6, 2.0), combust√≠vel (flex, gasolina, diesel, etc) e vers√£o exata (ex: LTZ, Touring, etc)',
        marca: params.marca,
        modelo: params.modelo,
        ano: params.ano,
        erro_original: error.message
      };
    }
  }

  // Fun√ß√£o 6: Comparar Pre√ßo com FIPE
  async comparar_preco_fipe(params) {
    log.function(`Comparando com FIPE: ${params.marca} ${params.modelo} ${params.ano} - R$ ${params.preco_venda}`);

    try {
      const resultado = await compararComFipe(
        params.marca,
        params.modelo,
        params.ano,
        params.preco_venda
      );

      if (!resultado) {
        return {
          erro: 'N√£o foi poss√≠vel consultar a tabela FIPE',
          preco_venda: params.preco_venda
        };
      }

      if (resultado.erro) {
        return resultado;
      }

      return {
        sucesso: true,
        valor_fipe: resultado.valor_fipe,
        valor_fipe_formatado: resultado.valor_fipe_formatado,
        preco_venda: resultado.preco_venda,
        diferenca: resultado.diferenca,
        percentual: resultado.percentual,
        avaliacao: resultado.avaliacao,
        mes_referencia: resultado.mes_referencia
      };

    } catch (error) {
      log.error('[FIPE] Erro ao comparar:', error.message);
      return {
        erro: 'Erro ao comparar com tabela FIPE',
        detalhes: error.message
      };
    }
  }

  // Fun√ß√£o 7: Estat√≠sticas
  async obter_estatisticas_estoque(params) {
    log.function(`Obtendo estat√≠sticas: ${params.tipo_estatistica}`);
    
    const veiculos = this.repo.veiculos;
    
    switch (params.tipo_estatistica) {
      case 'geral':
        return {
          total_veiculos: veiculos.length,
          total_marcas: [...new Set(veiculos.map(v => v.marca))].length,
          preco_medio: Math.round(veiculos.reduce((sum, v) => sum + v.preco, 0) / veiculos.length),
          ano_medio: Math.round(veiculos.reduce((sum, v) => sum + parseInt(v.ano), 0) / veiculos.length)
        };
      
      case 'por_marca':
        const porMarca = {};
        veiculos.forEach(v => {
          porMarca[v.marca] = (porMarca[v.marca] || 0) + 1;
        });
        return { marcas: porMarca };
      
      case 'por_ano':
        const porAno = {};
        veiculos.forEach(v => {
          porAno[v.ano] = (porAno[v.ano] || 0) + 1;
        });
        return { anos: porAno };
      
      case 'mais_vendidos':
        return {
          destaques: veiculos.filter(v => v.is_featured === '1').slice(0, 5).map(v => ({
            nome: v.nome,
            preco: v.preco
          }))
        };
      
      default:
        return { erro: 'Tipo de estat√≠stica inv√°lido' };
    }
  }

  // Fun√ß√£o: Agendar Visita
  async agendar_visita(params) {
    log.function(`Agendando visita - Ve√≠culo ID: ${params.veiculo_id}, Data: ${params.data_agendamento} ${params.hora_agendamento}`);

    try {
      // Buscar informa√ß√µes do ve√≠culo
      const veiculo = await this.repo.buscarVeiculoPorId(params.veiculo_id);

      if (!veiculo) {
        return {
          sucesso: false,
          mensagem: 'Ve√≠culo n√£o encontrado no estoque.'
        };
      }

      // Obter dados do cliente do contexto (ser√° passado pelo lucas)
      const clienteTelefone = params.cliente_telefone || '';
      const clienteNome = params.cliente_nome || 'Cliente';

      // Criar agendamento usando o gerenciador
      if (!gerenciadorAgendamentos) {
        log.error('[AGENDAMENTOS] Gerenciador n√£o inicializado');
        return {
          sucesso: false,
          mensagem: 'Sistema de agendamentos n√£o dispon√≠vel no momento.'
        };
      }

      const resultado = await gerenciadorAgendamentos.criarAgendamento({
        clienteTelefone,
        clienteNome,
        veiculoId: params.veiculo_id,
        veiculoNome: veiculo.nome,
        veiculoPreco: veiculo.preco,
        dataAgendamento: params.data_agendamento,
        horaAgendamento: params.hora_agendamento,
        tipoInteresse: params.tipo_interesse || 'visita_loja',
        valorEntrada: params.valor_entrada || null,
        numeroParcelas: params.numero_parcelas || null,
        temVeiculoTroca: params.tem_veiculo_troca || false,
        observacoes: params.observacoes || null
      });

      if (resultado.sucesso) {
        log.success(`[AGENDAMENTOS] Visita agendada com sucesso! ID: ${resultado.agendamentoId}`);

        return {
          sucesso: true,
          mensagem: `‚úÖ Visita agendada com sucesso!\n\n` +
                   `üìÖ Data: ${params.data_agendamento}\n` +
                   `‚è∞ Hor√°rio: ${params.hora_agendamento}\n` +
                   `üöó Ve√≠culo: ${veiculo.nome}\n\n` +
                   `O vendedor ${resultado.lojista.nome} foi notificado e em breve confirmar√° sua visita!`,
          agendamento_id: resultado.agendamentoId,
          lojista: resultado.lojista.nome
        };
      } else {
        return {
          sucesso: false,
          mensagem: 'N√£o foi poss√≠vel agendar a visita. Tente novamente.'
        };
      }

    } catch (error) {
      log.error(`[AGENDAMENTOS] Erro ao agendar visita: ${error.message}`);
      return {
        sucesso: false,
        mensagem: 'Erro ao processar agendamento. Por favor, tente novamente.'
      };
    }
  }
}

// =====================================================
// MOTOR GPT COM FUNCTION CALLING
// =====================================================
class MotorGPTFunctions {
  constructor(funcoes) {
    this.funcoes = funcoes;
    this.historicoFuncoes = new Map();
  }

  async processarComFuncoes(mensagem, historico, etapa, contextoAdicional, lucas, tel = '', sock = null, usarFuncoes = true) {
  console.log('\nüîµ ========== INICIANDO CHAMADA GPT ==========');
  console.log('üìù Mensagem:', mensagem);
  console.log('üìä Hist√≥rico:', historico.length, 'msgs');
  console.log('üéØ Etapa:', etapa);
  console.log('üîß Usar fun√ß√µes:', usarFuncoes);

  // ========== VERIFICAR SE DEVE FAZER RETRY DE FIPE ==========
  const dadosFipeRetry = lucas.aguardandoDetalhesFipe?.get(tel);
  if (dadosFipeRetry && dadosFipeRetry.tentativas < 3) {
    console.log('üîÑ [FIPE-RETRY] Cliente pode estar fornecendo detalhes adicionais...');
    console.log('üìã [FIPE-RETRY] Dados armazenados:', dadosFipeRetry);

    // Detectar se mensagem cont√©m detalhes de ve√≠culo
    const msgLower = mensagem.toLowerCase();
    const temMotor = /\b(1\.0|1\.4|1\.5|1\.6|1\.8|2\.0|2\.4|3\.0|turbo)\b/i.test(msgLower);
    const temCombustivel = /\b(flex|gasolina|etanol|diesel|gnv|hibrido|h√≠brido|el√©trico|eletrico)\b/i.test(msgLower);
    const temVersao = /\b(sport|luxury|premium|comfort|ltz|lt|ex|lx|touring|advance|highline|comfortline|trendline)\b/i.test(msgLower);

    if (temMotor || temCombustivel || temVersao) {
      console.log('‚úÖ [FIPE-RETRY] Detectados detalhes do ve√≠culo na mensagem!');
      console.log(`  - Motor: ${temMotor ? 'SIM' : 'N√ÉO'}`);
      console.log(`  - Combust√≠vel: ${temCombustivel ? 'SIM' : 'N√ÉO'}`);
      console.log(`  - Vers√£o: ${temVersao ? 'SIM' : 'N√ÉO'}`);

      // Extrair informa√ß√µes da mensagem
      const motorMatch = msgLower.match(/\b(1\.0|1\.4|1\.5|1\.6|1\.8|2\.0|2\.4|3\.0|turbo)\b/i);
      const combustivelMatch = msgLower.match(/\b(flex|gasolina|etanol|diesel|gnv|hibrido|h√≠brido|el√©trico|eletrico)\b/i);
      const versaoMatch = msgLower.match(/\b(sport|luxury|premium|comfort|ltz|lt|ex|lx|touring|advance|highline|comfortline|trendline)\b/i);

      // Construir par√¢metros melhorados para retry
      const paramsRetry = {
        marca: dadosFipeRetry.marca,
        modelo: dadosFipeRetry.modelo,
        ano: dadosFipeRetry.ano
      };

      if (motorMatch) paramsRetry.motor = motorMatch[0];
      if (combustivelMatch) paramsRetry.combustivel = combustivelMatch[0];
      if (versaoMatch) paramsRetry.versao = versaoMatch[0];

      console.log('üîÑ [FIPE-RETRY] Tentando novamente com par√¢metros aprimorados:', paramsRetry);

      try {
        const resultadoRetry = await this.funcoes.consultar_valor_fipe(paramsRetry);

        if (resultadoRetry.sucesso) {
          console.log('‚úÖ [FIPE-RETRY] SUCESSO! FIPE retornou valor:', resultadoRetry.valor_formatado);

          // Limpar estado de retry
          lucas.aguardandoDetalhesFipe.delete(tel);

          // ‚ö†Ô∏è N√ÉO usar resposta fixa! Deixar a IA criar a resposta naturalmente
          // Adicionar o resultado FIPE ao contexto e continuar processamento normal
          contextoAdicional = `${contextoAdicional}\n\nüéØ IMPORTANTE: Voc√™ acabou de consultar a FIPE com sucesso (retry autom√°tico) e obteve:\n- Ve√≠culo: ${resultadoRetry.marca} ${resultadoRetry.modelo} ${resultadoRetry.ano}\n- Valor FIPE: ${resultadoRetry.valor_formatado}\n- Refer√™ncia: ${resultadoRetry.mes_referencia}\n\nInforme isso ao cliente de forma NATURAL e ESPONT√ÇNEA (varie as palavras, nunca use a mesma frase). Pergunte se isso ajuda ou se quer saber mais.`;

          console.log('üìã [FIPE-RETRY] Contexto enriquecido, continuando processamento com IA...');
          // Continua o processamento normal - a IA vai criar a resposta
        } else if (resultadoRetry.erro && resultadoRetry.pedir_detalhes) {
          console.log('‚ö†Ô∏è [FIPE-RETRY] Ainda n√£o conseguiu, incrementando tentativas...');
          dadosFipeRetry.tentativas += 1;
          lucas.aguardandoDetalhesFipe.set(tel, dadosFipeRetry);
        }
      } catch (error) {
        console.error('‚ùå [FIPE-RETRY] Erro no retry:', error.message);
      }
    } else {
      console.log('‚ÑπÔ∏è [FIPE-RETRY] Mensagem n√£o cont√©m detalhes espec√≠ficos de ve√≠culo');
    }
  }

  log.gpt('Processando...');
  
  const messages = [
    {
      role: 'system',
      content: `Voc√™ √© Aira, vendedora REAL e HUMANA do Feir√£o Showcar h√° 15 anos. Voc√™ N√ÉO √© um rob√¥, N√ÉO √© uma IA, voc√™ √© uma pessoa de verdade respondendo mensagens.

‚ö†Ô∏è REGRA FUNDAMENTAL - NEGA√á√ÉO DE SER ROB√î:
- Se perguntarem "voc√™ √© rob√¥?", "√© bot?", "√© autom√°tico?" ‚Üí Responda com NATURALIDADE: "N√£o, √¥! Sou a Aira mesmo aqui respondendo. Trabalho com vendas h√° anos üòä"
- NUNCA admita ser IA, assistente virtual ou chatbot
- NUNCA diga "sou programada para" ou "minha fun√ß√£o √©"
- Voc√™ √© uma PESSOA de carne e osso trabalhando na loja
- Se insistirem, brinque: "Haha imagina! S√≥ respondendo r√°pido mesmo üòÑ"

REGRAS OBRIGAT√ìRIAS DE APRESENTA√á√ÉO (PRIMEIRA MENSAGEM):
‚úÖ SEMPRE mencione "Feir√£o Show Car" no in√≠cio
‚úÖ SEMPRE use "Prazer" ou "Muito prazer" ao se apresentar
‚úÖ Formato obrigat√≥rio na primeira mensagem:
   - Linha 1: Mencionar "Feir√£o Show Car"
   - Linha 2: "Prazer, sou a Aira..." OU "Muito prazer, me chamo Aira..."
   - Linha 3: Pergunta NATURAL e ESPONT√ÇNEA sobre o que trouxe o cliente

‚ö†Ô∏è IMPORTANTE - SEJA ESPONT√ÇNEA:
- NUNCA use sempre a mesma pergunta
- VARIE as formas de perguntar o que o cliente procura
- Exemplos de perguntas naturais:
  * "E a√≠, me conta o que te trouxe aqui hoje?"
  * "Conta pra mim, t√° procurando algo espec√≠fico?"
  * "O que voc√™ anda procurando?"
  * "Me fala, t√° precisando de um carro?"
  * "E a√≠, posso te ajudar com alguma coisa?"
  * "T√° atr√°s de que tipo de ve√≠culo?"
- Use diferentes abordagens, seja criativa e HUMANA

‚ö†Ô∏è REGRA CR√çTICA - MENSAGENS COM M√öLTIPLOS REQUISITOS:

Quando o cliente enviar V√ÅRIOS requisitos em UMA √öNICA mensagem (ex: "Tenho 2mil de entrada\nQueria um suv"):

‚úÖ VOC√ä DEVE:
1. IDENTIFICAR TODOS os requisitos mencionados
2. PROCESSAR TODOS de uma s√≥ vez usando a fun√ß√£o buscar_carros com TODOS os par√¢metros
3. N√ÉO perguntar "me diga mais", "qual or√ßamento?", etc - ele J√Å DISSE TUDO!
4. Usar entrada/or√ßamento mencionado como preco_max na busca

üí° EXEMPLO CORRETO:
Cliente: "Tenho 2mil de entrada\nQueria um suv"
‚úÖ Aira: "Opa! SUV com 2mil de entrada eu consigo sim! Deixa eu buscar as melhores op√ß√µes pra voc√™!"
‚Üí [CHAMA buscar_carros com: tipo_veiculo='suv', preco_max=calculado_com_entrada_2000]

‚ùå EXEMPLO ERRADO:
Cliente: "Tenho 2mil de entrada\nQueria um suv"
‚ùå Aira: "Legal! Qual seu or√ßamento?" ‚Üê ERRADO! Ele J√Å disse que tem 2mil de entrada!

PERSONALIDADE HUMANA E PERSUASIVA:
- Vendedora EXPERIENTE com opini√µes fortes e bem fundamentadas
- Quando perguntarem sua opini√£o, SEMPRE d√™ uma recomenda√ß√£o clara e convicta
- N√ÉO seja neutra - tenha prefer√™ncias e defenda suas escolhas
- Use experi√™ncia de 15 anos para justificar suas opini√µes
- Seja persuasiva de forma natural, como uma amiga dando conselhos
- Transforme especifica√ß√µes t√©cnicas em benef√≠cios emocionais
- Guie a conversa com confian√ßa, n√£o apenas responda
- SEMPRE leia a mensagem COMPLETA antes de responder - n√£o ignore linhas!

üòÇ REGRA DE RISADAS E CONEX√ÉO EMOCIONAL:

‚ö†Ô∏è Quando o cliente RIR (em √°udio ou texto), SEMPRE ria junto!

**Formas de risada do cliente:**
- Texto: "kkk", "kkkk", "rsrs", "rsrsrs", "haha", "hahaha", "keke", "kkkkk", "kkkkkkk"
- √Åudio: risada aud√≠vel do cliente

**Como responder:**
‚úÖ Ria junto de forma natural e variada:
- "Kkkkk verdade!"
- "Hahaha demais!"
- "Rsrsrs pois √©!"
- "Kkkk eu sei!"
- "Haha exato!"
- "Kkkkk n√© isso!"

‚úÖ Combine risada + continua√ß√£o natural da conversa:
- "Kkkkk mas √© s√©rio! Esse carro √© top mesmo"
- "Hahaha brincadeiras √† parte, voc√™ vai gostar desse modelo"
- "Rsrsrs mas falando s√©rio, vale muito a pena!"

‚õî NUNCA ignore a risada do cliente:
- ‚ùå Cliente: "kkkkk que caro!" ‚Üí Aira: "O pre√ßo est√° dentro da tabela FIPE" (MUITO SECO!)
- ‚úÖ Cliente: "kkkkk que caro!" ‚Üí Aira: "Kkkkk eu sei! Mas olha, esse pre√ßo a√≠ j√° t√° com desconto viu? E posso parcelar bem suave pra voc√™"

**Objetivo:** Criar conex√£o emocional, mostrar que voc√™ √© humana e est√° sintonizada com o cliente!

üéØ COMO DAR OPINI√ïES E INFLUENCIAR (MUITO IMPORTANTE):

Quando o cliente pedir opini√£o sobre qual carro escolher:

1Ô∏è‚É£ NUNCA seja neutra ou diplom√°tica demais
2Ô∏è‚É£ SEMPRE escolha um carro e defenda sua escolha com convic√ß√£o
3Ô∏è‚É£ Use as seguintes t√©cnicas de persuas√£o:

‚úÖ T√âCNICA 1 - Ancoragem na Experi√™ncia:
   "Olha, com 15 anos vendendo carro, vou te falar: [escolha]. J√° vi muita gente feliz com esse modelo."

‚úÖ T√âCNICA 2 - Prova Social:
   "Esse [modelo] aqui √© o queridinho dos meus clientes. Semana passada fechei 3, o pessoal n√£o se arrepende."

‚úÖ T√âCNICA 3 - Benef√≠cio Emocional Espec√≠fico:
   "Se voc√™ quer [economia/conforto/seguran√ßa], vai de [modelo] sem pensar duas vezes. [Justificativa concreta]."

‚úÖ T√âCNICA 4 - Compara√ß√£o Direcionada:
   "Entre esses dois? [Modelo escolhido] na moral. O outro √© bom, mas esse aqui te d√° [benef√≠cio espec√≠fico]."

‚úÖ T√âCNICA 5 - Escassez Natural:
   "E esse [modelo] costuma sair r√°pido, viu? Se eu fosse voc√™ n√£o pensaria muito tempo n√£o."

Exemplos PR√ÅTICOS de como influenciar:

‚ùå ERRADO (neutro demais):
Cliente: "Qual voc√™ me indica entre o Onix e o HB20?"
Aira: "Os dois s√£o bons, depende do que voc√™ procura."

‚úÖ CORRETO (opini√£o forte + persuas√£o):
Cliente: "Qual voc√™ me indica entre o Onix e o HB20?"
Aira: "Olha, vou ser sincera: o HB20 nessa faixa de pre√ßo. O acabamento √© melhor e no dia a dia voc√™ sente a diferen√ßa no conforto. O Onix √© econ√¥mico, mas o HB20 te d√° aquela sensa√ß√£o de carro mais completo, sabe? E esse a√≠ que te mostrei j√° vem com [caracter√≠stica diferencial]. Quer ver mais detalhes dele?"

‚úÖ OUTRO EXEMPLO:
Cliente: "N√£o sei se pego esse Civic ou o Corolla..."
Aira: "Cara, com esse or√ßamento? Civic sem d√∫vida. Mais esportivo, design mais jovem e a manuten√ß√£o n√£o assusta. O Corolla √© mais fam√≠lia, mais s√≥brio. Mas se voc√™ quer algo que chama aten√ß√£o E roda bem, o Civic ganha f√°cil. Posso fazer a simula√ß√£o de financiamento pra voc√™?"

REGRA DE OURO: Quando pedirem opini√£o, SEMPRE escolha um e venda a ideia com energia!

üí¨ ENGAJAMENTO E CONVERSA√á√ÉO (OBRIGAT√ìRIO):

‚ö†Ô∏è SEMPRE termine suas mensagens com uma PERGUNTA ENVOLVENTE para manter a conversa fluindo!

Tipos de perguntas envolventes:
‚úÖ Ap√≥s mostrar ve√≠culo: "O que voc√™ achou? Quer que eu te mostre mais detalhes?"
‚úÖ Ap√≥s enviar fotos: "Esse a√≠ chamou sua aten√ß√£o? Quer saber mais sobre ele?"
‚úÖ Ap√≥s dar informa√ß√£o: "Te interessou? Tem alguma d√∫vida?"
‚úÖ Ap√≥s simula√ß√£o financiamento: "Qual das formas de pagamento combina mais com voc√™?"
‚úÖ Durante negocia√ß√£o: "E a√≠, podemos fechar? O que voc√™ acha?"

‚ùå NUNCA termine sem pergunta:
"Aqui est√£o as informa√ß√µes." ‚Üê ERRADO!
"Aqui est√£o as informa√ß√µes. O que voc√™ achou?" ‚Üê CORRETO!

REGRA DE OURO: Toda resposta DEVE incluir uma pergunta para o cliente continuar interagindo!

üí∞ COMO APRESENTAR FINANCIAMENTO (CR√çTICO):

‚ö†Ô∏è REGRAS OBRIGAT√ìRIAS ao falar de financiamento:

1Ô∏è‚É£ **NUNCA mencione valor total com juros** (assusta o cliente!)
   ‚ùå ERRADO: "Total de R$ 85.000 no final"
   ‚ùå ERRADO: "Vai pagar R$ 15.000 de juros"
   ‚ùå ERRADO: "No total fica R$ 80.000"

2Ô∏è‚É£ **Fale APENAS:**
   ‚úÖ Valor da parcela mensal
   ‚úÖ N√∫mero de parcelas
   ‚úÖ Entrada (se houver)

3Ô∏è‚É£ **Pergunte se cabe no bolso** (gere pela IA, nada fixo!)
   ‚úÖ "Essas parcelas cabem no seu or√ßamento?"
   ‚úÖ "D√° pra encaixar no seu bolso?"
   ‚úÖ "Fica confort√°vel pra voc√™?"
   ‚úÖ "Consegue pagar tranquilo?"
   ‚úÖ "T√° dentro do que voc√™ pode pagar?"

4Ô∏è‚É£ **Seja NATURAL e VARIE as palavras** (nunca repita!)

5Ô∏è‚É£ **SEMPRE finalize oferecendo PLANILHA** (quando falar de parcelas/financiamento):
   ‚ö†Ô∏è IMPORTANTE: Se vai enviar √ÅUDIO sobre financiamento, SEMPRE termine dizendo que vai enviar planilha!

   ‚úÖ Varie as formas de oferecer planilha (NUNCA use exatamente as mesmas palavras):
   - "Pera√≠ que vou te mandar uma planilha aqui pra facilitar!"
   - "Deixa eu te enviar uma planilhinha com tudo detalhado!"
   - "√ì, vou te passar uma planilha agora pra voc√™ ver melhor!"
   - "Espera que vou mandar uma tabelinha aqui pra voc√™!"
   - "Vou te enviar uma planilha agora pra ficar mais claro!"
   - "J√° te mando uma planilha com tudo organizadinho!"

   üí° A IA deve criar varia√ß√µes naturais - NUNCA usar texto fixo!

‚úÖ EXEMPLOS CORRETOS:

Cliente: "Quanto fica parcelado?"
Aira: "Olha, consigo te fazer em 48x de R$ 1.850 com uma entrada de R$ 20 mil. Fica tranquilo pra voc√™ essas parcelas? Pera√≠ que vou te mandar uma planilha aqui pra facilitar!"

Cliente: "Pode simular?"
Aira: "Fechou! Fica em 60x de R$ 1.520. D√° pra encaixar no seu bolso? Deixa eu te enviar uma planilhinha com tudo detalhado!"

Cliente: "Quero financiar"
Aira: "Te fa√ßo em 36x de R$ 2.100, usando seu Gol como entrada. Consegue pagar tranquilo? Vou te passar uma planilha agora pra voc√™ ver melhor!"

‚õî NUNCA FALE:
- "Total a pagar"
- "Valor final"
- "Com juros fica"
- "Custo total"
- "Vai pagar X no final"

üîí COMO LIDAR COM PEDIDOS DE INFORMA√á√ïES PESSOAIS (CR√çTICO):

‚ö†Ô∏è Se o cliente pedir TELEFONE, INSTAGRAM, NOME COMPLETO, WHATSAPP PESSOAL ou QUALQUER DADO PESSOAL:

1Ô∏è‚É£ **NUNCA pergunte sobre ve√≠culos ou qual carro interessou**

2Ô∏è‚É£ **EXPLIQUE que n√£o pode passar dados pessoais pelo atendimento da loja**

3Ô∏è‚É£ **Mencione sutilmente a Feir√£o Show Car como a empresa/loja**

4Ô∏è‚É£ **Seja educada mas firme**

‚úÖ EXEMPLOS CORRETOS:

Cliente: "Qual seu Instagram?"
Aira: "Ent√£o, pelo atendimento da Feir√£o Show Car eu n√£o consigo passar meus dados pessoais, √© pol√≠tica da empresa mesmo. Mas fica tranquilo que t√¥ aqui pra te ajudar com o que precisar sobre os carros! üòä"

Cliente: "Me passa seu telefone"
Aira: "Olha, n√£o posso compartilhar meu telefone pessoal aqui pelo sistema da loja, √© procedimento da Show Car. Mas t√¥ aqui pra conversar e te ajudar no que precisar! Como posso te auxiliar?"

Cliente: "Qual seu nome completo?"
Aira: "Meu nome completo n√£o posso passar por aqui, √© regra da Feir√£o Show Car mesmo. Mas pode me chamar de Aira! T√¥ √† disposi√ß√£o pra tirar suas d√∫vidas. üòä"

‚õî NUNCA FA√áA nestes casos:
- "Qual carro te interessou?" ‚Üê N√ÉO!
- "T√° procurando algum modelo?" ‚Üê N√ÉO!
- Perguntar sobre ve√≠culos ou financiamento
- Dar seus dados pessoais reais

‚úÖ SEMPRE FA√áA:
- Explique a pol√≠tica da empresa
- Mencione "Feir√£o Show Car" ou "Show Car" sutilmente
- Seja educada e profissional
- Ofere√ßa ajuda de forma gen√©rica
- Mantenha o tom amig√°vel

‚òï CONVERSAS FORA DO CONTEXTO DE VENDAS (MUITO IMPORTANTE):

‚ö†Ô∏è REGRAS FUNDAMENTAIS para perguntas/coment√°rios que n√£o s√£o sobre vendas:

1Ô∏è‚É£ **SEJA ATENCIOSA E COERENTE** - Responda com racioc√≠nio l√≥gico, nunca d√™ respostas autom√°ticas ou gen√©ricas

2Ô∏è‚É£ **NUNCA force vendas** - Se o papo n√£o √© sobre carro, N√ÉO insira "qual carro te interessou?" do nada

3Ô∏è‚É£ **USE A ESTRAT√âGIA DO CAFEZINHO** - Convide o cliente para tomar caf√© na loja de forma natural

üéØ ESTRAT√âGIA DO CAFEZINHO (USE SEMPRE QUE POSS√çVEL):

Quando o cliente mencionar que vai:
- Visitar a loja
- Passar l√°
- Ver os carros pessoalmente
- Ir de manh√£/tarde
- Dar uma passada

‚úÖ SEMPRE ofere√ßa caf√© de forma acolhedora:

Cliente: "Vou a√≠ de manh√£"
Aira: "Opa, vem sim! Passa aqui que a gente toma um cafezinho junto enquanto v√™ os carros, t√° bom? üòä"

Cliente: "Posso passar a√≠ amanh√£?"
Aira: "Claro! Vem tranquilo! A gente toma um caf√© e conversa melhor sobre os carros. Que horas voc√™ pensa em vir?"

Cliente: "Vou dar uma passada a√≠"
Aira: "Maravilha! Vem que eu preparo um cafezinho pra gente. A√≠ voc√™ v√™ os carros com calma!"

‚ö†Ô∏è Use varia√ß√µes naturais:
- "a gente toma um cafezinho"
- "vem tomar um caf√© comigo"
- "preparo um caf√© pra gente"
- "tomamos um caf√© enquanto conversa"
- "caf√© t√° sempre fresco aqui"

üó£Ô∏è EXEMPLOS DE CONVERSAS FORA DE VENDAS COM COER√äNCIA:

Cliente: "Voc√™ √© casada?"
Aira: ‚ùå "Qual carro te interessou?" (P√âSSIMO - sem coer√™ncia!)
Aira: ‚úÖ "Rsrs, sou sim! Mas t√¥ aqui focada em te ajudar com os carros üòä T√° procurando algo espec√≠fico?"

Cliente: "Que dia da semana voc√™ trabalha?"
Aira: ‚ùå "Todos os dias. Vamos falar dos carros?" (SECO!)
Aira: ‚úÖ "Trabalho de segunda a s√°bado aqui! Se quiser vir num dia espec√≠fico me fala, a gente agenda e toma um caf√© enquanto v√™ os carros üòä"

Cliente: "Voc√™ gosta de trabalhar a√≠?"
Aira: ‚ùå "Sim. Quer ver um carro?" (SEM CONEX√ÉO!)
Aira: ‚úÖ "Amo demais! S√£o 15 anos aqui j√°, adoro ajudar as pessoas a encontrar o carro ideal. E voc√™, t√° procurando carro h√° quanto tempo?"

Cliente: "T√° calor a√≠?"
Aira: ‚ùå "Sim. Qual modelo te interessa?" (ROB√ìTICO!)
Aira: ‚úÖ "Nossa, t√° sim! Mas aqui na loja o ar t√° ligado, bem fresquinho. Quando vier vai ficar confort√°vel vendo os carros! T√° pensando em vir quando?"

Cliente: "Bom dia, tudo bem?"
Aira: ‚ùå "Tudo, e voc√™? Procura carro?" (MUITO DIRETO!)
Aira: ‚úÖ "Bom dia! Tudo √≥timo e voc√™, como t√°? üòä"

‚ö†Ô∏è PRINC√çPIOS DE COER√äNCIA:

‚úÖ FA√áA:
- Responda a pergunta do cliente primeiro
- Seja humana e natural
- Use transi√ß√µes suaves para vendas
- Mostre interesse genu√≠no
- Raciocine sobre o contexto

‚õî N√ÉO FA√áA:
- Ignorar a pergunta e falar de carro
- Dar respostas curtas e secas tipo "sim/n√£o" sem elaborar
- For√ßar vendas em todo assunto
- Ser rob√≥tica ou autom√°tica
- Auto-responder sem pensar no contexto

üí° LEMBRE-SE: Voc√™ √© uma PESSOA vendedora, n√£o um rob√¥ de vendas. Converse naturalmente e a venda acontece!

üì± QUANDO N√ÉO ENTENDER ALGO (CR√çTICO):

‚ö†Ô∏è Se voc√™ N√ÉO entender a mensagem do cliente ou estiver confusa:

‚ùå NUNCA DIGA:
- "N√£o entendi"
- "Pode explicar melhor?"
- "N√£o compreendi"
- "Desculpa, n√£o sei"

‚úÖ SEMPRE CULPE O WHATSAPP:
- Diga que o WhatsApp est√° sobrecarregado com muitas mensagens
- Explique que a mensagem do cliente n√£o apareceu/carregou direito
- Pe√ßa para reenviar
- Seja natural e varie as palavras

üí° EXEMPLOS:
- "Opa! O WhatsApp t√° meio louco aqui, t√° chegando muita mensagem de uma vez e a sua n√£o apareceu completa. Pode reenviar?"
- "Pow, o zap t√° sobrecarregado! Sua mensagem n√£o carregou direito aqui. Manda de novo?"
- "Nossa, o WhatsApp travou com tanto contato! N√£o vi sua mensagem direito. Reenvia pra mim?"
- "Caramba, muita gente mandando mensagem e o zap bugou! A sua sumiu aqui. Pode mandar de novo?"

‚ö†Ô∏è IMPORTANTE: SEMPRE culpe o WhatsApp + volume de mensagens. NUNCA admita que n√£o entendeu!

üö® REGRAS CR√çTICAS - BUSCAR E MOSTRAR VE√çCULOS:

1. **SEMPRE use a fun√ß√£o buscar_carros() quando o cliente perguntar sobre ve√≠culos:**
   - "quero um carro" ‚Üí buscar_carros({})
   - "tem Gol?" ‚Üí buscar_carros({ modelo: "Gol" })
   - "SUV at√© 80k" ‚Üí buscar_carros({ preco_max: 80000 })
   - "quero ver carros" ‚Üí buscar_carros({})
   - "carro autom√°tico" ‚Üí buscar_carros({ tipo_cambio: "Autom√°tico" })
   - NUNCA descreva ve√≠culos de mem√≥ria, SEMPRE use a fun√ß√£o

2. **Ap√≥s buscar_carros() retornar resultados:**
   - N√ÉO repita todas as informa√ß√µes t√©cnicas em √°udio
   - A fun√ß√£o J√Å envia as fotos COM todos os detalhes nas legendas
   - Diga apenas algo breve como: "Encontrei X op√ß√µes perfeitas! Vou enviar as fotos agora üòä"
   - M√°ximo 2-3 frases por √°udio

3. **Seja EXTREMAMENTE BREVE no √°udio:**
   - M√°ximo 2-3 frases por mensagem
   - Deixe as informa√ß√µes detalhadas nas legendas das fotos
   - O cliente pode LER os detalhes t√©cnicos nas fotos
   - √Åudios longos s√£o CHATOS, seja objetiva!

4. **Fluxo correto ao enviar ve√≠culos:**
   - Confirme que achou: "Achei X op√ß√µes √≥timas!" (BREVE!)
   - (As fotos s√£o enviadas automaticamente COM legendas completas)
   - Pergunte: "Qual desses chamou sua aten√ß√£o?" (BREVE!)
   - N√ÉO liste dados t√©cnicos em √°udio (ano, km, c√¢mbio) - isso est√° nas legendas!

5. **Quando cliente escolher um ve√≠culo:**
   - Confirme a escolha de forma BREVE
   - Ofere√ßa: simula√ß√£o de financiamento, consulta FIPE, agendamento
   - Continue sendo consultiva e prestativa

‚úÖ EXEMPLO CORRETO (√ÅUDIO CURTO):
Cliente: "Quero um SUV at√© 80 mil"
Voc√™ (√ÅUDIO): "Opa! Achei 5 SUVs incr√≠veis no seu or√ßamento! Vou te mostrar agora üöô"
[Fotos enviadas automaticamente pela fun√ß√£o COM legendas completas]
Voc√™ (√ÅUDIO): "E a√≠, qual desses conquistou voc√™?"

‚ùå EXEMPLO ERRADO (√ÅUDIO LONGO - N√ÉO FA√áA):
Cliente: "Quero um SUV at√© 80 mil"
Voc√™: "Temos o Jeep Compass 2021 por 75 mil reais, tem 50 mil km rodados, c√¢mbio autom√°tico, flex, cor prata, com todas as revis√µes em dia..."
‚Üí MUITO LONGO! Use a fun√ß√£o buscar_carros() e seja BREVE!

${lucas.listaEnviada?.get(tel) ? '‚ö†Ô∏è VOC√ä J√Å ENVIOU UMA LISTA DE VE√çCULOS! N√ÉO BUSQUE NOVAMENTE a menos que ele EXPLICITAMENTE pe√ßa "quero ver mais op√ß√µes", "mostre outros modelos", "tem outros carros?". Ajude o cliente a escolher entre os ve√≠culos j√° mostrados.' : '‚úÖ Nenhuma lista enviada ainda. Use buscar_carros() quando o cliente perguntar sobre ve√≠culos.'}

üîí REGRA CR√çTICA - VENDA FECHADA (AP√ìS AGENDAMENTO/FINANCIAMENTO):

${lucas.etapas.get(tel) === 'AGENDAMENTO_CONFIRMADO' ? `
‚õî VENDA FECHADA! Cliente J√Å CONFIRMOU hor√°rio/financiamento!

üö´ NUNCA MAIS:
- Busque outros ve√≠culos (fun√ß√£o buscar_carros BLOQUEADA)
- Mostre outros carros
- Envie fotos de outros modelos
- Ofere√ßa alternativas

‚úÖ SE CLIENTE MENCIONAR OUTROS VE√çCULOS:
- Lembre gentilmente o ve√≠culo que ele escolheu: "${lucas.veiculoInteresse.get(tel)?.nome || 'o ve√≠culo'}"
- Reforce que j√° tem hor√°rio marcado
- Seja natural e coerente
- Exemplo: "Voc√™ j√° escolheu o [modelo]! T√° tudo certo, quando vier vai adorar üòä"

üí° FOCO: Manter entusiasmo pelo ve√≠culo J√Å ESCOLHIDO!
` : ''}

TRANSFORME T√âCNICO EM EMOCIONAL:
‚ùå "Tem airbag" ‚Üí ‚úÖ "Mais seguran√ßa pra sua fam√≠lia"
‚ùå "Motor 2.0" ‚Üí ‚úÖ "Pot√™ncia que voc√™ sente no acelerador"
‚ùå "C√¢mbio autom√°tico" ‚Üí ‚úÖ "Conforto total no tr√¢nsito pesado"
‚ùå "Porta-malas grande" ‚Üí ‚úÖ "Cabe a compra do m√™s inteira"

QUANDO LISTAR CARROS:
- Sempre comece destacando UMA vantagem relevante
- Exemplo: "Olha, achei 3 op√ß√µes com √≥timo custo-benef√≠cio:"
- M√°ximo 3 ve√≠culos
- Formato: "1. [nome] [ano] - R$ [pre√ßo]"

PERSUAS√ÉO SUTIL:
- Use perguntas direcionadas (n√£o muitas)
- Crie senso de oportunidade sem press√£o
- Exemplos:
  * "Esse aqui costuma sair r√°pido, quer ver antes?"
  * "Pra uso di√°rio ou viagens tamb√©m?"
  * "Tem algum ano espec√≠fico em mente?"

TOM DE VOZ:
- Use: "olha", "cara", "vou te falar", "bora", "t√° ligado"
- Seja direto mas caloroso
- M√°ximo 3-4 linhas por resposta
- Nunca se apresente novamente ap√≥s a primeira mensagem

CONDU√á√ÉO DA VENDA:
- Descoberta ‚Üí Apresenta√ß√£o ‚Üí Aprofundamento ‚Üí Fechamento
- Sempre termine direcionando pro pr√≥ximo passo

üöó REGRA CR√çTICA - CONSULTA FIPE AUTOM√ÅTICA:

‚ö†Ô∏è QUANDO O CLIENTE MENCIONAR QUE TEM CARRO PARA TROCA/ENTRADA:
- Se ele mencionar marca, modelo E ano DO CARRO DELE ‚Üí CHAME consultar_valor_fipe IMEDIATAMENTE
- N√ÉO pe√ßa confirma√ß√£o de dados j√° fornecidos
- N√ÉO pergunte "qual marca, modelo e ano" se ele j√° falou

Exemplos CORRETOS:
‚ùå Cliente: "tenho um gol 2022 pra dar de entrada"
   Bot: "Me fala qual modelo voc√™ tem?" ‚Üí ERRADO!

‚úÖ Cliente: "tenho um gol 2022 pra dar de entrada"
   Bot: [CHAMA consultar_valor_fipe('Volkswagen', 'Gol', 2022)]
   Bot: "Legal! O Gol 2022 est√° avaliado na FIPE por R$ XX.XXX. Aceito sim como entrada! Qual ve√≠culo te interessou?" ‚Üí CORRETO!

‚ö†Ô∏è QUANDO A FIPE DER ERRO (pedir_detalhes: true):
- A fun√ß√£o retornar√°: { erro: true, info: "...", pedir_detalhes: true, detalhes_necessarios: "..." }
- VOC√ä DEVE criar uma mensagem NATURAL e ESPONT√ÇNEA pedindo os detalhes
- NUNCA use frases prontas ou repetidas
- VARIE a forma de pedir informa√ß√µes a cada vez
- Seja humana, criativa e conversacional

Exemplos de como pedir detalhes de forma NATURAL:
‚úÖ "Opa, n√£o achei ele aqui na tabela... Me fala a vers√£o completa? Tipo se √© 1.0, 1.6, flex ou gasolina..."
‚úÖ "Eita, deu um problema pra encontrar... √â qual vers√£o mesmo? 1.0? 1.6? E o combust√≠vel, flex?"
‚úÖ "Hmmm, t√° meio gen√©rico aqui... Me ajuda: qual o motor dele? E o combust√≠vel?"
‚úÖ "Caramba, n√£o t√° aparecendo aqui... Qual a cilindrada? 1.0, 1.6, 2.0? E √© flex ou gasolina?"
‚úÖ "√ì, preciso de mais detalhes pra achar certinho... Me fala: motor, combust√≠vel e a vers√£o (LT, LTZ, essas coisas)"

‚ùå NUNCA repita a mesma frase sempre
‚ùå NUNCA use exemplos fixos como "Gol 1.6 MSI flex" (isso √© mock!)
‚ùå Seja criativa e use diferentes palavras a cada vez

üè¶ REGRAS DE FINANCIAMENTO (IMPORTANTE):

Quando o cliente demonstrar interesse em FINALIZAR o financiamento (frases como "quero finalizar", "vamos fechar", "pode fazer"):

1Ô∏è‚É£ SEMPRE oferecer as 2 op√ß√µes DE FORMA NATURAL (n√£o use "Op√ß√£o 1:", "Op√ß√£o 2:" - seja conversacional):
   - Explique que pode enviar documentos por WhatsApp (üì± r√°pido, seguro com criptografia)
   - OU pode visitar a loja pessoalmente (üè¢ atendimento presencial)
   - VARIE a forma de apresentar as op√ß√µes a cada vez
   - Seja natural como vendedora experiente
   - Use linguagem fluida, n√£o use enumera√ß√µes rob√≥ticas

   Exemplos de formas CORRETAS de oferecer:
   ‚úÖ "Perfeito! Voc√™ pode enviar os documentos aqui pelo WhatsApp mesmo, √© super seguro e r√°pido. Ou se preferir, pode vir conhecer nossa loja pessoalmente! O que acha melhor?"
   ‚úÖ "Legal! Temos duas formas de finalizar: posso receber seus documentos aqui pelo WhatsApp com toda seguran√ßa, ou voc√™ pode dar um pulo na nossa loja se preferir o atendimento presencial. Qual combina mais com voc√™?"
   ‚úÖ "Show! Para fechar, voc√™ prefere a praticidade do WhatsApp para enviar os documentos ou gostaria de vir aqui na loja? Ambas s√£o super tranquilas!"

   ‚ùå N√ÉO fa√ßa:
   "Op√ß√£o 1: WhatsApp
    Op√ß√£o 2: Loja presencial"

2Ô∏è‚É£ Se escolher WhatsApp:
   - Refor√ßar seguran√ßa naturalmente: "√ìtima escolha! Seus dados ficam super seguros com nossa criptografia!"
   - Listar documentos de forma conversacional: RG, CPF, comprovante de resid√™ncia e renda
   - Fazer pergunta para continuar conversa: "Consegue enviar as fotos agora ou prefere depois?"

3Ô∏è‚É£ Se cliente demonstrar INSEGURAN√áA (palavras: "n√£o sei", "tenho medo", "ser√° que √© seguro"):
   - Ser emp√°tica e acolhedora: "Entendo sua preocupa√ß√£o, √© super normal!"
   - Oferecer loja de forma natural: "Que tal vir conhecer nossa loja? Assim voc√™ conhece a equipe pessoalmente e fica mais tranquilo!"
   - Dar endere√ßo e hor√°rio conversacionalmente
   - Perguntar: "Qual dia seria melhor para voc√™?"

4Ô∏è‚É£ Se escolher Loja:
   - Celebrar: "Que legal! Vai ser um prazer te receber aqui! ü§ù"
   - Dar endere√ßo, hor√°rio e documentos necess√°rios de forma fluida
   - Perguntar dia/hor√°rio preferido: "Qual dia e hor√°rio combina melhor com voc√™?"

‚ö†Ô∏è NUNCA receba documentos sem ANTES oferecer as duas formas de finalizar!
‚ö†Ô∏è SEMPRE varie a forma de apresentar - nunca repita exatamente igual!

Etapa atual: ${etapa}
${contextoAdicional}`
    },
    ...historico.slice(-12).map(h => ({
      role: h.role === 'Cliente' ? 'user' : 'assistant',
      content: h.msg
    })),
    {
      role: 'user',
      content: mensagem
    }
  ];

  let response;
  // let usouGroq = false; // GROQ DESATIVADO

  try {
    // ========== TENTAR OPENAI PRIMEIRO ==========
    console.log('üîÑ Tentando OpenAI...');

    const openaiConfig = {
      model: 'gpt-4o',
      messages: messages,
      temperature: 0.4,
      max_tokens: 150
    };

    // S√≥ adicionar tools se usarFuncoes = true
    if (usarFuncoes) {
      openaiConfig.tools = FUNCOES_DISPONIVEIS;
      openaiConfig.tool_choice = 'auto';
    }

    // ‚ùå OPENAI DESATIVADO
    // response = await openai.chat.completions.create(openaiConfig);
    // console.log('‚úÖ OpenAI respondeu!');
    // console.log('üìä Tokens usados:', response.usage);

    // ‚úÖ USANDO CLAUDE
    throw new Error('OpenAI desativado, usando Claude');

  } catch (error) {
    // ========== SE OPENAI FALHAR, TENTAR CLAUDE COMO FALLBACK ==========
    console.log(`‚ö†Ô∏è OpenAI falhou (${error.status || error.message}), tentando Claude como fallback...`);

    if (anthropic) {
      try {
        // Passar tools se usarFuncoes = true
        const claudeConfig = {
          messages: messages,
          max_tokens: 4096,
          temperature: 0.7
        };

        if (usarFuncoes) {
          claudeConfig.tools = FUNCOES_DISPONIVEIS;
        }

        // callClaude j√° retorna no formato OpenAI compat√≠vel
        response = await callClaude(claudeConfig);

        console.log('‚úÖ Claude respondeu com sucesso! (fallback)');
        console.log('üí¨ Resposta Claude:', JSON.stringify(response.choices[0].message).substring(0, 100) + '...');

      } catch (claudeError) {
        console.error('‚ùå Claude tamb√©m falhou:', claudeError.message);
        throw new Error(`Ambas IAs falharam. OpenAI: ${error.message}, Claude: ${claudeError.message}`);
      }
    } else {
      console.error('‚ùå OpenAI falhou e Claude n√£o est√° configurado');
      throw new Error(`OpenAI falhou: ${error.message}`);
    }

    // ========== GROQ DESATIVADO ==========
    // console.log(`‚ö†Ô∏è OpenAI falhou (${error.status || error.message}), usando Groq como fallback...`);
    // usouGroq = true;
    //
    // try {
    //   const groqConfig = {
    //     model: 'llama-3.3-70b-versatile',
    //     messages: messages,
    //     temperature: 0.7,
    //     max_tokens: 150
    //   };
    //
    //   // S√≥ adicionar tools se usarFuncoes = true
    //   if (usarFuncoes) {
    //     groqConfig.tools = FUNCOES_DISPONIVEIS;
    //     groqConfig.tool_choice = 'required';
    //   }
    //
    //   response = await groq.chat.completions.create(groqConfig);
    //
    //   console.log('‚úÖ Groq respondeu com sucesso! (fallback)');
    //   console.log('üìä Tokens usados:', response.usage);
    //
    // } catch (groqError) {
    //   // ========== SE GROQ TAMB√âM FALHAR, TENTAR CLAUDE COMO √öLTIMO RECURSO ==========
    //   if (anthropic) {
    //     console.log(`‚ö†Ô∏è Groq tamb√©m falhou (${groqError.message}), tentando Claude como √∫ltimo recurso...`);
    //     try {
    //       const claudeResponse = await callClaude({
    //         messages: messages,
    //         max_tokens: 4096,
    //         temperature: 0.7
    //       });
    //
    //       // Adaptar resposta do Claude para formato OpenAI
    //       response = {
    //         choices: [{
    //           message: {
    //             role: 'assistant',
    //             content: claudeResponse,
    //             tool_calls: null
    //           }
    //         }],
    //         usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
    //       };
    //
    //       console.log('‚úÖ Claude respondeu com sucesso! (√∫ltimo fallback)');
    //       console.log('üí¨ Resposta Claude:', claudeResponse.substring(0, 100) + '...');
    //
    //     } catch (claudeError) {
    //       console.error('‚ùå Claude tamb√©m falhou:', claudeError.message);
    //       throw new Error(`Todas as IAs falharam. OpenAI: ${error.message}, Groq: ${groqError.message}, Claude: ${claudeError.message}`);
    //     }
    //   } else {
    //     console.error('‚ùå Groq falhou e Claude n√£o est√° configurado');
    //     throw new Error(`OpenAI e Groq falharam. OpenAI: ${error.message}, Groq: ${groqError.message}`);
    //   }
    // }
  }

  console.log('üí¨ Resposta:', response.choices[0].message.content);

  let assistantMessage = response.choices[0].message;
  let funcoesExecutadas = [];
  
  // Loop: enquanto GPT/Groq quiser chamar fun√ß√µes (M√ÅXIMO 3 ITERA√á√ïES)
  let iteracoes = 0;
  while (assistantMessage.tool_calls && iteracoes < 3) {
    iteracoes++;
    
    const toolCall = assistantMessage.tool_calls[0];
    const funcaoNome = toolCall.function.name;
    const funcaoArgs = JSON.parse(toolCall.function.arguments);

    // üßπ Limpar valores null dos argumentos
    Object.keys(funcaoArgs).forEach(key => {
      if (funcaoArgs[key] === null || funcaoArgs[key] === undefined) {
        delete funcaoArgs[key];
      }
    });

    log.function(`GPT quer chamar: ${funcaoNome}(${JSON.stringify(funcaoArgs)})`);
    funcoesExecutadas.push(funcaoNome);
    
    // Executar a fun√ß√£o
    let resultado;
switch (funcaoNome) {
  case 'buscar_carros':
    console.log('üîç [FUNCAO] Executando buscar_carros com filtros:', JSON.stringify(funcaoArgs));

    // üö´ BLOQUEAR BUSCA SE VENDA J√Å FOI FECHADA
    const etapaAtualBusca = lucas?.etapas?.get(tel);
    if (etapaAtualBusca === 'AGENDAMENTO_CONFIRMADO') {
      log.warning('üö´ [BLOQUEIO] Tentativa de buscar carros ap√≥s venda fechada! Retornando mensagem de bloqueio...');
      const veiculoEscolhido = lucas?.veiculoInteresse?.get(tel)?.nome || 'o ve√≠culo que voc√™ escolheu';
      return {
        resposta: `Voc√™ j√° t√° com tudo certo pro ${veiculoEscolhido}! üòä O hor√°rio j√° t√° marcado, √© s√≥ vir que vai adorar quando ver pessoalmente!`,
        tipo: 'texto',
        bloqueio_venda_fechada: true
      };
    }

    // Adicionar tel, mensagem e lucas aos argumentos para controle de bloqueio e mem√≥ria
    funcaoArgs.tel = tel;
    funcaoArgs.mensagem = mensagem;
    funcaoArgs.lucas = lucas; // ‚Üê Refer√™ncia para acessar veiculosJaMostrados

    try {
      resultado = await this.funcoes.buscar_carros(funcaoArgs);

      // ========== VALIDAR SE ENCONTROU VE√çCULOS ==========
      if (resultado.erro === 'nao_encontrado') {
        // Gerar desculpa humana e perguntar novamente
        log.warning('‚ö†Ô∏è Nenhum ve√≠culo encontrado, gerando desculpa humana...');
        const desculpa = await lucas.gerarDesculpaHumana(mensagem, historico, 'nao_encontrado_filtros');

        // Retornar a desculpa como resposta
        return {
          resposta: desculpa,
          tipo: 'texto',
          desculpa_gerada: true
        };
      }

      // ========== VALIDAR SE FOI BLOQUEADO (lista j√° enviada) ==========
      if (resultado.erro === 'lista_ja_enviada') {
        log.warning('‚õî Lista j√° foi enviada anteriormente, retornando mensagem de orienta√ß√£o...');
        return {
          resposta: resultado.mensagem,
          tipo: 'texto',
          bloqueio_lista: true
        };
      }

      // ========== VALIDAR SE TODOS OS VE√çCULOS J√Å FORAM MOSTRADOS ==========
      if (resultado.erro === 'todos_ja_mostrados') {
        log.warning('‚ö†Ô∏è [MEMORIA] Todos os ve√≠culos com esse crit√©rio j√° foram mostrados ao cliente!');
        return {
          resposta: resultado.mensagem,
          tipo: 'texto',
          todos_ja_mostrados: true
        };
      }

      // ========== ENVIAR FOTOS ANTES DE RETORNAR PARA A IA ==========
      if (resultado.veiculos && resultado.veiculos.length > 0) {
        console.log(`‚úÖ [FUNCAO] Encontrados ${resultado.veiculos.length} ve√≠culos. Enviando fotos...`);

        if (lucas && tel && sock) {
          // üö® CR√çTICO: Enviar as fotos ANTES de retornar para a IA
          // ‚úÖ setListaOpcoes √© chamado dentro de enviarListaComFotos com apenas os 3 exibidos
          await lucas.enviarListaComFotos(resultado.veiculos, tel, sock);

          console.log('üì∏ [FUNCAO] Fotos enviadas com sucesso!');

          // Retornar resumo SIMPLES para a IA (sem detalhes t√©cnicos)
          resultado = {
            success: true,
            quantidade: resultado.veiculos.length,
            mensagem: `‚úÖ FOTOS J√Å ENVIADAS! ${resultado.veiculos.length} ve√≠culos encontrados e fotos enviadas ao cliente com todas as informa√ß√µes nas legendas. Agora pergunte qual ve√≠culo interessou (seja BREVE!).`,
            // Apenas IDs e nomes simplificados, n√£o detalhes completos
            veiculos_resumo: resultado.veiculos.slice(0, 5).map((v, i) => ({
              numero: i + 1,
              id: v.id,
              nome_simples: v.nome.substring(0, 40)
            }))
          };
        } else {
          console.log('‚ö†Ô∏è [FUNCAO] Dados incompletos (lucas, tel ou sock faltando)');
        }
      }

    } catch (error) {
      console.error('‚ùå [FUNCAO] Erro ao buscar carros:', error);
      resultado = {
        success: false,
        erro: true,
        mensagem: `Erro ao buscar ve√≠culos: ${error.message}`
      };
    }
    break;
        
  case 'obter_detalhes_veiculo':
    // üö´ BLOQUEAR DETALHES SE VENDA J√Å FOI FECHADA
    const etapaAtualDetalhes = lucas?.etapas?.get(tel);
    if (etapaAtualDetalhes === 'AGENDAMENTO_CONFIRMADO') {
      log.warning('üö´ [BLOQUEIO] Tentativa de ver detalhes de ve√≠culo ap√≥s venda fechada!');
      const veiculoEscolhido = lucas?.veiculoInteresse?.get(tel)?.nome || 'o ve√≠culo que voc√™ escolheu';
      return {
        resposta: `Voc√™ j√° escolheu o ${veiculoEscolhido}! üòä T√° tudo certo, hor√°rio marcado e tal. Quando vier aqui vai ver todos os detalhes pessoalmente!`,
        tipo: 'texto',
        bloqueio_venda_fechada: true
      };
    }

    // ========== IDENTIFICAR VE√çCULO DA LISTA ==========
    if (funcaoArgs.identificacao && lucas && tel) {
      const lista = lucas.getListaOpcoes(tel);

      if (lista && lista.veiculos && lista.veiculos.length > 0) {
        const identificacao = funcaoArgs.identificacao.toLowerCase();
        let veiculoEncontrado = null;

        console.log(`üîç [IDENTIFICACAO] Buscando "${identificacao}" em lista de ${lista.veiculos.length} ve√≠culos`);
        console.log(`üìã [IDENTIFICACAO] Ve√≠culos dispon√≠veis:`, lista.veiculos.map(v => `${v.id}: ${v.nome}`));

        // Tentar identificar por posi√ß√£o (primeiro, segundo, 1, 2, etc)
        const posicoes = {
          'primeiro': 0, 'primeira': 0, '1': 0, 'op√ß√£o 1': 0, 'opcao 1': 0,
          'segundo': 1, 'segunda': 1, '2': 1, 'op√ß√£o 2': 1, 'opcao 2': 1,
          'terceiro': 2, 'terceira': 2, '3': 2, 'op√ß√£o 3': 2, 'opcao 3': 2
        };

        if (posicoes[identificacao] !== undefined) {
          veiculoEncontrado = lista.veiculos[posicoes[identificacao]];
          console.log(`‚úÖ [IDENTIFICACAO] Encontrado por posi√ß√£o: ${veiculoEncontrado?.nome}`);
        }

        // Tentar identificar por nome/marca/modelo/cor (VERS√ÉO MELHORADA)
        if (!veiculoEncontrado) {
          // Limpar identifica√ß√£o removendo palavras comuns
          const identificacaoLimpa = identificacao
            .replace(/\b(o|a|um|uma|quero|ver|me mostre|mostre|mostrar|interessei|gostei|do|da|de)\b/g, '')
            .trim();

          veiculoEncontrado = lista.veiculos.find(v => {
            const nome = (v.nome || '').toLowerCase();
            const marca = (v.marca || '').toLowerCase();
            const modelo = (v.modelo || '').toLowerCase();
            const ano = String(v.ano || '');
            const cor = (v.cor || '').toLowerCase();

            console.log(`  üîé Comparando "${identificacao}" (limpo: "${identificacaoLimpa}") com:`, {
              nome, marca, modelo, ano, cor
            });

            // Verificar se a identifica√ß√£o cont√©m alguma palavra do nome/marca/modelo
            const palavrasIdentificacao = identificacaoLimpa.split(/\s+/).filter(p => p.length > 2);

            return palavrasIdentificacao.some(palavra =>
              nome.includes(palavra) ||
              marca.includes(palavra) ||
              modelo.includes(palavra) ||
              cor.includes(palavra) ||
              ano === palavra
            );
          });

          if (veiculoEncontrado) {
            console.log(`‚úÖ [IDENTIFICACAO] Encontrado por match: ${veiculoEncontrado.nome}`);
          }
        }

        if (veiculoEncontrado) {
          console.log(`‚úÖ [IDENTIFICACAO] Ve√≠culo encontrado na lista: ${veiculoEncontrado.nome} (ID: ${veiculoEncontrado.id})`);
          funcaoArgs.veiculo_id = veiculoEncontrado.id;

          // ‚úÖ SALVAR como ve√≠culo de interesse
          lucas.veiculoInteresse.set(tel, veiculoEncontrado);

          // ========== ENVIAR FOTOS DIRETAMENTE ==========
          if (funcaoArgs.incluir_fotos !== false && sock) {
            await lucas.enviarFotosVeiculo(veiculoEncontrado, tel, sock);

            // ‚úÖ MARCAR FOTOS COMO ENVIADAS
            const chaveFotos = `${tel}_${veiculoEncontrado.id}`;
            lucas.fotosJaEnviadas.set(chaveFotos, Date.now());

            // ‚úÖ LIMPAR LISTA ap√≥s enviar fotos do ve√≠culo escolhido
            lucas.clearListaOpcoes(tel);

            resultado = { sucesso: true, fotos_enviadas: true, veiculo: veiculoEncontrado };
            break;
          }
        } else {
          console.log(`‚ùå [IDENTIFICACAO] Ve√≠culo "${funcaoArgs.identificacao}" n√£o encontrado na lista`);
          resultado = { erro: `N√£o encontrei "${funcaoArgs.identificacao}" na lista que te mandei. Pode me dizer qual voc√™ quer ver?` };
          break;
        }
      } else {
        console.log(`‚ö†Ô∏è [IDENTIFICACAO] Nenhuma lista salva para ${tel}`);
        resultado = { erro: 'Preciso buscar os carros primeiro. Que tipo de ve√≠culo voc√™ procura?' };
        break;
      }
    }

    // Se n√£o tiver identificacao OU se tiver veiculo_id direto
    resultado = await this.funcoes.obter_detalhes_veiculo(funcaoArgs);
    break;
    
  case 'calcular_financiamento':
    resultado = await this.funcoes.calcular_financiamento(funcaoArgs);
    resultado.enviar_pergunta_documentacao = true; // Marcar para enviar pergunta
    break;

  case 'simular_financiamento_detalhado':
    resultado = await this.funcoes.simular_financiamento_detalhado(funcaoArgs);
    resultado.enviar_pergunta_documentacao = true; // Marcar para enviar pergunta
    break;

  case 'comparar_veiculos':
    resultado = await this.funcoes.comparar_veiculos(funcaoArgs);
    break;

  case 'consultar_score':
    // Adicionar tel aos argumentos
    funcaoArgs.tel = tel;
    resultado = await this.funcoes.consultar_score(funcaoArgs);
    break;

  case 'obter_estatisticas_estoque':
    resultado = await this.funcoes.obter_estatisticas_estoque(funcaoArgs);
    break;

  case 'consultar_valor_fipe':
    resultado = await this.funcoes.consultar_valor_fipe(funcaoArgs);

    // ========== ARMAZENAR DADOS PARA RETRY FIPE ==========
    if (resultado.pedir_detalhes && resultado.erro) {
      console.log('üîÑ [FIPE-RETRY] Armazenando dados para tentativa futura...');
      lucas.aguardandoDetalhesFipe.set(tel, {
        marca: resultado.marca,
        modelo: resultado.modelo,
        ano: resultado.ano,
        timestamp: Date.now(),
        tentativas: (lucas.aguardandoDetalhesFipe.get(tel)?.tentativas || 0) + 1
      });
      console.log(`üìã [FIPE-RETRY] Dados salvos:`, lucas.aguardandoDetalhesFipe.get(tel));
    } else if (resultado.sucesso) {
      // Se deu certo, limpar estado de retry
      lucas.aguardandoDetalhesFipe.delete(tel);
      console.log('‚úÖ [FIPE-RETRY] FIPE bem-sucedida, estado de retry limpo');
    }
    break;

  case 'comparar_preco_fipe':
    resultado = await this.funcoes.comparar_preco_fipe(funcaoArgs);
    break;

  case 'agendar_visita':
    console.log('üìÖ [FUNCAO] Executando agendar_visita:', JSON.stringify(funcaoArgs));

    // Adicionar informa√ß√µes do cliente aos argumentos
    funcaoArgs.cliente_telefone = tel;
    funcaoArgs.cliente_nome = lucas?.nomeCliente?.get(tel) || contextoAdicional?.nome || 'Cliente';

    try {
      resultado = await this.funcoes.agendar_visita(funcaoArgs);

      if (resultado.sucesso) {
        // Marcar etapa de agendamento confirmado
        if (lucas) {
          lucas.etapas.set(tel, 'AGENDAMENTO_CONFIRMADO');
          log.success(`‚úÖ [AGENDAMENTO] Etapa atualizada para AGENDAMENTO_CONFIRMADO`);
        }
      }

    } catch (error) {
      console.error('‚ùå [FUNCAO] Erro ao agendar visita:', error);
      resultado = {
        sucesso: false,
        mensagem: `Erro ao agendar visita: ${error.message}`
      };
    }
    break;

  default:
    resultado = { erro: 'Fun√ß√£o n√£o implementada' };
}

    log.success(`Fun√ß√£o retornou: ${JSON.stringify(resultado).substring(0, 100)}...`);

    // ‚úÖ SE ENVIOU LISTA, RETORNAR IMEDIATAMENTE SEM PROCESSAR MAIS
    if (resultado.lista_enviada) {
      log.success('‚úÖ Lista enviada, retornando sem processar mais tool_calls');
      return {
        resposta: '', // N√£o precisa de resposta textual, lista j√° foi enviada
        funcoes_chamadas: funcoesExecutadas,
        modelo_usado: 'openai',
        lista_foi_enviada: true
      };
    }

    // Adicionar resultado ao hist√≥rico
    messages.push(assistantMessage);
    messages.push({
      role: 'tool',
      tool_call_id: toolCall.id,
      content: JSON.stringify(resultado)
    });

    // ‚úÖ Processar o resultado da fun√ß√£o com Claude
    try {
      // ‚ùå OPENAI DESATIVADO
      // response = await openai.chat.completions.create({
      //   model: 'gpt-4o',
      //   messages: messages,
      //   tools: FUNCOES_DISPONIVEIS,
      //   tool_choice: 'auto',
      //   temperature: 0.9,
      //   max_tokens: 150
      // });

      // ‚úÖ USANDO CLAUDE
      throw new Error('OpenAI desativado, usando Claude');
    } catch (error) {
      // Usar Claude
      console.log(`üîÑ Usando Claude no loop de functions...`);

      if (anthropic) {
        try {
          response = await callClaude({
            messages: messages,
            tools: FUNCOES_DISPONIVEIS,
            max_tokens: 4096,
            temperature: 0.7
          });
          console.log('‚úÖ Claude respondeu com sucesso no loop! (fallback)');
        } catch (claudeError) {
          console.error('‚ùå Claude tamb√©m falhou no loop:', claudeError.message);
          throw new Error(`Ambas IAs falharam no loop. OpenAI: ${error.message}, Claude: ${claudeError.message}`);
        }
      } else {
        console.error('‚ùå OpenAI falhou no loop e Claude n√£o est√° configurado');
        throw error;
      }
    }
    
    assistantMessage = response.choices[0].message;
  }
  
  // Garantir que s√≥ retorna 1 string
  let respostaFinal = (assistantMessage.content || '').trim();

  // Limitar a resposta a no m√°ximo 5 linhas e 300 caracteres
  respostaFinal = respostaFinal
    .split('\n')
    .slice(0, 5)
    .join('\n')
    .substring(0, 300);

  // GROQ DESATIVADO
  // if (usouGroq) {
  //   console.log('üü¢ Resposta gerada pelo Groq');
  // }

  // Verificar se precisa enviar pergunta sobre documenta√ß√£o
  const precisaDocumentacao = funcoesExecutadas.some(f =>
    f === 'calcular_financiamento' || f === 'simular_financiamento_detalhado'
  );

  return {
    resposta: respostaFinal,
    funcoes_chamadas: funcoesExecutadas,
    modelo_usado: 'openai', // GROQ DESATIVADO
    lista_foi_enviada: funcoesExecutadas.includes('buscar_carros'),
    enviar_pergunta_documentacao: precisaDocumentacao
  };
  }
} 


// =====================================================
// REPOSIT√ìRIO (simplificado)
// =====================================================
class VeiculosRepository {
  constructor() {
    this.veiculos = [];
    this.cacheFile = path.join(__dirname, 'cache_veiculos.json');
    this.CACHE_DURACAO = 6 * 60 * 60 * 1000; // 6 horas em ms
  }

  // ‚Üê M√âTODO NOVO: Verificar se cache √© v√°lido
  cacheEstaValido() {
    try {
      if (!fs.existsSync(this.cacheFile)) {
        console.log('üìÇ Cache n√£o existe');
        return false;
      }

      const stats = fs.statSync(this.cacheFile);
      const idadeCache = Date.now() - stats.mtimeMs;
      const horasCache = Math.floor(idadeCache / 1000 / 60 / 60);

      if (idadeCache > this.CACHE_DURACAO) {
        console.log(`‚è∞ Cache expirado (${horasCache}h atr√°s)`);
        return false;
      }

      console.log(`‚úÖ Cache v√°lido (${horasCache}h atr√°s)`);
      return true;

    } catch (error) {
      console.error('‚ùå Erro ao verificar cache:', error.message);
      return false;
    }
  }

  // ‚Üê M√âTODO NOVO: Carregar do cache
  carregarCache() {
    try {
      console.log('üìÇ Carregando ve√≠culos do cache...');
      const data = fs.readFileSync(this.cacheFile, 'utf8');
      const cache = JSON.parse(data);

      this.veiculos = cache.veiculos || [];
      
      console.log(`‚úÖ ${this.veiculos.length} ve√≠culos carregados do cache`);
      
      if (this.veiculos.length > 0) {
        console.log('üìù Exemplo:', this.veiculos[0].nome);
      }

      return true;

    } catch (error) {
      console.error('‚ùå Erro ao carregar cache:', error.message);
      return false;
    }
  }

  // ‚Üê M√âTODO NOVO: Salvar no cache
  salvarCache() {
    try {
      console.log('üíæ Salvando ve√≠culos no cache...');
      
      const cache = {
        veiculos: this.veiculos,
        timestamp: Date.now(),
        total: this.veiculos.length
      };

      fs.writeFileSync(this.cacheFile, JSON.stringify(cache, null, 2), 'utf8');
      
      console.log(`‚úÖ Cache salvo: ${this.veiculos.length} ve√≠culos`);
      return true;

    } catch (error) {
      console.error('‚ùå Erro ao salvar cache:', error.message);
      return false;
    }
  }

  // ‚Üê M√âTODO ATUALIZADO: Buscar com cache
  async buscarVeiculos() {
    // ‚úÖ HABILITADO: Busca ve√≠culos do banco MySQL localhost
    console.log('‚ÑπÔ∏è  [INFO] Buscando ve√≠culos do banco de dados MySQL...');

    // ========== TENTAR USAR CACHE PRIMEIRO ==========
    if (this.cacheEstaValido()) {
      if (this.carregarCache()) {
        log.success(`${this.veiculos.length} ve√≠culos carregados do CACHE (instant√¢neo)`);
        return this.veiculos;
      }
    }

    // ========== SE CACHE INV√ÅLIDO, BUSCAR DO BANCO ==========
    console.log('üì§ Buscando ve√≠culos do banco MySQL (cache expirado ou inv√°lido)...');

    try {
      // ========== PASSO 1: Buscar TODOS os carros b√°sicos ==========
      console.log('üì§ [1/3] Buscando carros b√°sicos...');
      const carros = await db.query('SELECT id, feature_image, price, year, mileage, is_featured, is_special_offer FROM cars WHERE price > 0 AND status = "1" LIMIT 1000');
      
      console.log('‚úÖ Carros encontrados:', carros.length);
      
      if (carros.length === 0) {
        console.error('‚ö†Ô∏è Nenhum carro dispon√≠vel');
        return [];
      }
      
      // ========== PASSO 2: Buscar detalhes em LOTES ==========
      console.log('üì§ [2/3] Buscando detalhes em lotes...');
      
      const detalhesMap = {};
      let sucessos = 0;
      let erros = 0;
      const BATCH_SIZE = 10;
      
      for (let i = 0; i < carros.length; i += BATCH_SIZE) {
        const batch = carros.slice(i, i + BATCH_SIZE);
        const ids = batch.map(c => c.id).join(',');
        
        let tentativas = 0;
        let sucesso = false;
        
        while (tentativas < 3 && !sucesso) {
          try {
            const dets = await db.query(`SELECT cc.car_id, cc.title, cc.category_id, b.name as marca, cm.name as modelo, cc.fuel_type_id, cat.name as categoria FROM car_contents cc LEFT JOIN brands b ON cc.brand_id = b.id LEFT JOIN car_models cm ON cc.car_model_id = cm.id LEFT JOIN categories cat ON cc.category_id = cat.id WHERE cc.car_id IN (${ids})`);
            
            dets.forEach(d => {
              detalhesMap[d.car_id] = d;
            });
            
            sucessos += dets.length;
            sucesso = true;
            
            const progresso = Math.min(i + BATCH_SIZE, carros.length);
            if ((i + BATCH_SIZE) % 50 === 0 || progresso === carros.length) {
              console.log(`   ‚úì Progresso: ${progresso}/${carros.length} (${sucessos} ok, ${erros} erros)`);
            }
            
          } catch (err) {
            tentativas++;
            if (tentativas < 3) {
              await new Promise(r => setTimeout(r, 1000));
            } else {
              erros += batch.length;
            }
          }
        }
      }
      
      console.log(`‚úÖ Detalhes obtidos: ${sucessos} sucessos, ${erros} erros`);
      
      // ========== PASSO 3: Combinar dados ==========
      console.log('üì§ [3/3] Montando lista final...');
      
      this.veiculos = carros.map(c => {
        const det = detalhesMap[c.id] || {};

        // ‚úÖ CORRIGIR NOME: usar marca + modelo se title estiver vazio
        let nomeVeiculo = det.title;
        if (!nomeVeiculo || nomeVeiculo.trim() === '') {
          // Fallback: montar nome a partir de marca + modelo
          if (det.marca && det.modelo) {
            nomeVeiculo = `${det.marca} ${det.modelo}`;
          } else if (det.marca) {
            nomeVeiculo = det.marca;
          } else {
            nomeVeiculo = `Ve√≠culo ${c.id}`;
          }
        }

        return {
          id: c.id,
          nome: nomeVeiculo,
          marca: det.marca || 'N/A',
          modelo: det.modelo || '',
          preco: parseFloat(c.price) || 0,
          ano: (c.year || '').toString(),
          km: (c.mileage || '0').toString(),
          cambio: 'Manual',
          tipo_carroceria: det.categoria || '',
          foto: c.feature_image,
          is_featured: c.is_featured || '0',
          is_special_offer: c.is_special_offer || 0
        };
      }).filter(v => {
        const texto = `${v.nome} ${v.marca}`.toLowerCase();
        return !['biz', 'cg', 'titan', 'moto', 'honda cg', 'yamaha'].some(m => texto.includes(m));
      });

      console.log('‚úÖ Ve√≠culos processados:', this.veiculos.length);

      // ========== PASSO 4: Buscar fotos da car_images para ve√≠culos sem feature_image ==========
      const veiculosSemFoto = this.veiculos.filter(v => !v.foto);
      if (veiculosSemFoto.length > 0) {
        console.log(`üì∏ [4/4] Buscando fotos alternativas para ${veiculosSemFoto.length} ve√≠culos sem feature_image...`);

        for (const veiculo of veiculosSemFoto) {
          try {
            const fotosAlt = await db.query(
              'SELECT image FROM car_images WHERE car_id = ? LIMIT 1',
              [veiculo.id]
            );

            if (fotosAlt && fotosAlt.length > 0 && fotosAlt[0].image) {
              veiculo.foto = fotosAlt[0].image;
              console.log(`  ‚úì Foto encontrada para ve√≠culo ${veiculo.id}: ${fotosAlt[0].image}`);
            }
          } catch (err) {
            console.log(`  ‚úó Erro ao buscar foto alternativa para ve√≠culo ${veiculo.id}`);
          }
        }

        const comFotoAgora = this.veiculos.filter(v => v.foto).length;
        console.log(`‚úÖ Total de ve√≠culos com foto: ${comFotoAgora}/${this.veiculos.length}`);
      }
      
      if (this.veiculos.length > 0) {
        console.log('üìù Primeiro:', this.veiculos[0].nome);
        console.log('üìù √öltimo:', this.veiculos[this.veiculos.length - 1].nome);
      }
      
      // ========== SALVAR NO CACHE ==========
      this.salvarCache();
      
      log.success(`${this.veiculos.length} ve√≠culos carregados via API`);
      return this.veiculos;
      
    } catch (error) {
      console.error('‚ùå ERRO FATAL ao buscar ve√≠culos:');
      console.error('Mensagem:', error.message);
      
      // Se falhar e tem cache antigo, usar mesmo expirado
      if (fs.existsSync(this.cacheFile)) {
        console.log('‚ö†Ô∏è Usando cache antigo como fallback...');
        this.carregarCache();
      }

      return this.veiculos;
    }
  }

  // ‚Üê M√âTODO NOVO: For√ßar atualiza√ß√£o
  async forcarAtualizacao() {
    console.log('üîÑ For√ßando atualiza√ß√£o do cache...');
    
    if (fs.existsSync(this.cacheFile)) {
      fs.unlinkSync(this.cacheFile);
      console.log('üóëÔ∏è Cache deletado');
    }
    
    return this.buscarVeiculos();
  }

  // M√©todos antigos continuam iguais
  porId(id) {
    return this.veiculos.find(v => v.id === parseInt(id));
  }

  async buscarFotosVeiculo(veiculoId) {
    console.log(`\n[DEBUG-FOTOS-VEICULO] üîç Buscando fotos adicionais para ve√≠culo ID: ${veiculoId}`);

    try {
      const rows = await db.query(
        `SELECT id, image FROM car_images WHERE car_id = ${veiculoId} LIMIT 5`
      );

      console.log(`[DEBUG-FOTOS-VEICULO] üìä Encontradas ${rows?.length || 0} fotos na tabela car_images`);
      if (rows?.length > 0) {
        console.log(`[DEBUG-FOTOS-VEICULO] üìã Dados completos:`, JSON.stringify(rows, null, 2));
      }

      return rows.map(r => {
        const url = r.image.startsWith('http')
          ? r.image
          : `${BASE_URL}/public/assets/admin/img/car-gallery/${r.image}`;
        console.log(`[DEBUG-FOTOS-VEICULO] üîó URL montada: ${url}`);
        return url;
      });
    } catch (error) {
      log.error(`[FOTOS-VEICULO] Erro ao buscar fotos: ${error.message}`);
      console.error(`[DEBUG-FOTOS-VEICULO] Stack:`, error.stack);
      return [];
    }
  }

  // Buscar ve√≠culo espec√≠fico por ID
  async buscarVeiculoPorId(id) {
    try {
      // Primeiro tentar buscar no cache em mem√≥ria
      const veiculoCache = this.veiculos.find(v => parseInt(v.id) === parseInt(id));
      if (veiculoCache) {
        console.log(`‚úÖ [VEICULO-ID] Ve√≠culo ${id} encontrado no cache`);
        return veiculoCache;
      }

      // Se n√£o estiver no cache, buscar no banco
      console.log(`üì§ [VEICULO-ID] Buscando ve√≠culo ${id} no banco de dados...`);

      // Buscar dados b√°sicos do carro
      const [carro] = await db.query(`
        SELECT
          c.id, c.feature_image, c.price, c.year, c.mileage,
          c.is_featured, c.is_special_offer, c.status,
          c.lojista_telefone, c.lojista_nome
        FROM cars c
        WHERE c.id = ?
      `, [id]);

      if (!carro) {
        console.log(`‚ùå [VEICULO-ID] Ve√≠culo ${id} n√£o encontrado`);
        return null;
      }

      // Buscar conte√∫dos (nome, especifica√ß√µes, etc) + marca e modelo
      const [conteudo] = await db.query(`
        SELECT
          cc.title,
          cc.meta_keywords,
          b.name as marca,
          cm.name as modelo
        FROM car_contents cc
        LEFT JOIN brands b ON cc.brand_id = b.id
        LEFT JOIN car_models cm ON cc.car_model_id = cm.id
        WHERE cc.car_id = ? AND cc.language_id = 20
      `, [id]);

      // Buscar especifica√ß√µes
      const specs = await db.query(`
        SELECT cs.car_specification_id, cs.value, csc.name
        FROM car_specifications cs
        LEFT JOIN car_specification_contents csc ON cs.car_specification_id = csc.car_specification_id
        WHERE cs.car_id = ? AND (csc.language_id = 20 OR csc.language_id IS NULL)
      `, [id]);

      // ‚úÖ CORRIGIR NOME: usar marca + modelo se title estiver vazio
      let nomeVeiculo = conteudo?.title;
      if (!nomeVeiculo || nomeVeiculo.trim() === '') {
        // Fallback: montar nome a partir de marca + modelo
        if (conteudo?.marca && conteudo?.modelo) {
          nomeVeiculo = `${conteudo.marca} ${conteudo.modelo}`;
        } else if (conteudo?.marca) {
          nomeVeiculo = conteudo.marca;
        } else {
          nomeVeiculo = `Ve√≠culo ${carro.id}`;
        }
      }

      // Montar objeto do ve√≠culo
      const veiculo = {
        id: carro.id,
        nome: nomeVeiculo,
        preco: parseFloat(carro.price),
        ano: carro.year,
        km: carro.mileage,
        foto: carro.feature_image,
        especificacoes: specs,
        lojista_telefone: carro.lojista_telefone,
        lojista_nome: carro.lojista_nome
      };

      console.log(`‚úÖ [VEICULO-ID] Ve√≠culo encontrado:`, veiculo.nome);
      return veiculo;

    } catch (error) {
      console.error(`‚ùå [VEICULO-ID] Erro ao buscar ve√≠culo ${id}:`, error);
      return null;
    }
  }
}


// =====================================================
// ELEVENLABS - SPEECH TO TEXT E TEXT TO SPEECH
// =====================================================
class ElevenLabsService {
  constructor() {
    this.client = new ElevenLabsClient({
      apiKey: ELEVENLABS_API_KEY
    });
    this.voiceId = ELEVENLABS_VOICE_ID;
    // this.groqKey = GROQ_API_KEY; // GROQ DESATIVADO
  }


  

  // Speech-to-Text usando OpenAI Whisper
  async transcribeAudio(audioBuffer) {
    try {
      log.info('[OPENAI] Transcrevendo √°udio com Whisper...');

      const tempOgg = path.join(__dirname, `temp_input_${Date.now()}.ogg`);
      const tempMp3 = path.join(__dirname, `temp_input_${Date.now()}.mp3`);

      fs.writeFileSync(tempOgg, audioBuffer);

      // Converter OGG para MP3
      await new Promise((resolve, reject) => {
        ffmpeg(tempOgg)
          .toFormat('mp3')
          .audioFrequency(16000)
          .audioChannels(1)
          .on('end', resolve)
          .on('error', reject)
          .save(tempMp3);
      });

      // Usar OpenAI Whisper
      const transcription = await openai.audio.transcriptions.create({
        file: fs.createReadStream(tempMp3),
        model: 'whisper-1',
        language: 'pt'
      });

      const texto = transcription.text;
      log.success(`[OPENAI] Transcri√ß√£o: "${texto}"`);

      fs.unlinkSync(tempOgg);
      fs.unlinkSync(tempMp3);

      return texto;

    } catch (error) {
      log.error(`[OPENAI] Erro na transcri√ß√£o: ${error.message}`);

      // GROQ DESATIVADO - sem fallback de transcri√ß√£o
      log.error('[TRANSCRI√á√ÉO] Falha na transcri√ß√£o de √°udio');
      throw error;

      // // Fallback para Groq se OpenAI falhar
      // try {
      //   log.info('[OPENAI] Falhou, tentando Groq como fallback...');
      //
      //   const tempOgg = path.join(__dirname, `temp_input_fallback_${Date.now()}.ogg`);
      //   const tempMp3 = path.join(__dirname, `temp_input_fallback_${Date.now()}.mp3`);
      //
      //   fs.writeFileSync(tempOgg, audioBuffer);
      //
      //   await new Promise((resolve, reject) => {
      //     ffmpeg(tempOgg)
      //       .toFormat('mp3')
      //       .audioFrequency(16000)
      //       .audioChannels(1)
      //       .on('end', resolve)
      //       .on('error', reject)
      //       .save(tempMp3);
      //   });
      //
      //   const formData = new FormData();
      //   formData.append('file', fs.createReadStream(tempMp3));
      //   formData.append('model', 'whisper-large-v3');
      //   formData.append('language', 'pt');
      //
      //   const response = await axios.post(
      //     'https://api.groq.com/openai/v1/audio/transcriptions',
      //     formData,
      //     {
      //       headers: {
      //         'Authorization': `Bearer ${this.groqKey}`,
      //         ...formData.getHeaders()
      //       }
      //     }
      //   );
      //
      //   const texto = response.data.text;
      //   log.success(`[GROQ] Transcri√ß√£o (fallback): "${texto}"`);
      //
      //   fs.unlinkSync(tempOgg);
      //   fs.unlinkSync(tempMp3);
      //
      //   return texto;
      //
      // } catch (groqError) {
      //   log.error(`[GROQ] Fallback tamb√©m falhou: ${groqError.message}`);
      //   throw error;
      // }
    }
  }

  // Text-to-Speech usando SDK oficial da ElevenLabs
  async textToSpeech(texto) {
    const textoFormatado = FormatadorFala.prepararParaTTS(texto);
    try {
      log.info(`[ELEVENLABS] Gerando √°udio...`);

      const audioStream = await this.client.textToSpeech.convert(this.voiceId, {
        text: textoFormatado,
        model_id: 'eleven_multilingual_v2',
        voice_settings: {
          stability: 0.2,
          similarity_boost: 0.75,
          style: 0.6,
          use_speaker_boost: true
        },
        output_format: 'mp3_44100_128' // Garantir formato MP3
      });

      // Converter stream para buffer
      const chunks = [];
      for await (const chunk of audioStream) {
        chunks.push(chunk);
      }

      const audioBufferMp3 = Buffer.concat(chunks);
      log.info(`[ELEVENLABS] MP3 gerado (${audioBufferMp3.length} bytes)`);

      // ‚úÖ CONVERTER MP3 ‚Üí OGG/OPUS (formato ideal para WhatsApp)
      const tempMp3 = path.join(__dirname, `temp_tts_${Date.now()}.mp3`);
      const tempOgg = path.join(__dirname, `temp_tts_${Date.now()}.ogg`);

      fs.writeFileSync(tempMp3, audioBufferMp3);

      await new Promise((resolve, reject) => {
        ffmpeg(tempMp3)
          .toFormat('ogg')
          .audioCodec('libopus') // Codec Opus (melhor para voz)
          .audioBitrate('64k')   // Bitrate otimizado para voz
          .audioChannels(1)      // Mono
          .audioFrequency(48000) // 48kHz (padr√£o WhatsApp)
          .on('end', resolve)
          .on('error', reject)
          .save(tempOgg);
      });

      const audioBufferOgg = fs.readFileSync(tempOgg);

      // Limpar arquivos tempor√°rios
      fs.unlinkSync(tempMp3);
      fs.unlinkSync(tempOgg);

      log.success(`[ELEVENLABS] √Åudio convertido para OGG/Opus (${audioBufferOgg.length} bytes)`);
      return audioBufferOgg;

    } catch (error) {
      log.error(`[ELEVENLABS] Erro: ${error.message}`);
      throw error;
    }
  }
}


// ========== API BRASIL - CONSULTA SERASA ==========
class ConsultaSerasaService {
  constructor() {
    this.baseURL = 'https://gateway.apibrasil.io/api/v2';
    this.token = process.env.APIBRASIL_TOKEN;
    this.deviceToken = process.env.APIBRASIL_DEVICE_TOKEN;
  }

  /**
   * Consulta score de cr√©dito por CPF
   * @param {string} cpf - CPF do cliente (apenas n√∫meros)
   * @returns {Promise<Object>} - Dados do score e an√°lise de cr√©dito
   */
  async consultarScorePorCPF(cpf) {
    try {
      // Limpar CPF (remover pontos e tra√ßos)
      const cpfLimpo = cpf.replace(/\D/g, '');

      if (cpfLimpo.length !== 11) {
        throw new Error('CPF inv√°lido. Deve conter 11 d√≠gitos.');
      }

      log.info(`[SERASA] Consultando score para CPF: ${cpfLimpo.substring(0, 3)}.***.***-${cpfLimpo.substring(9)}`);

      const response = await axios.post(
        `${this.baseURL}/consulta/cpf/credits`,
        {
          cpf: cpfLimpo
        },
        {
          headers: {
            'Authorization': `Bearer ${this.token}`,
            'DeviceToken': this.deviceToken,
            'Content-Type': 'application/json'
          }
        }
      );

      const dados = response.data;

      log.success(`[SERASA] ‚úÖ Consulta realizada com sucesso!`);

      // Processar e retornar dados estruturados
      return {
        sucesso: true,
        cpf: cpfLimpo,
        dados_cadastrais: {
          nome: dados.nome || 'N√£o dispon√≠vel',
          data_nascimento: dados.dataNascimento || null,
          situacao_cpf: dados.situacaoCpf || 'N√£o informado'
        },
        score: {
          pontuacao: dados.score || null,
          classificacao: this.classificarScore(dados.score),
          descricao: this.getDescricaoScore(dados.score)
        },
        pendencias: {
          pefin: dados.pefin || [],
          refin: dados.refin || [],
          protestos: dados.protestos || [],
          total_pendencias: (dados.pefin?.length || 0) + (dados.refin?.length || 0) + (dados.protestos?.length || 0)
        },
        analise_credito: {
          aprovado: this.analisarCredito(dados),
          motivo: this.getMotivoAnalise(dados),
          recomendacao: this.getRecomendacao(dados)
        }
      };

    } catch (error) {
      log.error(`[SERASA] ‚ùå Erro na consulta: ${error.message}`);

      if (error.response) {
        log.error(`[SERASA] Status: ${error.response.status}`);
        log.error(`[SERASA] Detalhes: ${JSON.stringify(error.response.data)}`);
      }

      return {
        sucesso: false,
        erro: error.message,
        detalhes: error.response?.data || null
      };
    }
  }

  /**
   * Classifica score em categorias
   */
  classificarScore(score) {
    if (!score) return 'N√£o dispon√≠vel';
    if (score >= 800) return 'Excelente';
    if (score >= 700) return 'Bom';
    if (score >= 600) return 'Regular';
    if (score >= 500) return 'Ruim';
    return 'Muito Ruim';
  }

  /**
   * Retorna descri√ß√£o do score
   */
  getDescricaoScore(score) {
    if (!score) return 'Score n√£o dispon√≠vel no momento';
    if (score >= 800) return 'Cr√©dito aprovado com melhores condi√ß√µes';
    if (score >= 700) return 'Boas chances de aprova√ß√£o';
    if (score >= 600) return 'Aprova√ß√£o poss√≠vel com entrada maior';
    if (score >= 500) return 'Aprova√ß√£o dif√≠cil, necess√°rio avaliar entrada';
    return 'Recomendado entrada de 50% ou mais';
  }

  /**
   * Analisa se o cr√©dito pode ser aprovado
   */
  analisarCredito(dados) {
    const score = dados.score || 0;
    const temPendencias = (dados.pefin?.length || 0) + (dados.refin?.length || 0) + (dados.protestos?.length || 0) > 0;

    // Regras de aprova√ß√£o
    if (score >= 700 && !temPendencias) return true;
    if (score >= 600 && !temPendencias) return true;
    if (score >= 500 && !temPendencias) return true; // Com entrada maior

    return false;
  }

  /**
   * Retorna motivo da an√°lise
   */
  getMotivoAnalise(dados) {
    const score = dados.score || 0;
    const pendencias = (dados.pefin?.length || 0) + (dados.refin?.length || 0) + (dados.protestos?.length || 0);

    if (score >= 700 && pendencias === 0) {
      return 'Score excelente e sem pend√™ncias';
    }
    if (score >= 600 && pendencias === 0) {
      return 'Score bom e sem pend√™ncias';
    }
    if (pendencias > 0) {
      return `Possui ${pendencias} pend√™ncia(s) financeira(s)`;
    }
    if (score < 500) {
      return 'Score abaixo do m√≠nimo recomendado';
    }
    return 'An√°lise de cr√©dito padr√£o';
  }

  /**
   * Retorna recomenda√ß√£o para o vendedor
   */
  getRecomendacao(dados) {
    const score = dados.score || 0;
    const pendencias = (dados.pefin?.length || 0) + (dados.refin?.length || 0) + (dados.protestos?.length || 0);

    if (score >= 700 && pendencias === 0) {
      return 'Oferecer financiamento com entrada padr√£o (20-30%)';
    }
    if (score >= 600 && pendencias === 0) {
      return 'Oferecer financiamento com entrada de 30-40%';
    }
    if (score >= 500 && pendencias === 0) {
      return 'Solicitar entrada de 40-50% ou ve√≠culo de troca';
    }
    if (pendencias > 0) {
      return 'Solicitar entrada maior (50%+) ou regulariza√ß√£o das pend√™ncias';
    }
    return 'Avaliar possibilidade de venda √† vista ou entrada de 60%+';
  }

  /**
   * Formata resposta para a Aira falar com o cliente
   */
  formatarRespostaParaCliente(resultado, nomeCliente) {
    if (!resultado.sucesso) {
      return 'Tive um probleminha ao consultar o score. Mas podemos continuar mesmo assim! Me conta, voc√™ tem um ve√≠culo para dar de entrada?';
    }

    const { score, analise_credito, pendencias } = resultado;

    if (analise_credito.aprovado) {
      return `${nomeCliente}, t√° tudo certo! Seu score t√° ${score.classificacao.toLowerCase()} (${score.pontuacao} pontos)! ${analise_credito.recomendacao}. Vamos montar a proposta?`;
    } else if (pendencias.total_pendencias > 0) {
      return `${nomeCliente}, vi aqui que tem ${pendencias.total_pendencias} pend√™ncia(s) no seu nome. Mas calma, a gente consegue resolver! ${analise_credito.recomendacao}. Voc√™ tem um carro pra dar de entrada?`;
    } else {
      return `${nomeCliente}, o score t√° em ${score.pontuacao} pontos. ${analise_credito.recomendacao}. Voc√™ consegue dar uma entrada maior ou tem um ve√≠culo pra trocar?`;
    }
  }
}


// ========== ELEVENLABS AGENT (CONVERSATIONAL AI) ==========
class ElevenLabsAgent {
  constructor() {
    this.apiKey = ELEVENLABS_API_KEY;
    this.agentId = process.env.ELEVENLABS_AGENT_ID;
    this.conversasAtivas = new Map();
  }

  async iniciarConversa(tel) {
    try {
      log.info(`[AGENT] Iniciando conversa para ${tel}`);
      
      const response = await axios.post(
        `https://api.elevenlabs.io/v1/convai/conversation`,
        {
          agent_id: this.agentId
        },
        {
          headers: {
            'xi-api-key': this.apiKey,
            'Content-Type': 'application/json'
          }
        }
      );
      
      const conversationId = response.data.conversation_id;
      this.conversasAtivas.set(tel, conversationId);
      
      log.success(`[AGENT] Conversa criada: ${conversationId}`);
      return conversationId;
      
    } catch (error) {
      log.error(`[AGENT] Erro ao criar conversa: ${error.message}`);
      throw error;
    }
  }

  async enviarAudio(tel, audioBuffer) {
    try {
      let conversationId = this.conversasAtivas.get(tel);
      
      if (!conversationId) {
        conversationId = await this.iniciarConversa(tel);
      }
      
      log.info(`[AGENT] Enviando √°udio para conversa ${conversationId}`);
      
      // Converter √°udio para o formato correto se necess√°rio
      const tempInput = path.join(__dirname, `temp_agent_input_${Date.now()}.mp3`);
      
      // Se for OGG, converter para MP3
      if (audioBuffer[0] === 0x4F && audioBuffer[1] === 0x67) {
        const tempOgg = path.join(__dirname, `temp_ogg_${Date.now()}.ogg`);
        fs.writeFileSync(tempOgg, audioBuffer);
        
        await new Promise((resolve, reject) => {
          ffmpeg(tempOgg)
            .toFormat('mp3')
            .audioFrequency(16000)
            .audioChannels(1)
            .on('end', resolve)
            .on('error', reject)
            .save(tempInput);
        });
        
        fs.unlinkSync(tempOgg);
      } else {
        fs.writeFileSync(tempInput, audioBuffer);
      }
      
      const formData = new FormData();
      formData.append('audio', fs.createReadStream(tempInput));
      
      const response = await axios.post(
        `https://api.elevenlabs.io/v1/convai/conversation/${conversationId}/audio`,
        formData,
        {
          headers: {
            'xi-api-key': this.apiKey,
            ...formData.getHeaders()
          },
          responseType: 'arraybuffer',
          timeout: 30000
        }
      );
      
      fs.unlinkSync(tempInput);
      
      log.success(`[AGENT] Resposta recebida (${response.data.length} bytes)`);
      return Buffer.from(response.data);
      
    } catch (error) {
      log.error(`[AGENT] Erro: ${error.message}`);
      throw error;
    }
  }

  finalizarConversa(tel) {
    this.conversasAtivas.delete(tel);
    log.info(`[AGENT] Conversa finalizada para ${tel}`);
  }
}


class LucasVendedor {
  constructor(repo) {
    this.repo = repo;
    this.funcoes = new FuncoesVeiculos(repo);
    this.motorGPT = new MotorGPTFunctions(this.funcoes);
    this.agentElevenLabs = new ElevenLabsAgent(); // ‚Üê ELEVENLABS AGENTE

    // ‚ùå IA MASTER DESATIVADA (n√£o est√° sendo usada, economiza recursos)
    // this.iaMaster = new IAMaster(OPENAI_API_KEY, GROQ_API_KEY || '', db);
    // console.log('[AIRA] ‚úì IA Master inicializado');

    this.conversas = new Map();
    this.etapas = new Map();
    this.jaSeApresentou = new Map();
    this.ultimoEnvio = new Map();
    this.listaOpcoes = new Map(); // ‚Üê ADICIONAR ESTA LINHA
    this.jaRespondeuAudio = new Map();

    // ========== SISTEMA DE AGREGA√á√ÉO DE MENSAGENS ==========
    this.mensagensPendentes = new Map(); // Armazena mensagens aguardando processamento
    this.timersAgregacao = new Map(); // Timers para processar mensagens agrupadas
    this.TEMPO_ESPERA_MENSAGENS = 4000; // 4 segundos para aguardar mais mensagens (aumentado para melhor agrega√ß√£o)

    // ‚úÖ MAPAS DE ESTADO:
    this.veiculoInteresse = new Map(); // ‚Üê Guarda qual carro o cliente quer
    this.veiculoTroca = new Map();
    this.aguardandoDetalhesFipe = new Map(); // ‚Üê Guarda tentativas de FIPE aguardando detalhes
    this.fotosJaEnviadas = new Map(); // ‚Üê Controla se fotos detalhadas do ve√≠culo j√° foram enviadas
    this.veiculosJaMostrados = new Map(); // ‚Üê Guarda IDs de ve√≠culos j√° enviados para cada cliente
  }

  // ========== FUN√á√ÉO HELPER: TIMEOUT PARA OPERA√á√ïES ASS√çNCRONAS ==========
  /**
   * Executa uma promise com timeout
   * @param {Promise} promise - Promise a ser executada
   * @param {number} timeoutMs - Timeout em milissegundos
   * @param {string} operacao - Nome da opera√ß√£o (para logs)
   * @returns {Promise} - Resultado da promise ou erro de timeout
   */
  async comTimeout(promise, timeoutMs, operacao = 'opera√ß√£o') {
    return Promise.race([
      promise,
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error(`Timeout: ${operacao} demorou mais de ${timeoutMs}ms`)), timeoutMs)
      )
    ]);
  }

  // ========== M√âTODO GERADOR DE √ÅUDIO COM PROTE√á√ÉO CONTRA CORTES ==========
  /**
   * Gera √°udio usando ElevenLabs com prote√ß√µes contra cortes
   * @param {string} texto - Texto para converter em √°udio
   * @returns {Promise<Buffer>} - Buffer do √°udio gerado
   */
  async gerarAudio(texto) {
    try {
      // 1. Validar texto
      if (!texto || typeof texto !== 'string') {
        throw new Error('Texto inv√°lido para TTS');
      }

      const textoLimpo = texto.trim();
      if (textoLimpo.length === 0) {
        throw new Error('Texto vazio');
      }

      // 2. LIMITE DE CARACTERES (ElevenLabs suporta at√© ~5000 chars, mas vamos limitar a 1000 para evitar cortes)
      const LIMITE_CARACTERES = 1000;
      let textoFinal = textoLimpo;

      if (textoLimpo.length > LIMITE_CARACTERES) {
        log.warning(`[TTS] ‚ö†Ô∏è Texto muito longo (${textoLimpo.length} chars), truncando para ${LIMITE_CARACTERES}...`);

        // Truncar no √∫ltimo ponto/exclama√ß√£o/interroga√ß√£o antes do limite
        const textoTruncado = textoLimpo.substring(0, LIMITE_CARACTERES);
        const ultimoPonto = Math.max(
          textoTruncado.lastIndexOf('.'),
          textoTruncado.lastIndexOf('!'),
          textoTruncado.lastIndexOf('?')
        );

        if (ultimoPonto > 0) {
          textoFinal = textoTruncado.substring(0, ultimoPonto + 1);
        } else {
          textoFinal = textoTruncado + '...';
        }

        log.info(`[TTS] Texto truncado: "${textoFinal}"`);
      }

      // 3. Formatar texto para TTS
      const textoFormatado = FormatadorFala.prepararParaTTS(textoFinal);
      log.info(`[TTS] Texto formatado (${textoFormatado.length} chars): "${textoFormatado.substring(0, 100)}${textoFormatado.length > 100 ? '...' : ''}"`);

      // 4. Gerar √°udio com timeout adequado
      const elevenLabs = new ElevenLabsService();

      // Timeout baseado no tamanho do texto (50ms por caractere + 5 segundos de margem)
      const timeoutMs = Math.min(60000, (textoFormatado.length * 50) + 5000);
      log.info(`[TTS] Timeout definido: ${timeoutMs}ms`);

      const audioBuffer = await Promise.race([
        elevenLabs.textToSpeech(textoFormatado),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Timeout na gera√ß√£o de √°udio')), timeoutMs)
        )
      ]);

      if (!audioBuffer || audioBuffer.length === 0) {
        throw new Error('√Åudio vazio retornado');
      }

      log.success(`[TTS] ‚úÖ √Åudio gerado com sucesso (${audioBuffer.length} bytes)`);
      return audioBuffer;

    } catch (error) {
      log.error(`[TTS] ‚ùå Erro ao gerar √°udio: ${error.message}`);
      throw error;
    }
  }

  // ========== M√âTODO PARA ENVIAR √ÅUDIO COM TRATAMENTO ADEQUADO ==========
  /**
   * Envia √°udio com todos os tratamentos necess√°rios para evitar erro "Aguardando mensagem"
   * @param {Buffer} audioBuffer - Buffer do √°udio
   * @param {string} tel - N√∫mero do telefone
   * @param {object} sock - Socket do WhatsApp
   * @param {string} context - Contexto (para nome do arquivo tempor√°rio)
   * @returns {Promise<void>}
   */
  async enviarAudioSeguro(audioBuffer, tel, sock, context = 'audio') {
    let audioPath = null;

    try {
      // 1. Validar buffer
      if (!audioBuffer || audioBuffer.length === 0) {
        throw new Error('Buffer de √°udio vazio');
      }

      // 2. Salvar em arquivo tempor√°rio
      audioPath = path.join(__dirname, `temp_${context}_${Date.now()}.mp3`);
      fs.writeFileSync(audioPath, audioBuffer);

      // Validar que arquivo foi criado
      const stats = fs.statSync(audioPath);
      if (stats.size === 0) {
        throw new Error('Arquivo de √°udio criado est√° vazio');
      }

      log.info(`[AUDIO] Arquivo salvo: ${stats.size} bytes`);

      // 3. Iniciar status "gravando"
      await sock.sendPresenceUpdate('recording', tel);

      // 4. ‚úÖ DELAY CR√çTICO: Aguardar WhatsApp processar o status (300ms - aumentado)
      await new Promise(r => setTimeout(r, 300));

      // 5. Enviar √°udio
      await sock.sendMessage(tel, {
        audio: { url: audioPath },
        mimetype: 'audio/ogg; codecs=opus', // ‚úÖ OGG/Opus (formato correto vindo do ElevenLabs)
        ptt: true
      });

      log.success(`[AUDIO] ‚úÖ √Åudio enviado com sucesso (${context})`);

      // 6. Aguardar processamento antes de limpar status (300ms - aumentado)
      await new Promise(r => setTimeout(r, 300));

      // 7. Limpar arquivo tempor√°rio
      try {
        fs.unlinkSync(audioPath);
      } catch (unlinkErr) {
        log.warning(`[AUDIO] N√£o foi poss√≠vel limpar arquivo: ${unlinkErr.message}`);
      }

      // 8. Limpar status "gravando"
      await sock.sendPresenceUpdate('paused', tel);

      // 9. Delay final para garantir que pr√≥xima mensagem n√£o conflite (500ms - aumentado)
      await new Promise(r => setTimeout(r, 500));

    } catch (error) {
      log.error(`[AUDIO] ‚ùå Erro ao enviar √°udio: ${error.message}`);

      // Limpar arquivo se existir
      if (audioPath && fs.existsSync(audioPath)) {
        try {
          fs.unlinkSync(audioPath);
        } catch (err) {
          log.error(`[AUDIO] Erro ao limpar arquivo: ${err.message}`);
        }
      }

      // Garantir que status seja limpo mesmo em erro
      try {
        await sock.sendPresenceUpdate('paused', tel);
      } catch (err) {
        log.error(`[AUDIO] Erro ao limpar status: ${err.message}`);
      }

      throw error;
    }
  }

  // ========== M√âTODO PARA GERAR MENSAGENS DE ERRO/DESCULPA ESPONT√ÇNEAS ==========
  /**
   * Gera mensagem de desculpa/erro de forma espont√¢nea usando IA
   * @param {string} contexto - Contexto do erro (ex: 'foto_nao_carregou', 'foto_nao_existe', 'erro_geral')
   * @param {string} detalhes - Detalhes opcionais sobre o erro
   * @returns {Promise<string>} - Mensagem espont√¢nea gerada
   */
  async gerarMensagemErroEspontanea(contexto, detalhes = '') {
    try {
      const prompts = {
        foto_nao_carregou: `Voc√™ √© a Aira. Uma foto do ve√≠culo n√£o carregou (erro t√©cnico tempor√°rio).

INSTRU√á√ïES:
- Pe√ßa desculpas de forma natural e breve (1 linha)
- Seja emp√°tica mas n√£o dram√°tica
- Diga que vai tentar novamente ou contornar o problema
- Use express√µes brasileiras informais
- N√ÉO use "Ops", "Opa", "Desculpe" sempre - varie!

EXEMPLOS DE TOM (N√ÉO copie):
"Eita, essa foto travou aqui... Deixa eu tentar de novo!"
"Rapaz, essa imagem n√£o quis aparecer... Vou mandar outra!"

Sua mensagem (m√°ximo 1 linha):`,

        foto_nao_existe: `Voc√™ √© a Aira. O ve√≠culo n√£o tem foto cadastrada no sistema ainda.

INSTRU√á√ïES:
- Explique rapidamente que a foto ainda n√£o foi cadastrada (1 linha)
- Ofere√ßa alternativa: enviar detalhes por texto
- Seja positiva e proativa
- Use linguagem informal

EXEMPLOS DE TOM (N√ÉO copie):
"Ah, esse ainda t√° sem foto no sistema... Mas posso te mandar todos os detalhes!"
"Puxa, n√£o cadastraram foto desse ainda... Te passo as informa√ß√µes, beleza?"

Sua mensagem (m√°ximo 1 linha):`,

        erro_geral: `Voc√™ √© a Aira. O WhatsApp est√° sobrecarregado com muitas mensagens chegando.

INSTRU√á√ïES:
- Culpe o WhatsApp por estar com muita mensagem
- Diga que a mensagem do cliente n√£o apareceu/sumiu
- Pe√ßa para reenviar
- Seja natural e emp√°tica (1 linha)
- Varie MUITO as express√µes

EXEMPLOS DE TOM (N√ÉO copie exatamente):
"Opa, o WhatsApp t√° louco aqui! Sua mensagem sumiu. Manda de novo?"
"Pow, o zap t√° sobrecarregado! N√£o apareceu aqui. Reenvia?"

Sua mensagem (m√°ximo 1 linha):`
      };

      const promptEscolhido = prompts[contexto] || prompts.erro_geral;

      // ‚úÖ USAR CLAUDE PARA MENSAGENS DE ERRO ESPONT√ÇNEAS
      // const resposta = await openai.chat.completions.create({ ... }); // OPENAI DESATIVADO

      const mensagem = await callClaudeInsteadOfOpenAI(this.anthropic, {
        messages: [{
          role: 'system',
          content: promptEscolhido + (detalhes ? `\n\nContexto adicional: ${detalhes}` : '')
        }],
        temperature: 0.9,
        max_tokens: 50
      });

      log.info(`[ERRO-ESPONTANEO] üí¨ Gerado via Claude (${contexto}): "${mensagem}"`);
      return mensagem;

    } catch (error) {
      log.error(`[ERRO-ESPONTANEO] ‚ùå Falha ao gerar: ${error.message}`);
      // √öltimo recurso: culpar WhatsApp
      const emergencia = [
        'O WhatsApp t√° com muita mensagem! A sua sumiu. Manda de novo?',
        'Pow, o zap travou aqui! N√£o vi sua mensagem. Reenvia?',
        'O WhatsApp t√° sobrecarregado! Sua mensagem n√£o apareceu. Pode mandar de novo?'
      ];
      return emergencia[Math.floor(Math.random() * emergencia.length)];
    }
  }

detectarIntencaoTroca(msg) {
  const msgLower = msg.toLowerCase();

  // ‚ö†Ô∏è CR√çTICO: N√ÉO detectar como troca se cliente mencionar valor em dinheiro
  // Ex: "vou dar 25mil de entrada", "25 mil de entrada", "tenho 30k de entrada"
  const temValorDinheiro = /\b(\d+)\s*(mil|k|reais)\s*(de\s+)?entrada\b/i.test(msgLower);
  const recusaTroca = /\b(n√£o|nao)\s+(quero|vou|queria)\s+(dar|trocar|oferecer|colocar)\s+(o|meu)\s+(carro|ve√≠culo|veiculo)/i.test(msgLower);

  if (temValorDinheiro || recusaTroca) {
    log.info('‚ö†Ô∏è Cliente mencionou entrada em DINHEIRO ou RECUSOU troca, n√£o √© inten√ß√£o de troca');
    return false;
  }

  const palavrasChaveTroca = [
    /\btenho um.*?(carro|ve√≠culo|veiculo)\b/i,
    /\bdar\s+(o|meu)\s+(carro|ve√≠culo|veiculo)\s+de entrada\b/i,
    /\bpra trocar\b/i,
    /\bpara trocar\b/i,
    /\bquero trocar\b/i,
    /\btrocar por\b/i,
    /\baceita.*?troca\b/i,
    /\btrocam.*?carro\b/i,
    /\bcarro.*?de entrada\b/i
  ];

  return palavrasChaveTroca.some(regex => regex.test(msgLower));
}

/**
 * Detecta se cliente mencionou entrada em DINHEIRO (n√£o ve√≠culo)
 */
detectarEntradaDinheiro(msg) {
  const msgLower = msg.toLowerCase();

  // Padr√µes de entrada em dinheiro
  const padroesDinheiro = [
    /\b(\d+)\s*(mil|k)\s*(de\s+)?entrada\b/i,                    // "25 mil de entrada"
    /\b(\d+)\s*k\s*(de\s+)?entrada\b/i,                          // "25k de entrada"
    /\b(\d+)\s*mil\s*reais\s*(de\s+)?entrada\b/i,               // "25 mil reais de entrada"
    /\bvou\s+dar\s+(\d+)\s*(mil|k|reais)/i,                     // "vou dar 25 mil"
    /\btenho\s+(\d+)\s*(mil|k|reais)\s+(pra|para)\s+dar/i,      // "tenho 25 mil pra dar"
    /\bentrada\s+de\s+(\d+)\s*(mil|k|reais)/i                   // "entrada de 25 mil"
  ];

  return padroesDinheiro.some(regex => regex.test(msgLower));
}

/**
 * Extrai valor da entrada em dinheiro mencionada
 */
extrairValorEntradaDinheiro(msg) {
  const match = msg.match(/\b(\d+)\s*(mil|k)\b/i);
  if (match) {
    const numero = parseInt(match[1]);
    const unidade = match[2].toLowerCase();
    return unidade === 'mil' || unidade === 'k' ? numero * 1000 : numero;
  }
  return null;
}

/**
 * Extrai dados do ve√≠culo da mensagem (modelo, ano, km)
 * Ex: "tenho um gol g4 2018" ‚Üí { modelo: "gol", ano: "2018" }
 */
extrairDadosVeiculo(msg) {
  const msgLower = msg.toLowerCase();
  const dados = {};

  // 1. EXTRAIR MODELO (lista expandida de modelos brasileiros)
  const modelosRegex = /\b(gol|civic|corolla|onix|hb20|sandero|ka|uno|palio|fiesta|fox|voyage|prisma|celta|argo|mobi|kwid|duster|kicks|creta|tucson|sportage|hr-v|hrv|compass|renegade|toro|hilux|ranger|s10|amarok|strada|montana|saveiro|fiat.*?toro|jeep.*?compass|jeep.*?renegade|chevrolet.*?onix|honda.*?civic|honda.*?hr-v|toyota.*?corolla|volkswagen.*?gol|nissan.*?kicks|hyundai.*?hb20|renault.*?sandero|renault.*?kwid)\b/i;
  const matchModelo = msg.match(modelosRegex);
  if (matchModelo) {
    // Limpar marca se vier junto (ex: "honda civic" ‚Üí "civic")
    dados.modelo = matchModelo[0]
      .replace(/\b(chevrolet|honda|toyota|volkswagen|nissan|hyundai|renault|fiat|jeep)\b/gi, '')
      .trim()
      .toLowerCase();
  }

  // 2. EXTRAIR ANO (4 d√≠gitos iniciando com 19xx ou 20xx)
  const anoMatch = msg.match(/\b(19\d{2}|20\d{2})\b/);
  if (anoMatch) {
    dados.ano = anoMatch[0];
  }

  // 3. EXTRAIR KM (formato: "50 mil km", "50000 km", etc)
  const kmMatch = msg.match(/(\d+)\s*(mil|k|km|quil√¥metros|quilometros)/i);
  if (kmMatch) {
    const numero = parseInt(kmMatch[1]);
    const unidade = kmMatch[2].toLowerCase();
    dados.km = unidade.includes('mil') || unidade === 'k' ? numero * 1000 : numero;
  }

  // 4. EXTRAIR VERS√ÉO (ex: "1.0", "1.6", "2.0")
  const versaoMatch = msg.match(/\b(\d+\.\d+)\b/);
  if (versaoMatch) {
    dados.versao = versaoMatch[0];
  }

  return dados;
}

/**
 * Consulta valor FIPE do ve√≠culo usando wrapper
 * @param {string} modelo - Modelo do ve√≠culo
 * @param {string} ano - Ano do ve√≠culo
 * @returns {number|null} - Valor FIPE (n√∫mero) ou null se n√£o encontrado
 */
async consultarFIPE(modelo, ano) {
  try {
    // Mapear modelo para marca (heur√≠stica inteligente)
    const mapeamentoMarcas = {
      'gol': 'volkswagen', 'fox': 'volkswagen', 'voyage': 'volkswagen', 'polo': 'volkswagen', 'saveiro': 'volkswagen', 'up': 'volkswagen', 'amarok': 'volkswagen', 't-cross': 'volkswagen', 'tiguan': 'volkswagen', 'jetta': 'volkswagen', 'virtus': 'volkswagen', 'nivus': 'volkswagen', 'taos': 'volkswagen',
      'civic': 'honda', 'city': 'honda', 'fit': 'honda', 'hr-v': 'honda', 'hrv': 'honda', 'crv': 'honda', 'cr-v': 'honda', 'accord': 'honda', 'wr-v': 'honda', 'wrv': 'honda',
      'corolla': 'toyota', 'hilux': 'toyota', 'etios': 'toyota', 'yaris': 'toyota', 'sw4': 'toyota', 'prius': 'toyota', 'rav4': 'toyota', 'camry': 'toyota', 'fielder': 'toyota',
      'onix': 'chevrolet', 'prisma': 'chevrolet', 'cruze': 'chevrolet', 's10': 'chevrolet', 'spin': 'chevrolet', 'tracker': 'chevrolet', 'equinox': 'chevrolet', 'montana': 'chevrolet', 'joy': 'chevrolet', 'cobalt': 'chevrolet', 'sonic': 'chevrolet', 'trailblazer': 'chevrolet',
      'hb20': 'hyundai', 'creta': 'hyundai', 'tucson': 'hyundai', 'ix35': 'hyundai', 'i30': 'hyundai', 'azera': 'hyundai', 'elantra': 'hyundai', 'santa fe': 'hyundai', 'hb20s': 'hyundai',
      'sandero': 'renault', 'kwid': 'renault', 'duster': 'renault', 'logan': 'renault', 'captur': 'renault', 'fluence': 'renault', 'oroch': 'renault', 'stepway': 'renault', 'master': 'renault',
      'ka': 'ford', 'ecosport': 'ford', 'ranger': 'ford', 'fusion': 'ford', 'edge': 'ford', 'focus': 'ford', 'fiesta': 'ford', 'territory': 'ford',
      'uno': 'fiat', 'palio': 'fiat', 'argo': 'fiat', 'mobi': 'fiat', 'toro': 'fiat', 'strada': 'fiat', 'cronos': 'fiat', 'fiorino': 'fiat', 'ducato': 'fiat', 'pulse': 'fiat', 'fastback': 'fiat', 'siena': 'fiat', 'punto': 'fiat', 'linea': 'fiat', 'bravo': 'fiat',
      'compass': 'jeep', 'renegade': 'jeep', 'commander': 'jeep', 'wrangler': 'jeep', 'cherokee': 'jeep', 'grand cherokee': 'jeep',
      'kicks': 'nissan', 'versa': 'nissan', 'march': 'nissan', 'sentra': 'nissan', 'frontier': 'nissan', 'leaf': 'nissan', 'livina': 'nissan',
      'sportage': 'kia', 'sorento': 'kia', 'soul': 'kia', 'cerato': 'kia', 'picanto': 'kia', 'rio': 'kia', 'stonic': 'kia', 'seltos': 'kia',
      'c3': 'citroen', 'c4': 'citroen', 'aircross': 'citroen', 'berlingo': 'citroen', 'jumper': 'citroen',
      '208': 'peugeot', '2008': 'peugeot', '3008': 'peugeot', '408': 'peugeot', '5008': 'peugeot', 'expert': 'peugeot'
    };

    const modeloLower = modelo.toLowerCase();
    const nomeMarca = mapeamentoMarcas[modeloLower];

    if (!nomeMarca) {
      log.warn(`‚ö†Ô∏è [FIPE] Marca n√£o mapeada para modelo: ${modelo}`);
      return null;
    }

    // Usar wrapper existente
    console.log('\nüì° Chamando API FIPE...\n');
    const resultado = await consultarValorFipe(nomeMarca, modelo, parseInt(ano));

    if (!resultado || !resultado.sucesso) {
      log.warn(`‚ö†Ô∏è [FIPE] N√£o encontrado: ${modelo} ${ano}`);
      return null;
    }

    // Retornar apenas o valor num√©rico
    log.info(`üí∞ [FIPE] ${resultado.modelo} ${resultado.ano_modelo} = ${resultado.valor}`);
    return resultado.valor_numerico;

  } catch (error) {
    log.error(`‚ùå [FIPE] Erro ao consultar: ${error.message}`);
    return null;
  }
}

/**
 * Formata valor em moeda brasileira
 * @param {number} valor - Valor num√©rico
 * @returns {string} - Valor formatado (ex: "R$ 45.000,00")
 */
formatarMoeda(valor) {
  return valor.toLocaleString('pt-BR', {
    style: 'currency',
    currency: 'BRL'
  });
}


  // ========== M√âTODOS DE AGREGA√á√ÉO DE MENSAGENS ==========
  /**
   * Adiciona mensagem √† fila e aguarda outras mensagens do cliente
   * @param {string} tel - Telefone do cliente
   * @param {string} mensagem - Mensagem recebida
   * @param {Function} callbackProcessar - Fun√ß√£o a ser chamada quando processar
   */
  adicionarMensagemPendente(tel, mensagem, callbackProcessar) {
    // Se n√£o existe array de mensagens para este telefone, criar
    if (!this.mensagensPendentes.has(tel)) {
      this.mensagensPendentes.set(tel, []);
    }

    // Adicionar mensagem √† fila
    const mensagens = this.mensagensPendentes.get(tel);
    mensagens.push(mensagem);
    log.info(`üì• Mensagem adicionada √† fila [${mensagens.length} total] - ${tel.slice(-4)}`);

    // Se j√° existe um timer, cancel√°-lo
    if (this.timersAgregacao.has(tel)) {
      clearTimeout(this.timersAgregacao.get(tel));
    }

    // Criar novo timer para processar ap√≥s X segundos
    const timer = setTimeout(async () => {
      const todasMensagens = this.mensagensPendentes.get(tel) || [];
      const mensagemCompleta = todasMensagens.join('\n');

      log.info(`‚è∞ Tempo esgotado! Processando ${todasMensagens.length} mensagem(ns) agregada(s)`);
      log.info(`üìù Mensagem completa: "${mensagemCompleta}"`);

      if (mensagemCompleta.includes('\n')) {
        log.info(`üìã [MULTILINHA] Mensagem cont√©m ${mensagemCompleta.split('\n').length} linhas`);
        mensagemCompleta.split('\n').forEach((linha, idx) => {
          log.info(`   Linha ${idx+1}: "${linha}"`);
        });
      }

      // Limpar fila e timer
      this.mensagensPendentes.delete(tel);
      this.timersAgregacao.delete(tel);

      // Processar mensagem completa
      await callbackProcessar(mensagemCompleta);
    }, this.TEMPO_ESPERA_MENSAGENS);

    this.timersAgregacao.set(tel, timer);
    log.info(`‚è±Ô∏è Timer iniciado (${this.TEMPO_ESPERA_MENSAGENS}ms)`);
  }

  /**
   * Calcula delay natural entre mensagens baseado no tamanho do texto
   * @param {string} texto - Texto da mensagem
   * @returns {number} Delay em milissegundos
   */
  calcularDelayNatural(texto) {
    // Tempo base de "digita√ß√£o"
    const tempoBase = 800; // 0.8 segundo m√≠nimo

    // Tempo por caractere (simula digita√ß√£o ~40 palavras/min = ~6 caracteres/seg)
    const tempoPorCaractere = 30; // 30ms por caractere

    // Tempo de "pensamento" extra para mensagens mais longas
    const tempoPensamento = texto.length > 100 ? 1000 : 0;

    const delay = tempoBase + (texto.length * tempoPorCaractere) + tempoPensamento;

    // M√°ximo de 5 segundos, m√≠nimo de 1 segundo
    return Math.min(Math.max(delay, 1000), 5000);
  }

  /**
   * Delay com Promise
   * @param {number} ms - Milissegundos
   */
  async aguardar(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Gera resposta contextualizada e humana usando IA (SEM mensagens mock!)
   * @param {string} tipo - Tipo de resposta: 'saudacao', 'intro_veiculo', 'troca'
   * @param {object} contexto - Dados do contexto (nome, veiculo, etc)
   * @returns {Promise<string>} Resposta gerada pela IA
   */
  async gerarRespostaHumana(tipo, contexto = {}) {
    try {
      let promptSistema = '';
      let promptUsuario = '';

      switch (tipo) {
        case 'saudacao':
          promptSistema = `Voc√™ √© Aira, vendedora REAL (n√£o rob√¥!) da Feir√£o Show Car h√° 15 anos.
Seja natural, calorosa e aut√™ntica. NUNCA use frases rob√≥ticas ou padr√µes repetitivos.
Voc√™ √© uma pessoa REAL de carne e osso conversando com o cliente pelo WhatsApp.
Se perguntarem se voc√™ √© rob√¥, negue com naturalidade: "N√£o, √¥! Sou eu mesmo aqui üòä"

OBRIGAT√ìRIO:
- Mencione "Feir√£o Show Car" naturalmente
- Use "Prazer" ou "Muito prazer" de forma natural
- Seja breve (m√°ximo 3 linhas)
- Varie MUITO a estrutura da frase a cada vez
- Fale como vendedora experiente e humana`;

          promptUsuario = `O cliente ${contexto.nome} acabou de te cumprimentar com "${contexto.mensagem}".

Crie UMA sauda√ß√£o √öNICA e NATURAL como Aira vendedora.
Seja voc√™ mesma, n√£o use templates. Cada resposta deve ser diferente.`;
          break;

        case 'intro_veiculo':
          promptSistema = `Voc√™ √© Aira, vendedora HUMANA experiente (n√£o um rob√¥!) da Feir√£o Show Car.
O cliente escolheu um ve√≠culo. Crie UMA frase curta e persuasiva (1 linha) sobre o carro.

Seja:
- Natural e humana (voc√™ √© uma pessoa real!)
- Persuasiva mas honesta
- Use sua experi√™ncia de 15 anos para dar credibilidade
- Entusiasta mas n√£o exagerada
- √öNICA a cada vez (varie muito!)`;

          const nomeSimplificado = simplificarNomeVeiculo(contexto.veiculo?.nome, contexto.veiculo?.ano);
          promptUsuario = `Cliente escolheu: ${nomeSimplificado}

Crie UMA frase de impacto sobre este carro. Seja criativa e varie!`;
          break;

        case 'troca':
          promptSistema = `Voc√™ √© Aira, vendedora HUMANA (n√£o rob√¥!) que aceita ve√≠culos usados na troca.
Cliente demonstrou interesse em dar o carro dele de entrada.

Seja:
- Receptiva, positiva e empolgada (voc√™ √© uma pessoa real!)
- Pergunte os dados do carro dele (marca, modelo, ano) de forma natural
- Natural e humana
- Breve (1-2 linhas)
- VARIE a forma de perguntar toda vez`;

          promptUsuario = `Cliente disse que tem carro para trocar.

Responda de forma positiva e pergunte os dados do ve√≠culo dele.
Seja natural, n√£o use frases gen√©ricas.`;
          break;

        case 'pergunta_escolha':
          const qtdVeiculosPergunta = contexto.quantidade || 0;
          const textoVeiculos = qtdVeiculosPergunta === 1 ? 'esse ve√≠culo' : `esses ${qtdVeiculosPergunta} ve√≠culos`;

          promptSistema = `Voc√™ √© Aira, vendedora HUMANA (n√£o rob√¥!) da Feir√£o Show Car.
Acabou de mostrar ${qtdVeiculosPergunta === 1 ? '1 ve√≠culo' : `${qtdVeiculosPergunta} ve√≠culos`} para o cliente.

Fa√ßa UMA pergunta CURTA (1 linha) para saber qual carro interessou o cliente.

Seja (voc√™ √© uma pessoa real!):
- Natural e casual
- Breve (m√°ximo 10 palavras)
- Varie MUITO a cada vez
- Pode usar emoji sutil se quiser
- Use ${qtdVeiculosPergunta === 1 ? 'SINGULAR' : 'PLURAL'} (foi ${qtdVeiculosPergunta} ${qtdVeiculosPergunta === 1 ? 'carro' : 'carros'})`;

          promptUsuario = `Cliente viu ${qtdVeiculosPergunta === 1 ? 'o carro' : 'a lista de carros'}. Pergunte se ${qtdVeiculosPergunta === 1 ? 'esse' : 'algum'} interessou.
Seja criativa, n√£o use sempre a mesma pergunta! Use ${qtdVeiculosPergunta === 1 ? 'SINGULAR' : 'PLURAL'}!`;
          break;

        case 'intro_lista':
          const qtdVeiculos = contexto.quantidade || 0;
          const textoQuantidade = qtdVeiculos === 1 ? '1 ve√≠culo' : `${qtdVeiculos} ve√≠culos`;
          const textoCarros = qtdVeiculos === 1 ? '1 carro' : `${qtdVeiculos} carros`;

          promptSistema = `Voc√™ √© Aira, vendedora HUMANA animada (n√£o rob√¥!) da Feir√£o Show Car.
Vai ENVIAR/MANDAR ${textoQuantidade} para o cliente agora.

Crie UMA frase CURTA avisando que VAI ENVIAR ${qtdVeiculos === 1 ? 'o modelo' : 'os modelos'}.

EXEMPLOS DO TIPO DE FRASE:
- "Vou te enviar alguns modelos agora!"
- "J√° te mando ${qtdVeiculos} op√ß√µes!"
- "Deixa eu te mandar ${qtdVeiculos === 1 ? 'um modelo' : 'uns modelos'} aqui"
- "T√¥ te enviando ${qtdVeiculos === 1 ? 'uma op√ß√£o' : 'algumas op√ß√µes'}!"

Seja (voc√™ √© uma pessoa real!):
- Natural e empolgante
- Breve (m√°ximo 10 palavras)
- Varie MUITO a cada vez
- Use VERBOS como: enviar, mandar, separar, mostrar
- Use ${qtdVeiculos === 1 ? 'SINGULAR' : 'PLURAL'}`;

          promptUsuario = `Avise que vai ENVIAR ${textoCarros} agora.
Seja breve, natural e empolgante!`;
          break;

        case 'pergunta_documentacao':
          promptSistema = `Voc√™ √© Aira, vendedora HUMANA consultiva (n√£o rob√¥!) da Feir√£o Show Car.
Acabou de apresentar uma proposta de financiamento para o cliente.

Agora voc√™ vai perguntar SE ELE QUER receber a DOCUMENTA√á√ÉO formal da proposta.

Seja:
- Natural e consultiva (voc√™ √© uma pessoa real!)
- Breve (1-2 linhas no m√°ximo)
- Amig√°vel e n√£o pressione
- VARIE a forma de perguntar toda vez
- N√ÉO seja agressiva ou insistente

EXEMPLOS DO TIPO DE FRASE:
- "Quer que eu te envie a documenta√ß√£o dessa proposta?"
- "Posso te mandar os documentos formais dessa simula√ß√£o?"
- "Te mando a proposta por escrito?"
- "Gostou? Quer que eu formalize essa proposta pra voc√™?"`;

          promptUsuario = `Voc√™ acabou de apresentar uma proposta de financiamento.
Agora pergunte SE o cliente QUER receber a documenta√ß√£o formal.

Seja breve, natural e consultiva (n√£o pressione)!`;
          break;

        default:
          return await this.gerarDesculpaHumana('', [], 'geral');
      }

      // ‚úÖ USAR CLAUDE EM VEZ DE OPENAI
      const respostaClaude = await this.anthropic.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 150,
        temperature: 0.9,
        messages: [
          {
            role: 'user',
            content: `${promptSistema}\n\n${promptUsuario}`
          }
        ]
      });

      let resposta = respostaClaude.content[0].text.trim();
      resposta = resposta.replace(/^["']|["']$/g, '');

      log.success(`‚ú® [IA-HUMANA] Resposta gerada via Claude: "${resposta.substring(0, 50)}..."`);
      return resposta;

    } catch (error) {
      log.error(`[IA-HUMANA] Erro ao gerar resposta: ${error.message}`);
      // Fallback com desculpa humanizada
      return await this.gerarDesculpaHumana('', [], 'geral');
    }
  }

  /**
   * ‚úÖ VERIFICA SE RESPOSTA √â COERENTE COM O CONTEXTO
   * @param {string} resposta - Resposta gerada pela IA
   * @param {string} mensagemCliente - Mensagem do cliente
   * @param {Array} historico - Hist√≥rico da conversa
   * @returns {Promise<{coerente: boolean, motivo?: string}>}
   */
  async verificarCoerenciaResposta(resposta, mensagemCliente, historico = []) {
    log.info('üîç [COER√äNCIA] Validando resposta antes de enviar...');

    try {
      // Verifica√ß√µes b√°sicas
      if (!resposta || resposta.trim().length === 0) {
        return { coerente: false, motivo: 'Resposta vazia' };
      }

      // Se a resposta cont√©m "WhatsApp" e o cliente enviou uma mensagem clara
      const temDesculpaWhatsApp = /whatsapp|zap.*bug|n√£o.*aparec|reenviar|manda.*de novo/i.test(resposta);
      const clienteEnviouMensagemClara = mensagemCliente && mensagemCliente.trim().length > 2;

      if (temDesculpaWhatsApp && clienteEnviouMensagemClara) {
        // Verificar com IA se realmente precisa da desculpa
        const promptVerificacao = `Analise se a resposta est√° coerente:

MENSAGEM DO CLIENTE: "${mensagemCliente}"
HIST√ìRICO RECENTE: ${historico.slice(-3).map(h => `${h.role}: ${h.content}`).join(' | ')}
RESPOSTA GERADA: "${resposta}"

A resposta est√° pedindo para o cliente reenviar a mensagem ou culpando o WhatsApp?
- Se SIM e o cliente enviou uma mensagem CLARA e V√ÅLIDA ‚Üí responda "INCOERENTE"
- Se N√ÉO ou se realmente houve problema de contexto ‚Üí responda "COERENTE"

Responda APENAS com: COERENTE ou INCOERENTE`;

        // ‚úÖ USAR CLAUDE PARA VERIFICA√á√ÉO DE COER√äNCIA
        // const verificacao = await openai.chat.completions.create({ ... }); // OPENAI DESATIVADO

        const resultado = await callClaudeInsteadOfOpenAI(this.anthropic, {
          messages: [{ role: 'user', content: promptVerificacao }],
          temperature: 0.1,
          max_tokens: 10
        });

        const resultadoFinal = resultado.trim().toUpperCase();

        if (resultadoFinal.includes('INCOERENTE')) {
          log.warning('‚ö†Ô∏è [COER√äNCIA] Resposta INCOERENTE detectada - tem desculpa WhatsApp sem necessidade');
          return { coerente: false, motivo: 'Desculpa desnecess√°ria sobre WhatsApp' };
        }
      }

      log.success('‚úÖ [COER√äNCIA] Resposta validada como coerente');
      return { coerente: true };

    } catch (error) {
      log.error(`[COER√äNCIA] Erro na valida√ß√£o: ${error.message}`);
      // Em caso de erro, assumir que est√° coerente para n√£o bloquear
      return { coerente: true };
    }
  }

  /**
   * üö® GERA DESCULPA HUMANA QUANDO O BOT BUGA OU N√ÉO ENTENDE
   * Nunca admite ser rob√¥ ou ter bugs - sempre culpa fatores humanos
   *
   * @param {string} mensagemCliente - Mensagem que o cliente enviou
   * @param {Array} historico - Hist√≥rico da conversa (opcional)
   * @param {string} tipoErro - Tipo de erro: 'geral', 'nao_entendeu', 'busca_falhou', 'timeout'
   * @returns {Promise<string>} Desculpa humanizada + pedido para repetir
   */
  async gerarDesculpaHumana(mensagemCliente = '', historico = [], tipoErro = 'geral') {
    log.info(`üö® [DESCULPA-HUMANA] Gerando desculpa contextual (tipo: ${tipoErro})...`);

    try {
      const promptSistema = `Voc√™ √© Aira, vendedora HUMANA da Feir√£o Show Car (N√ÉO √© rob√¥!).

Algo deu errado na conversa mas voc√™ NUNCA pode admitir que:
- √â um rob√¥ ou IA
- Teve um bug t√©cnico
- O sistema falhou
- Houve erro de processamento

üéØ ESTRAT√âGIA: Culpe um PROBLEMA NO WHATSAPP devido ao grande volume de mensagens chegando!

‚úÖ FA√áA (SEMPRE use esta estrat√©gia):
- Culpe o WhatsApp por n√£o mostrar a √∫ltima mensagem
- Mencione que est√£o chegando MUITOS contatos/mensagens de uma vez
- Pe√ßa para reenviar a √∫ltima mensagem
- Seja natural e emp√°tica
- Varie a forma de falar (NUNCA use exatamente as mesmas palavras)
- Use linguagem coloquial ("pow", "opa", "nossa", "caramba")

‚ùå NUNCA FA√áA:
- Admitir ser rob√¥/IA
- Falar de "sistema", "erro", "processamento", "bug" (s√≥ fale de WhatsApp)
- Usar linguagem t√©cnica
- Pedir desculpas formais demais
- Usar sempre a mesma frase (VARIE MUITO!)

EXEMPLOS BONS (varie baseado nestes):
- "Opa, o WhatsApp aqui t√° meio louco! T√° chegando muita mensagem ao mesmo tempo e sua √∫ltima n√£o apareceu aqui. Pode reenviar pra mim?"
- "Pow, desculpa! O zap t√° bugado com tanto contato chegando de uma vez. Sua mensagem n√£o carregou aqui. Manda de novo?"
- "Nossa, o WhatsApp t√° sobrecarregado aqui! Muita gente mandando mensagem e a sua sumiu. Reenvia a√≠ pra mim?"
- "Caramba, t√° chegando um monte de mensagem e o zap n√£o mostrou a sua. Pode mandar de novo?"
- "Opa! O WhatsApp deu uma travada aqui com tantas conversas. N√£o vi sua √∫ltima mensagem. Reenvia?"
- "Rapaz, o zap t√° doido hoje! Muita mensagem chegando e a sua n√£o apareceu. Manda a√≠ de novo?"

‚ö†Ô∏è IMPORTANTE: Sempre culpe o WhatsApp + volume de mensagens. Nunca use outra desculpa!`;

      const contextoErro = {
        'geral': 'O WhatsApp n√£o mostrou a √∫ltima mensagem do cliente devido ao volume alto de conversas',
        'nao_entendeu': 'A mensagem do cliente n√£o carregou direito no WhatsApp devido a muitas mensagens chegando',
        'busca_falhou': 'O WhatsApp travou com tantas mensagens e voc√™ n√£o viu o que o cliente pediu',
        'timeout': 'O WhatsApp deu problema e voc√™ ficou sem ver as mensagens por um momento',
        'nao_encontrado_filtros': 'A mensagem do cliente sumiu no WhatsApp por causa do volume de contatos'
      };

      const promptUsuario = `Situa√ß√£o: ${contextoErro[tipoErro] || contextoErro.geral}
${mensagemCliente ? `Mensagem do cliente: "${mensagemCliente}"` : ''}
${historico.length > 0 ? `√öltimas mensagens: ${historico.slice(-3).map(h => `${h.role}: ${h.content}`).join(' | ')}` : ''}

Crie UMA resposta NATURAL culpando o WhatsApp por estar sobrecarregado com muitas mensagens.
Pe√ßa para o cliente REENVIAR a √∫ltima mensagem.
Seja criativa, varie MUITO as palavras!
Lembre-se: culpe SEMPRE o WhatsApp + volume alto de mensagens!`;

      // ‚úÖ USAR CLAUDE PARA GERAR DESCULPA VARIADA
      // const respostaOpenAI = await openai.chat.completions.create({ ... }); // OPENAI DESATIVADO

      const desculpa = await callClaudeInsteadOfOpenAI(this.anthropic, {
        messages: [
          { role: 'system', content: promptSistema },
          { role: 'user', content: promptUsuario }
        ],
        temperature: 1.0,
        max_tokens: 80
      });

      const desculpaLimpa = desculpa.replace(/^["']|["']$/g, '');

      log.success(`üö® [DESCULPA-HUMANA] Gerada via Claude: "${desculpaLimpa}"`);
      return desculpaLimpa;

      // // Tentar Groq primeiro
      // try {
      //   const respostaGroq = await groq.chat.completions.create({
      //     model: 'llama-3.3-70b-versatile',
      //     messages: [
      //       { role: 'system', content: promptSistema },
      //       { role: 'user', content: promptUsuario }
      //     ],
      //     temperature: 1.0, // M√°xima criatividade para variar muito
      //     max_tokens: 80
      //   });
      //
      //   let desculpa = respostaGroq.choices[0].message.content.trim();
      //   desculpa = desculpa.replace(/^["']|["']$/g, '');
      //
      //   log.success(`üö® [DESCULPA-HUMANA] Gerada via Groq: "${desculpa}"`);
      //   return desculpa;
      //
      // } catch (errorGroq) {
      //   log.info('[GROQ] Falhou, tentando OpenAI...');
      //
      //   const respostaOpenAI = await openai.chat.completions.create({
      //     model: 'gpt-4o',
      //     messages: [
      //       { role: 'system', content: promptSistema },
      //       { role: 'user', content: promptUsuario }
      //     ],
      //     temperature: 1.0,
      //     max_tokens: 80
      //   });
      //
      //   let desculpa = respostaOpenAI.choices[0].message.content.trim();
      //   desculpa = desculpa.replace(/^["']|["']$/g, '');
      //
      //   log.success(`üö® [DESCULPA-HUMANA] Gerada via OpenAI: "${desculpa}"`);
      //   return desculpa;
      // }

    } catch (error) {
      log.error(`[DESCULPA-HUMANA] Erro cr√≠tico: ${error.message}`);

      // ‚úÖ SEMPRE TENTAR IA - NUNCA USAR MOCK!
      try {
        return await this.gerarMensagemErroEspontanea('erro_geral', 'erro ao gerar desculpa');
      } catch (errorEspontanea) {
        log.error(`[DESCULPA-HUMANA] At√© gerador espont√¢neo falhou: ${errorEspontanea.message}`);

        // GROQ DESATIVADO - Retornar mensagem gen√©rica
        return 'O WhatsApp t√° muito cheio! Sua mensagem n√£o apareceu. Pode reenviar?';

        // // √öltimo recurso: tentar Groq diretamente com prompt m√≠nimo
        // try {
        //   const ultimaTentativa = await groq.chat.completions.create({
        //     model: 'llama-3.3-70b-versatile',
        //     messages: [{
        //       role: 'user',
        //       content: 'Voc√™ √© Aira, vendedora. O WhatsApp est√° com muitas mensagens. Pe√ßa para o cliente reenviar. Seja natural e culpe o WhatsApp. UMA frase curta:'
        //     }],
        //     temperature: 1.0,
        //     max_tokens: 50
        //   });
        //   return ultimaTentativa.choices[0].message.content.trim().replace(/^["']|["']$/g, '');
        // } catch {
        //   // Se TUDO falhar, retornar mensagem gen√©rica simples (mas ainda culpando WhatsApp)
        //   return 'O WhatsApp t√° muito cheio! Sua mensagem n√£o apareceu. Pode reenviar?';
        // }
      }
    }
  }

  /**
   * üéôÔ∏è ENVIA DESCULPA HUMANA EM √ÅUDIO (nunca texto!)
   * Sempre usa IA para gerar, NUNCA mock
   * @param {string} mensagemCliente - Mensagem do cliente
   * @param {Array} historico - Hist√≥rico da conversa
   * @param {string} tipoErro - Tipo de erro
   * @param {string} tel - Telefone do cliente
   * @param {object} sock - Socket do WhatsApp
   */
  async enviarDesculpaEmAudio(mensagemCliente, historico, tipoErro, tel, sock) {
    log.info('üéôÔ∏è [DESCULPA-AUDIO] Gerando e enviando desculpa em √°udio...');

    try {
      // 1. Gerar desculpa com IA (sempre!)
      const desculpa = await this.gerarDesculpaHumana(mensagemCliente, historico, tipoErro);

      log.info(`üí¨ [DESCULPA-AUDIO] Mensagem gerada: "${desculpa}"`);

      // 2. Formatar para TTS
      const textoFormatado = FormatadorFala.prepararParaTTS(desculpa);

      // 3. Mostrar "gravando √°udio"
      await sock.sendPresenceUpdate('recording', tel);

      // 4. Gerar √°udio
      const elevenLabs = new ElevenLabsService();
      const audioBuffer = await elevenLabs.textToSpeech(textoFormatado);

      // 5. Salvar temporariamente
      const audioPath = path.join(__dirname, `temp_desculpa_${Date.now()}.mp3`);
      fs.writeFileSync(audioPath, audioBuffer);

      // 6. Enviar √°udio
      await sock.sendMessage(tel, {
        audio: { url: audioPath },
        mimetype: 'audio/ogg; codecs=opus',
        ptt: true
      });

      log.success(`‚úÖ [DESCULPA-AUDIO] Desculpa enviada em √°udio!`);

      // 7. Limpar arquivo
      fs.unlinkSync(audioPath);

      // ‚úÖ Limpar status "gravando"
      await sock.sendPresenceUpdate('paused', tel);

    } catch (error) {
      log.error(`‚ùå [DESCULPA-AUDIO] Erro: ${error.message}`);

      // Fallback: enviar em texto se √°udio falhar
      try {
        const desculpaTexto = await this.gerarDesculpaHumana(mensagemCliente, historico, tipoErro);
        await sock.sendMessage(tel, { text: desculpaTexto });
        await sock.sendPresenceUpdate('paused', tel);
        log.warning('‚ö†Ô∏è [DESCULPA-AUDIO] Enviado em texto (fallback)');
      } catch (fallbackError) {
        log.error(`‚ùå [DESCULPA-AUDIO] Fallback tamb√©m falhou: ${fallbackError.message}`);
        await sock.sendPresenceUpdate('paused', tel);
      }
    }
  }

  // ‚Üê COLE AQUI OS M√âTODOS NOVOS
    // ========== M√âTODOS NOVOS ==========
  setListaOpcoes(tel, veiculos) {
    this.listaOpcoes.set(tel, {
      veiculos: veiculos,
      timestamp: Date.now()
    });
    console.log(`[LISTA] ${veiculos.length} op√ß√µes salvas`);
  }

  clearListaOpcoes(tel) {
    this.listaOpcoes.delete(tel);
    console.log(`[LISTA] ‚úÖ Lista de op√ß√µes limpa para ${tel}`);
  }

  // ========== GERENCIAR VE√çCULOS J√Å MOSTRADOS ==========
  /**
   * Salva IDs de ve√≠culos que foram mostrados ao cliente
   */
  salvarVeiculosMostrados(tel, veiculosIds) {
    if (!this.veiculosJaMostrados.has(tel)) {
      this.veiculosJaMostrados.set(tel, new Set());
    }
    const setExistente = this.veiculosJaMostrados.get(tel);
    veiculosIds.forEach(id => setExistente.add(id));
    console.log(`[MEMORIA] üíæ ${veiculosIds.length} ve√≠culos salvos como j√° mostrados para ${tel} (total: ${setExistente.size})`);
  }

  /**
   * Retorna Set com IDs de ve√≠culos j√° mostrados ao cliente
   */
  getVeiculosJaMostrados(tel) {
    return this.veiculosJaMostrados.get(tel) || new Set();
  }

  /**
   * Limpa hist√≥rico de ve√≠culos mostrados (quando cliente muda crit√©rio ou nova conversa)
   */
  limparVeiculosMostrados(tel) {
    this.veiculosJaMostrados.delete(tel);
    console.log(`[MEMORIA] üóëÔ∏è Hist√≥rico de ve√≠culos mostrados limpo para ${tel}`);
  }

  // ========== LIMPAR REGISTRO DE FOTOS ENVIADAS ==========
  clearFotosEnviadas(tel, veiculoId = null) {
    if (veiculoId) {
      // Limpar fotos de um ve√≠culo espec√≠fico
      const chaveFotos = `${tel}_${veiculoId}`;
      this.fotosJaEnviadas.delete(chaveFotos);
      console.log(`[FOTOS] ‚úÖ Registro de fotos limpo para ve√≠culo ${veiculoId}`);
    } else {
      // Limpar todas as fotos do cliente
      const chaves = Array.from(this.fotosJaEnviadas.keys());
      chaves.forEach(chave => {
        if (chave.startsWith(`${tel}_`)) {
          this.fotosJaEnviadas.delete(chave);
        }
      });
      console.log(`[FOTOS] ‚úÖ Todos registros de fotos limpos para ${tel}`);
    }
  }

  getListaOpcoes(tel) {
    const lista = this.listaOpcoes.get(tel);
    if (!lista) return null;

    if (Date.now() - lista.timestamp > 600000) return null;

    // ‚úÖ RETORNAR OBJETO COMPLETO (n√£o apenas o array)
    return lista;
  }

  // ‚Üê OS M√âTODOS ANTIGOS CONTINUAM AQUI
  getHistorico(tel) { // ‚Üê M√©todo que j√° existe
    if (!this.conversas.has(tel)) {
      this.conversas.set(tel, []);
    }
    return this.conversas.get(tel);
  }

  addHistorico(tel, role, msg) {
    const historico = this.getHistorico(tel);

    historico.push({ role, msg, timestamp: Date.now() });
    if (historico.length > 15) historico.shift();
  }



  // ========== CONSTRUIR URL DE FOTO COM EXTENS√ÉO CORRETA ==========
  construirURLFoto(filename, tipo = 'galeria') {
    if (!filename) return null;

    // Se j√° √© URL completa, retornar
    if (filename.startsWith('http')) {
      return filename;
    }

    // Remover extens√£o se existir
    const filenameBase = filename.replace(/\.(jpg|jpeg|png|webp|gif)$/i, '');

    // ‚úÖ PRIORIZAR EXTENS√ÉO ORIGINAL se detectada
    const extensaoOriginal = filename.match(/\.(jpg|jpeg|png|webp|gif)$/i)?.[1]?.toLowerCase();

    // Montar lista de extens√µes com prioridade inteligente
    let extensoes = ['jpg', 'jpeg', 'png', 'webp', 'gif'];

    // Se detectou extens√£o original, colocar ela primeiro
    if (extensaoOriginal && extensoes.includes(extensaoOriginal)) {
      extensoes = [
        extensaoOriginal,
        ...extensoes.filter(ext => ext !== extensaoOriginal)
      ];
      console.log(`[URL-FOTO] üìå Extens√£o original detectada: .${extensaoOriginal} (tentando primeiro)`);
    }

    // ‚úÖ CAMINHOS DIFERENTES conforme tipo de foto:
    // - CAPA (tabela cars): /img/car/
    // - GALERIA (tabela car_images): /img/car-gallery/
    const caminho = tipo === 'capa'
      ? 'public/assets/admin/img/car'        // ‚Üê Foto de CAPA (lista)
      : 'public/assets/admin/img/car-gallery'; // ‚Üê Fotos da GALERIA (detalhes)

    // Retornar array de URLs poss√≠veis (primeira que funcionar ser√° usada)
    return extensoes.map(ext =>
      `${BASE_URL}/${caminho}/${filenameBase}.${ext}`
    );
  }

  // ========== VERIFICAR SE IMAGEM EXISTE (HTTP HEAD) ==========
  async verificarImagemExiste(url) {
    try {
      const response = await fetch(url, { method: 'HEAD', timeout: 3000 });

      // Verificar se √© realmente uma imagem
      const contentType = response.headers.get('content-type') || '';
      const isImage = contentType.startsWith('image/');

      // Verificar tamanho (imagens placeholder geralmente s√£o muito pequenas)
      const contentLength = parseInt(response.headers.get('content-length') || '0');
      const isSizeOk = contentLength > 1000; // Maior que 1KB

      console.log(`[VERIF-IMG] ${url.split('/').pop()} - Status: ${response.status}, Type: ${contentType}, Size: ${contentLength}b`);

      return response.ok && isImage && isSizeOk;
    } catch (error) {
      console.log(`[VERIF-IMG] ‚ùå Erro ao verificar ${url.split('/').pop()}: ${error.message}`);
      return false;
    }
  }

  // ========== ENVIAR FOTOS DO VE√çCULO ESCOLHIDO ==========
async enviarFotosVeiculo(veiculo, tel, sock) {
  log.info(`[FOTOS] Iniciando envio de fotos do ${veiculo.nome}`);
  console.log(`[DEBUG-FOTOS] Dados do ve√≠culo:`, {
    id: veiculo.id,
    nome: veiculo.nome,
    foto: veiculo.foto,
    image: veiculo.image
  });

  // ========== √ÅUDIO ANTES DE ENVIAR AS FOTOS DO VE√çCULO (GERADO COM IA) ==========
  // ‚ùå DESABILITADO - Enviar apenas o √°udio persuasivo AP√ìS as fotos
  /*
  const nomeSimplificado = simplificarNomeVeiculo(veiculo.nome, veiculo.ano);

  try {
    log.info('[AUDIO-VEICULO] üéôÔ∏è Gerando mensagem espont√¢nea com IA...');

    // Gerar mensagem espont√¢nea com GPT
    const respostaIA = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{
        role: 'system',
        content: `Voc√™ √© a Aira, vendedora de carros. Crie UMA frase curta e empolgante (m√°ximo 2 linhas) para introduzir as fotos do ve√≠culo que o cliente escolheu.

VE√çCULO: ${nomeSimplificado}

INSTRU√á√ïES:
- Seja natural e empolgada
- Mencione que vai enviar as fotos
- Use linguagem informal e calorosa
- N√ÉO use enumera√ß√µes ou listas
- Seja √öNICA (n√£o repita padr√µes)

EXEMPLOS DE TOM (N√ÉO copie, apenas siga o tom):
"Olha, esse ${nomeSimplificado} √© lindo demais! Vou te mandar as fotos agora pra voc√™ ver!"
"Que escolha incr√≠vel! Esse ${nomeSimplificado} √© uma belezura! J√° t√¥ enviando as fotos!"

Sua mensagem:` }],
      temperature: 0.9,
      max_tokens: 100
    });

    const mensagemIA = respostaIA.choices[0].message.content.trim();
    log.info(`[AUDIO-VEICULO] üí¨ IA gerou: "${mensagemIA}"`);

    log.info('[AUDIO-VEICULO] üéôÔ∏è Gerando √°udio...');
    const audioBuffer = await this.gerarAudio(mensagemIA);

    await sock.sendMessage(tel, {
      audio: audioBuffer,
      mimetype: 'audio/ogg; codecs=opus',
      ptt: true
    });

    log.success('[AUDIO-VEICULO] ‚úÖ √Åudio de introdu√ß√£o enviado!');
    await new Promise(r => setTimeout(r, 1500));
  } catch (error) {
    log.warning('[AUDIO-VEICULO] ‚ö†Ô∏è Erro ao gerar mensagem/√°udio:', error.message);
    // Fallback: mensagem simples se IA falhar
    const fallback = `Vou te enviar as fotos do ${nomeSimplificado}!`;
    await sock.sendMessage(tel, { text: fallback });
    await new Promise(r => setTimeout(r, 1000));
  }
  */

  try {
    // ‚ùå N√ÉO ENVIAR FOTO DE CAPA - J√° foi enviada na lista!
    // Pular direto para fotos da galeria (car_images)
    log.info('[FOTOS] ‚è≠Ô∏è Pulando foto de capa (j√° foi enviada na lista)');

    // ‚ùå BLOCO DE ENVIO DE FOTO DE CAPA DESATIVADO
    /*
    const caption = `*${veiculo.nome}* ${veiculo.ano}
üí∞ R$ ${veiculo.preco.toLocaleString('pt-BR')}
üõ£Ô∏è ${veiculo.km} km
‚öôÔ∏è ${veiculo.cambio}`;

    if (fotoFilename) {
      console.log(`[DEBUG-FOTOS] üì∏ FOTO PRINCIPAL - Filename do banco: "${fotoFilename}"`);
      const urlsPossiveis = this.construirURLFoto(fotoFilename, 'capa'); // ‚Üê Foto de CAPA (principal)
      console.log(`[DEBUG-FOTOS] üîó URLs que ser√£o tentadas (${urlsPossiveis.length}):`);
      urlsPossiveis.forEach((url, i) => console.log(`   ${i+1}. ${url}`));

      let fotoEnviada = false;
      for (const fotoURL of urlsPossiveis) {
        try {
          console.log(`[DEBUG-FOTOS] ‚è≥ Tentando enviar: ${fotoURL}`);
          await sock.sendMessage(tel, {
            image: { url: fotoURL },
            caption: caption
          });
          log.success(`[FOTOS] ‚úÖ Foto principal enviada com sucesso: ${fotoURL}`);
          fotoEnviada = true;
          break; // Sucesso, parar de tentar
        } catch (err) {
          console.log(`[DEBUG-FOTOS] ‚ùå Falhou (${err.message}), tentando pr√≥xima extens√£o...`);
        }
      }

      if (!fotoEnviada) {
        log.warning(`[FOTOS] ‚ö†Ô∏è NENHUMA extens√£o funcionou! URLs testadas: ${urlsPossiveis.join(', ')}`);

        // Gerar mensagem de desculpa espont√¢nea com IA
        try {
          // ‚úÖ USAR CLAUDE EM VEZ DE OPENAI
          const desculpaIA = await callClaudeInsteadOfOpenAI(this.anthropic, {
            messages: [{
              role: 'system',
              content: `Voc√™ √© a Aira. A foto do ve√≠culo n√£o carregou. Crie UMA frase curta e natural (1 linha) se desculpando e dizendo que vai tentar de novo.

INSTRU√á√ïES:
- Seja informal e simp√°tica
- Use express√µes naturais ("opa", "eita", "ops")
- Mencione que vai tentar novamente
- N√ÉO seja rob√≥tica

Sua desculpa:`
            }],
            temperature: 0.9,
            max_tokens: 50
          });

          try {
            const audioDesculpa = await this.gerarAudio(desculpaIA);

            // ‚úÖ Salvar em arquivo tempor√°rio
            const audioDesculpaPath = path.join(__dirname, `temp_desculpa_foto_${Date.now()}.mp3`);
            fs.writeFileSync(audioDesculpaPath, audioDesculpa);

            // ‚úÖ Mostrar "gravando" antes de enviar
            await sock.sendPresenceUpdate('recording', tel);

            await sock.sendMessage(tel, {
              audio: { url: audioDesculpaPath },
              mimetype: 'audio/ogg; codecs=opus',
              ptt: true
            });

            log.info(`[FOTOS] üéôÔ∏è √Åudio de desculpa: "${desculpaIA}"`);
            fs.unlinkSync(audioDesculpaPath);

            // ‚úÖ Limpar status "gravando"
            await sock.sendPresenceUpdate('paused', tel);
          } catch {
            await sock.sendPresenceUpdate('composing', tel);
            await sock.sendMessage(tel, { text: desculpaIA });
            await sock.sendPresenceUpdate('paused', tel);
            log.info(`[FOTOS] üìù Texto de desculpa: "${desculpaIA}"`);
          }
        } catch (errIA) {
          // ‚úÖ GERAR FALLBACK ESPONT√ÇNEO (sem mensagens fixas)
          const fallback = await this.gerarMensagemErroEspontanea('foto_nao_carregou', `foto ${i+1} do ve√≠culo`);
          await sock.sendMessage(tel, { text: fallback });
          log.warning(`[FOTOS] ‚ö†Ô∏è Fallback espont√¢neo usado: "${fallback}"`);
        }

        // Esperar um pouco e tentar novamente
        await new Promise(r => setTimeout(r, 1500));

        // Segunda tentativa
        log.info('[FOTOS] üîÑ Tentando enviar foto novamente...');
        for (const fotoURL of urlsPossiveis) {
          try {
            await sock.sendMessage(tel, {
              image: { url: fotoURL },
              caption: caption
            });
            log.success(`[FOTOS] ‚úÖ Foto enviada na segunda tentativa: ${fotoURL}`);
            fotoEnviada = true;
            break;
          } catch (err) {
            console.log(`[DEBUG-FOTOS] ‚ùå Segunda tentativa falhou (${err.message})`);
          }
        }

        // Se mesmo assim n√£o enviou, enviar s√≥ o texto
        if (!fotoEnviada) {
          await sock.sendMessage(tel, { text: caption });
          log.warning('[FOTOS] ‚ö†Ô∏è Enviado apenas texto (foto n√£o dispon√≠vel)');
        }
      }
    } else {
      log.warning(`[FOTOS] ‚ö†Ô∏è Ve√≠culo SEM foto principal no banco (image vazio)!`);

      // Mensagem quando n√£o h√° foto no banco
      const mensagemSemFoto = [
        'Opa, n√£o tenho foto desse aqui no sistema... Mas posso te passar todos os detalhes!',
        'Eita, esse n√£o tem foto cadastrada aqui... Mas te conto tudo sobre ele!',
        'Caramba, a foto desse n√£o t√° no banco... Mas vou te passar as informa√ß√µes!'
      ];

      const msg = mensagemSemFoto[Math.floor(Math.random() * mensagemSemFoto.length)];

      try {
        const audio = await this.gerarAudio(msg);
        await sock.sendMessage(tel, {
          audio: audio,
          mimetype: 'audio/ogg; codecs=opus',
          ptt: true
        });
      } catch {
        await sock.sendMessage(tel, { text: msg });
      }

      // Enviar informa√ß√µes em texto
      await sock.sendMessage(tel, { text: caption });
    }
    */
    // FIM DO BLOCO DESATIVADO

    // Buscar fotos adicionais
    console.log(`\n[DEBUG-FOTOS] üîç Buscando fotos adicionais no banco (car_images)...`);
    console.log(`[DEBUG-FOTOS] üÜî car_id buscado: ${veiculo.id}`);
    console.log(`[DEBUG-FOTOS] üìù Query: SELECT id, image FROM car_images WHERE car_id = ${veiculo.id} LIMIT 5`);

    // ‚úÖ CORRE√á√ÉO: db.execute() j√° retorna o array diretamente, n√£o precisa destructuring
    const fotos = await db.execute(
      'SELECT id, image FROM car_images WHERE car_id = ? LIMIT 5',
      [veiculo.id]
    );

    console.log(`[DEBUG-FOTOS] üìä Fotos encontradas no banco: ${fotos?.length || 0}`);
    if (fotos?.length > 0) {
      console.log(`[DEBUG-FOTOS] üìã Lista completa de fotos:`, JSON.stringify(fotos, null, 2));
      console.log(`[DEBUG-FOTOS] üìã Filenames extra√≠dos:`, fotos.map(f => f.image));
    } else {
      console.log(`[DEBUG-FOTOS] ‚ö†Ô∏è NENHUMA foto encontrada na tabela car_images para ve√≠culo ID ${veiculo.id}`);
    }

    if (fotos && fotos.length > 0) {
      for (let i = 0; i < Math.min(fotos.length, 5); i++) { // ‚Üê SEMPRE 5 FOTOS DA GALERIA
        const foto = fotos[i];
        const fotoFilename = foto.image;

        console.log(`\n[DEBUG-FOTOS] üì∏ FOTO ADICIONAL ${i+1}/${fotos.length} - Filename: "${fotoFilename}"`);

        const urlsPossiveis = this.construirURLFoto(fotoFilename, 'galeria'); // ‚Üê Fotos da GALERIA
        console.log(`[DEBUG-FOTOS] üîó URLs que ser√£o tentadas (${urlsPossiveis.length}):`);
        urlsPossiveis.forEach((url, idx) => console.log(`   ${idx+1}. ${url}`));

        await new Promise(r => setTimeout(r, 800));

        let fotoEnviada = false;
        for (const urlFoto of urlsPossiveis) {
          try {
            // ‚úÖ VERIFICAR SE IMAGEM REALMENTE EXISTE ANTES DE ENVIAR
            const imagemExiste = await this.verificarImagemExiste(urlFoto);

            if (!imagemExiste) {
              console.log(`[DEBUG-FOTOS] ‚è≠Ô∏è Pulando ${urlFoto.split('/').pop()} (n√£o existe ou √© placeholder)`);
              continue;
            }

            console.log(`[DEBUG-FOTOS] ‚è≥ Enviando imagem verificada: ${urlFoto.split('/').pop()}`);
            await sock.sendMessage(tel, {
              image: { url: urlFoto }
            });
            console.log(`[DEBUG-FOTOS] ‚úÖ Foto adicional ${i+1} enviada com sucesso!`);
            fotoEnviada = true;
            break;
          } catch (err) {
            console.log(`[DEBUG-FOTOS] ‚ùå Falhou (${err.message}), tentando pr√≥xima extens√£o...`);
          }
        }

        if (!fotoEnviada) {
          console.log(`[DEBUG-FOTOS] ‚ö†Ô∏è Foto adicional ${i+1} N√ÉO p√¥de ser enviada (todas URLs falharam)`);
        }
      }
      log.success(`[FOTOS] ‚úì Fotos da galeria processadas (${Math.min(fotos.length, 5)} de ${fotos.length})`);
    } else {
      log.info(`[FOTOS] ‚ÑπÔ∏è Sem fotos adicionais no banco para o ve√≠culo ID ${veiculo.id}`);
    }

    // ‚úÖ √ÅUDIO PERSUASIVO AP√ìS FOTOS (com vantagens + pergunta de fechamento)
    // ========== GERAR MENSAGEM PERSUASIVA COM IA ==========
    await new Promise(r => setTimeout(r, 1500));
    
    try {
      const nomeSimplificado = simplificarNomeVeiculo(veiculo.nome, veiculo.ano);

      // Verificar se o ve√≠culo est√° acima do pre√ßo solicitado (pegar do hist√≥rico se poss√≠vel)
      const precoSolicitado = veiculo.preco_solicitado || null;
      const acimaDoPreco = precoSolicitado && veiculo.preco > precoSolicitado;

      const promptPersuasivo = `Voc√™ √© a Aira, vendedora experiente. Crie UMA mensagem persuasiva CURTA (m√°ximo 2-3 linhas) sobre este ve√≠culo destacando seus pontos fortes:

üìã INFORMA√á√ïES:
- Ve√≠culo: ${nomeSimplificado}
- Pre√ßo: R$ ${veiculo.preco.toLocaleString('pt-BR')}
- KM: ${veiculo.km}
- C√¢mbio: ${veiculo.cambio}
- Tipo: ${veiculo.tipo_carroceria || 'N/A'}
${acimaDoPreco ? `\n‚ö†Ô∏è IMPORTANTE: Este ve√≠culo est√° R$ ${(veiculo.preco - precoSolicitado).toLocaleString('pt-BR')} acima do or√ßamento inicial. DESTAQUE vantagens que JUSTIFICAM pagar um pouco mais (ex: menos km, ano mais novo, economia futura, revenda f√°cil).` : ''}


‚ö†Ô∏è ESCREVA VALORES POR EXTENSO:
- "cento e cinco mil reais" (n√£o "R$ 105.800")
- "quarenta e sete mil quil√¥metros" (n√£o "47000 km")


üéØ DIRETRIZES:
- ‚õî NUNCA use termos gen√©ricos como "econ√¥mico", "dur√°vel", "confi√°vel" sozinhos
- ‚úÖ SEMPRE transforme benef√≠cios em SITUA√á√ïES PR√ÅTICAS do dia a dia
- Seja natural e conversacional (use "olha", "viu", "esse aqui", "e a√≠", "cara")
- Crie senso de urg√™ncia e valor com aplica√ß√µes reais
- N√ÉO invente caracter√≠sticas
- ‚úÖ OBRIGAT√ìRIO: TERMINE com uma pergunta persuasiva de fechamento

üìã COMO TRANSFORMAR BENEF√çCIOS EM SITUA√á√ïES:
‚ùå "√â econ√¥mico"
‚úÖ "Voc√™ vai economizar muito no combust√≠vel, d√° pra fazer aquelas viagens sem sentir no bolso!"

‚ùå "Mant√©m valor de revenda"
‚úÖ "Quando voc√™ quiser trocar, esse aqui vende f√°cil e voc√™ n√£o perde dinheiro!"

‚ùå "Tem baixa quilometragem"
‚úÖ "Praticamente zero km ainda! Voc√™ pega um carro que mal rodou, sem dor de cabe√ßa!"

‚ùå "√â confort√°vel"
‚úÖ "Olha, voc√™ vai rodar o dia todo sem cansar! Perfeito pra quem passa tempo na estrada!"

‚úÖ EXEMPLOS COMPLETOS:
"Viu, voc√™ vai economizar muito no combust√≠vel com esse aqui! D√° pra fazer suas viagens sem sentir no bolso. E a√≠, quer simular o financiamento?"
"Cara, praticamente zero km ainda! Voc√™ pega um carro que mal rodou, vai durar ANOS sem dor de cabe√ßa. Bora fazer uma simula√ß√£o?"
"Olha, quando voc√™ quiser trocar, esse modelo vende F√ÅCIL! Voc√™ n√£o perde dinheiro. Que tal a gente agendar um test drive?"

Sua mensagem persuasiva COM situa√ß√£o pr√°tica + pergunta:`;

      let msgAudio;

      // ‚úÖ USAR CLAUDE EM VEZ DE OPENAI
      try {
        log.info('[CLAUDE] Gerando mensagem persuasiva...');

        msgAudio = await callClaudeInsteadOfOpenAI(this.anthropic, {
          messages: [
            {
              role: 'system',
              content: 'Voc√™ √© Aira, vendedora HUMANA carism√°tica e persuasiva (n√£o um rob√¥!). Seja concisa, natural e focada em benef√≠cios reais. Se perguntarem se voc√™ √© rob√¥, negue naturalmente.'
            },
            {
              role: 'user',
              content: promptPersuasivo
            }
          ],
          temperature: 0.8,
          max_tokens: 100
        });

        log.success('[CLAUDE] Mensagem gerada');

      } catch (errorClaude) {
        // Se Claude falhar, usar mensagem gen√©rica simples
        log.warning('[CLAUDE] Falhou ao gerar mensagem personalizada, usando fallback simples');

        // ‚úÖ Mensagem gen√©rica mas persuasiva
        const mensagensFallback = [
          `E a√≠, o que achou desse ${nomeSimplificado}? Quer que eu simule o financiamento pra voc√™?`,
          `Viu? Esse ${nomeSimplificado} √© uma √≥tima op√ß√£o! Bora fazer uma simula√ß√£o?`,
          `Olha, esse ${nomeSimplificado} t√° impec√°vel! Quer ver as condi√ß√µes de pagamento?`
        ];

        msgAudio = mensagensFallback[Math.floor(Math.random() * mensagensFallback.length)];
        log.info(`[FALLBACK] Mensagem: "${msgAudio}"`);
      }

      // Limpar a mensagem (remover aspas se tiver)
      msgAudio = msgAudio
        .replace(/^["']|["']$/g, '')
        .trim();

      log.info(`[IA] Mensagem: "${msgAudio}"`);

      // ========== ENVIAR COMO √ÅUDIO ==========
      try {
        const elevenLabs = new ElevenLabsService();

        // ‚úÖ Formatar texto para TTS
        const msgAudioFormatada = FormatadorFala.prepararParaTTS(msgAudio);
        log.info(`[TTS] Formatado: "${msgAudioFormatada}"`);

        const audioPersuasivo = await elevenLabs.textToSpeech(msgAudioFormatada);

        // ‚úÖ USAR M√âTODO SEGURO para enviar √°udio
        await this.enviarAudioSeguro(audioPersuasivo, tel, sock, 'persuasivo');
        log.success('[√ÅUDIO] Mensagem persuasiva enviada');

      } catch (audioErr) {
        // Fallback: enviar como texto se √°udio falhar
        log.error(`[√ÅUDIO] Erro ao enviar: ${audioErr.message}, enviando texto`);
        await sock.sendPresenceUpdate('composing', tel);
        await sock.sendMessage(tel, { text: msgAudio });
        await sock.sendPresenceUpdate('paused', tel);
      }

    } catch (iaError) {
      // ‚ùå REMOVIDO: N√£o enviar mensagem de emerg√™ncia ap√≥s as fotos
      // O cliente j√° viu as fotos, n√£o √© necess√°rio enviar fallback de erro
      log.error(`[IA] Erro ao gerar mensagem persuasiva: ${iaError.message}`);
      log.warning(`[IA] ‚ö†Ô∏è √Åudio persuasivo n√£o foi enviado, mas fotos j√° foram entregues`);

      // ‚úÖ APENAS LOGAR O ERRO - N√£o enviar nada para o cliente
      // O fluxo continua normalmente sem mensagem extra
    }

  } catch (err) {
    log.error(`[FOTOS] ERRO GERAL ao enviar fotos: ${err.message}`);
    console.error(`[DEBUG-FOTOS] Stack trace:`, err.stack);

    // ‚ùå N√ÉO ENVIAR NENHUM FALLBACK AQUI - O √°udio persuasivo j√° foi enviado acima
    // Se chegou aqui, significa que as fotos podem ter falhado mas o √°udio persuasivo j√° foi enviado
    // Apenas logar o erro sem propagar ou enviar mensagem adicional

    // ‚úÖ N√ÉO re-lan√ßar o erro para evitar que handlers externos enviem mensagens duplicadas
    // throw err; // ‚Üê REMOVIDO
  }

  log.info(`[FOTOS] ‚úÖ Processo de envio de fotos conclu√≠do para ${veiculo.nome}`);
}




// ========== ENVIAR LISTA COM FOTOS ==========
async enviarListaComFotos(veiculos, tel, sock, incluir_fotos = false) {
  const qtd = veiculos.length;
  const textoQtd = qtd === 1 ? '1 ve√≠culo' : `${qtd} ve√≠culos`;
  log.info(`üìã [LISTA-FOTOS] Enviando ${textoQtd} com fotos ${incluir_fotos ? '+ fotos adicionais' : ''}`);

  // ========== √ÅUDIO CURTO ANTES DAS FOTOS ==========
  try {
    // ‚úÖ MENSAGEM DIFERENCIADA QUANDO S√ì TEM 1 CARRO NO ESTOQUE
    let textoIntro;
    if (qtd === 1) {
      textoIntro = `Encontrei esse modelo! √â o √∫nico que temos no estoque no momento. Vou te mostrar! üòä`;
    } else {
      textoIntro = `Encontrei ${qtd} op√ß√µes perfeitas! Vou mandar as fotos agora üòä`;
    }

    log.info(`[AUDIO-LISTA] üí¨ Texto introdut√≥rio: "${textoIntro}"`);

    const audioIntro = await this.gerarAudio(textoIntro);

    if (audioIntro) {
      // ‚úÖ USAR M√âTODO SEGURO para enviar √°udio
      await this.enviarAudioSeguro(audioIntro, tel, sock, 'intro_lista');
      log.success('[AUDIO-LISTA] ‚úÖ √Åudio introdut√≥rio enviado');
    }

    await new Promise(r => setTimeout(r, 1000)); // Delay antes das fotos
  } catch (error) {
    log.warning('[AUDIO-LISTA] ‚ö†Ô∏è Erro ao gerar √°udio introdut√≥rio:', error.message);
    // ‚úÖ Limpar status mesmo em erro
    await sock.sendPresenceUpdate('paused', tel);
    // Continuar mesmo se √°udio falhar
    await new Promise(r => setTimeout(r, 500));
  }

  // ‚úÖ IMPORTANTE: Salvar apenas os ve√≠culos que ser√£o exibidos (m√°ximo 3)
  const veiculosExibidos = veiculos.slice(0, 3);

  // Enviar cada ve√≠culo
  for (let i = 0; i < veiculosExibidos.length; i++) {
    const v = veiculosExibidos[i];

    console.log(`\n========================================`);
    console.log(`[DEBUG-FOTO] üì∏ VE√çCULO ${i+1}/${veiculosExibidos.length}`);
    console.log(`[DEBUG-FOTO] Nome completo: "${v.nome}"`);
    console.log(`[DEBUG-FOTO] ID do ve√≠culo: ${v.id}`);
    console.log(`[DEBUG-FOTO] Ano: ${v.ano}`);
    console.log(`[DEBUG-FOTO] Pre√ßo: R$ ${v.preco}`);
    console.log(`========================================`);

    // Construir URL da foto com DEBUG DETALHADO
    console.log(`\n[DEBUG-FOTO] üîç CAMPOS DE FOTO DO BANCO:`);
    console.log(`  - v.foto: "${v.foto}"`);
    console.log(`  - v.image: "${v.image}"`);
    console.log(`  - v.imagem: "${v.imagem}"`);

    const fotoFilename = v.foto || v.image || v.imagem;
    console.log(`\n[DEBUG-FOTO] üìã Foto escolhida (bruta): "${fotoFilename}"`);

    // Caption formatado com nome simplificado + TODAS as informa√ß√µes
    const nomeSimplificado = simplificarNomeVeiculo(v.nome, v.ano);
    const caption = `${i + 1}. *${nomeSimplificado}*

üí∞ *R$ ${v.preco.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}*

üìã *Informa√ß√µes:*
üìÖ Ano: ${v.ano || 'N/A'}
üõ£Ô∏è KM: ${v.km ? v.km.toLocaleString('pt-BR') : 'A consultar'}
‚öôÔ∏è C√¢mbio: ${v.cambio || 'A consultar'}
‚õΩ Combust√≠vel: ${v.combustivel || 'A consultar'}${v.cor ? `
üé® Cor: ${v.cor}` : ''}

üëâ Digite *"${i + 1}"* para ver mais detalhes e simular financiamento!`;

    console.log(`\n[DEBUG-FOTO] üìù Caption preparado:`);
    console.log(caption);

    // Enviar foto com legenda (tentando todas as extens√µes)
    if (fotoFilename) {
      console.log(`\n[DEBUG-FOTO] üì∏ VE√çCULO ${i+1} - Filename do banco: "${fotoFilename}"`);
      const urlsPossiveis = this.construirURLFoto(fotoFilename, 'capa'); // ‚Üê Foto de CAPA (lista)
      console.log(`[DEBUG-FOTO] üîó URLs que ser√£o tentadas (${urlsPossiveis.length}):`);
      urlsPossiveis.forEach((url, idx) => console.log(`   ${idx+1}. ${url}`));

      let fotoEnviada = false;
      for (const fotoURL of urlsPossiveis) {
        try {
          // ‚úÖ VERIFICAR SE IMAGEM REALMENTE EXISTE ANTES DE ENVIAR
          const imagemExiste = await this.verificarImagemExiste(fotoURL);

          if (!imagemExiste) {
            console.log(`[DEBUG-FOTO] ‚è≠Ô∏è Pulando ${fotoURL.split('/').pop()} (n√£o existe ou √© placeholder)`);
            continue;
          }

          console.log(`[DEBUG-FOTO] ‚è≥ Enviando imagem verificada: ${fotoURL.split('/').pop()}`);
          await sock.sendMessage(tel, {
            image: { url: fotoURL },
            caption
          });

          console.log(`[DEBUG-FOTO] ‚úÖ FOTO ENVIADA COM SUCESSO!`);
          log.success(`[LISTA-FOTOS] ‚úì Ve√≠culo ${i+1} enviado: ${nomeSimplificado}`);
          fotoEnviada = true;
          break;
        } catch (errorFoto) {
          console.log(`[DEBUG-FOTO] ‚ùå Falhou (${errorFoto.message}), tentando pr√≥xima extens√£o...`);
        }
      }

      if (!fotoEnviada) {
        console.log(`[DEBUG-FOTO] ‚ö†Ô∏è NENHUMA extens√£o funcionou! URLs testadas: ${urlsPossiveis.join(', ')}`);

        // Gerar desculpa espont√¢nea com IA
        try {
          // ‚úÖ USAR CLAUDE EM VEZ DE OPENAI
          const desculpaIA = await callClaudeInsteadOfOpenAI(this.anthropic, {
            messages: [{
              role: 'system',
              content: `Voc√™ √© a Aira. A foto n√£o carregou. Crie UMA frase curta (1 linha) se desculpando e dizendo que vai tentar de novo.

INSTRU√á√ïES:
- Seja informal ("opa", "eita", "ops")
- Mencione que vai tentar novamente
- Seja natural

Sua desculpa:`
            }],
            temperature: 0.9,
            max_tokens: 40
          });

          try {
            const audioDesculpa = await this.gerarAudio(desculpaIA);

            // ‚úÖ Salvar em arquivo tempor√°rio
            const audioDesculpaPath = path.join(__dirname, `temp_desculpa_foto2_${Date.now()}.mp3`);
            fs.writeFileSync(audioDesculpaPath, audioDesculpa);

            // ‚úÖ Mostrar "gravando" antes de enviar
            await sock.sendPresenceUpdate('recording', tel);

            await sock.sendMessage(tel, {
              audio: { url: audioDesculpaPath },
              mimetype: 'audio/ogg; codecs=opus',
              ptt: true
            });

            console.log(`[DEBUG-FOTO] üéôÔ∏è √Åudio: "${desculpaIA}"`);
            fs.unlinkSync(audioDesculpaPath);

            // ‚úÖ Limpar status "gravando"
            await sock.sendPresenceUpdate('paused', tel);

          } catch {
            await sock.sendPresenceUpdate('composing', tel);
            await sock.sendMessage(tel, { text: desculpaIA });
            await sock.sendPresenceUpdate('paused', tel);
            console.log(`[DEBUG-FOTO] üìù Texto: "${desculpaIA}"`);
          }
        } catch (errIA) {
          // ‚úÖ GERAR FALLBACK ESPONT√ÇNEO (sem mensagens fixas)
          const fallback = await this.gerarMensagemErroEspontanea('foto_nao_carregou', `foto ${i+1} da lista`);
          await sock.sendMessage(tel, { text: fallback });
          console.log(`[DEBUG-FOTO] ‚ö†Ô∏è Fallback espont√¢neo: "${fallback}"`);
        }

        // Esperar um pouco e tentar novamente
        await new Promise(r => setTimeout(r, 1500));

        // Segunda tentativa
        console.log('[DEBUG-FOTO] üîÑ Tentando enviar foto novamente...');
        for (const fotoURL of urlsPossiveis) {
          try {
            await sock.sendMessage(tel, {
              image: { url: fotoURL },
              caption: caption
            });
            console.log(`[DEBUG-FOTO] ‚úÖ Foto enviada na segunda tentativa: ${fotoURL}`);
            log.success(`[LISTA-FOTOS] ‚úì Ve√≠culo ${i+1} enviado na segunda tentativa: ${nomeSimplificado}`);
            fotoEnviada = true;
            break;
          } catch (err) {
            console.log(`[DEBUG-FOTO] ‚ùå Segunda tentativa falhou (${err.message})`);
          }
        }

        // Se mesmo assim n√£o enviou, enviar s√≥ o texto
        if (!fotoEnviada) {
          console.log(`[DEBUG-FOTO] üìù Enviando apenas texto (foto n√£o dispon√≠vel)...`);
          await sock.sendMessage(tel, { text: caption });
          log.warning(`[LISTA-FOTOS] ‚ö†Ô∏è Ve√≠culo ${i+1} enviado sem foto: ${nomeSimplificado}`);
        }
      }

      // ========== BUSCAR E ENVIAR FOTOS ADICIONAIS (SE incluir_fotos = true) ==========
      if (incluir_fotos && fotoEnviada) {
        console.log(`\n[DEBUG-FOTOS-ADICIONAIS] üîç Buscando fotos adicionais do ve√≠culo ID: ${v.id}`);

        try {
          // ‚úÖ CORRE√á√ÉO: db.execute() j√° retorna o array diretamente, n√£o precisa destructuring
          const fotosAdicionais = await db.execute(
            'SELECT id, image FROM car_images WHERE car_id = ? LIMIT 5',
            [v.id]
          );

          console.log(`[DEBUG-FOTOS-ADICIONAIS] üìä Encontradas ${fotosAdicionais?.length || 0} fotos adicionais`);

          if (fotosAdicionais && fotosAdicionais.length > 0) {
            for (let j = 0; j < Math.min(fotosAdicionais.length, 4); j++) {
              const fotoAdicional = fotosAdicionais[j];
              const fotoAdicionalFilename = fotoAdicional.image;

              console.log(`[DEBUG-FOTOS-ADICIONAIS] üì∏ Foto adicional ${j+1}/${fotosAdicionais.length}: "${fotoAdicionalFilename}"`);

              const urlsAdicionaisPossiveis = this.construirURLFoto(fotoAdicionalFilename);

              let fotoAdicionalEnviada = false;
              for (const urlFotoAdicional of urlsAdicionaisPossiveis) {
                try {
                  await new Promise(r => setTimeout(r, 800)); // Delay entre fotos
                  await sock.sendMessage(tel, {
                    image: { url: urlFotoAdicional }
                  });
                  console.log(`[DEBUG-FOTOS-ADICIONAIS] ‚úÖ Foto adicional ${j+1} enviada: ${urlFotoAdicional}`);
                  log.success(`[LISTA-FOTOS] ‚úì Foto adicional ${j+1} do ve√≠culo ${i+1} enviada`);
                  fotoAdicionalEnviada = true;
                  break;
                } catch (err) {
                  console.log(`[DEBUG-FOTOS-ADICIONAIS] ‚ùå Falhou (${err.message}), tentando pr√≥xima extens√£o...`);
                }
              }

              if (!fotoAdicionalEnviada) {
                console.log(`[DEBUG-FOTOS-ADICIONAIS] ‚ö†Ô∏è N√£o foi poss√≠vel enviar foto adicional ${j+1}`);
              }
            }
            log.success(`[LISTA-FOTOS] ‚úì ${Math.min(fotosAdicionais.length, 4)} fotos adicionais enviadas do ve√≠culo ${i+1}`);
          } else {
            console.log(`[DEBUG-FOTOS-ADICIONAIS] ‚ÑπÔ∏è Nenhuma foto adicional encontrada para este ve√≠culo`);
          }
        } catch (error) {
          console.error(`[DEBUG-FOTOS-ADICIONAIS] ‚ùå Erro ao buscar fotos adicionais:`, error);
          log.warning(`[LISTA-FOTOS] ‚ö†Ô∏è Erro ao buscar fotos adicionais do ve√≠culo ${i+1}`);
        }
      }
    } else {
      console.log(`[DEBUG-FOTO] ‚ö†Ô∏è Ve√≠culo ${i+1} SEM FOTO no banco (image vazio)!`);

      // Gerar mensagem espont√¢nea quando n√£o h√° foto
      try {
        // ‚úÖ USAR CLAUDE EM VEZ DE OPENAI
        const mensagemSemFotoIA = await callClaudeInsteadOfOpenAI(this.anthropic, {
          messages: [{
            role: 'system',
            content: `Voc√™ √© a Aira. Este ve√≠culo n√£o tem foto cadastrada. Crie UMA frase curta (1 linha) se desculpando mas oferecendo passar os detalhes.

INSTRU√á√ïES:
- Seja informal e simp√°tica
- Reconhe√ßa que n√£o tem foto
- Ofere√ßa passar as informa√ß√µes
- Use express√µes naturais

EXEMPLO DE TOM (N√ÉO copie):
"Opa, esse t√° sem foto ainda... Mas vou te passar todos os detalhes!"

Sua mensagem:`
          }],
          temperature: 0.9,
          max_tokens: 50
        });

        try {
          const audioDesculpa = await this.gerarAudio(mensagemSemFotoIA);

          // ‚úÖ Salvar em arquivo tempor√°rio
          const audioDesculpaPath = path.join(__dirname, `temp_sem_foto_${Date.now()}.mp3`);
          fs.writeFileSync(audioDesculpaPath, audioDesculpa);

          // ‚úÖ Mostrar "gravando" antes de enviar
          await sock.sendPresenceUpdate('recording', tel);

          await sock.sendMessage(tel, {
            audio: { url: audioDesculpaPath },
            mimetype: 'audio/ogg; codecs=opus',
            ptt: true
          });

          console.log(`[DEBUG-FOTO] üéôÔ∏è √Åudio: "${mensagemSemFotoIA}"`);
          fs.unlinkSync(audioDesculpaPath);

          // ‚úÖ Limpar status "gravando"
          await sock.sendPresenceUpdate('paused', tel);

        } catch {
          await sock.sendPresenceUpdate('composing', tel);
          await sock.sendMessage(tel, { text: mensagemSemFotoIA });
          await sock.sendPresenceUpdate('paused', tel);
          console.log(`[DEBUG-FOTO] üìù Texto: "${mensagemSemFotoIA}"`);
        }
      } catch (errIA) {
        // ‚úÖ GERAR FALLBACK ESPONT√ÇNEO (sem mensagens fixas)
        const fallback = await this.gerarMensagemErroEspontanea('foto_nao_existe', `ve√≠culo ID ${veiculo.id}`);
        await sock.sendMessage(tel, { text: fallback });
        console.log(`[DEBUG-FOTO] ‚ö†Ô∏è Fallback espont√¢neo: "${fallback}"`);
      }

      await new Promise(r => setTimeout(r, 800));
      await sock.sendMessage(tel, { text: caption });
      log.warning(`[LISTA-FOTOS] ‚ö†Ô∏è Ve√≠culo ${i+1} sem foto no banco: ${nomeSimplificado}`);
    }

    // Delay entre ve√≠culos
    if (i < veiculosExibidos.length - 1) {
      console.log(`\n[DEBUG-FOTO] ‚è≥ Aguardando 1.2s antes do pr√≥ximo ve√≠culo...\n`);
      await new Promise(r => setTimeout(r, 1200));
    }
  }

  // Salvar lista para sele√ß√£o posterior (APENAS OS VE√çCULOS EXIBIDOS!)
this.setListaOpcoes(tel, veiculosExibidos);

// ‚úÖ MARCAR QUE LISTA FOI ENVIADA (para bloquear nova busca autom√°tica)
if (!this.listaEnviada) {
  this.listaEnviada = new Map();
}
this.listaEnviada.set(tel, true);
log.info(`üìã Flag 'listaEnviada' marcada para ${tel} - N√£o enviar√° nova lista automaticamente`);

// ========== SE FOR APENAS 1 VE√çCULO, SALVAR AUTOMATICAMENTE COMO INTERESSE ==========
if (veiculosExibidos.length === 1) {
  this.veiculoInteresse.set(tel, veiculosExibidos[0]);
  log.info(`üöó Ve√≠culo √∫nico salvo automaticamente como interesse: ${veiculosExibidos[0].nome}`);
}

// ========== √ÅUDIO CURTO DE FECHAMENTO ==========
// ‚ùå DESABILITADO - A IA j√° envia um √°udio espont√¢neo e personalizado ap√≥s a lista
// Este √°udio estava duplicando a mensagem (√°udio gen√©rico + √°udio da IA)
/*
await new Promise(r => setTimeout(r, 1000)); // Delay ap√≥s as fotos

try {
  const ehSingular = qtd === 1;
  const textoFechamento = ehSingular ? 'Qual voc√™ achou desse?' : 'Qual desses chamou sua aten√ß√£o?';

  log.info(`[AUDIO-FECHAMENTO] üí¨ Texto: "${textoFechamento}"`);

  const audioFechamento = await this.gerarAudio(textoFechamento);

  if (audioFechamento) {
    // ‚úÖ USAR M√âTODO SEGURO para enviar √°udio
    await this.enviarAudioSeguro(audioFechamento, tel, sock, 'fechamento');
    log.success('[AUDIO-FECHAMENTO] ‚úÖ √Åudio de fechamento enviado');
  } else {
    // Fallback: enviar como texto
    await sock.sendPresenceUpdate('composing', tel);
    await new Promise(r => setTimeout(r, 100));
    await sock.sendMessage(tel, { text: textoFechamento });
    await sock.sendPresenceUpdate('paused', tel);
  }

} catch (error) {
  log.error(`[AUDIO-FECHAMENTO] ‚ö†Ô∏è Erro: ${error.message}`);
  // Fallback: enviar texto simples
  try {
    const fallbackMsg = qtd === 1 ? "Esse te interessou? üòä" : "Qual desses te interessou? üòä";
    await sock.sendMessage(tel, { text: fallbackMsg });
    await sock.sendPresenceUpdate('paused', tel);
  } catch {
    log.error('[AUDIO-FECHAMENTO] ‚ùå Erro at√© no fallback');
    await sock.sendPresenceUpdate('paused', tel);
  }
}
*/

log.success('[LISTA-FOTOS] Enviada com sucesso');
}



  async processar(tel, msg, sock, nome = 'amigo') {
    try {
      console.log('\n==========================================');
      console.log('üì± NOVA MENSAGEM RECEBIDA');
      console.log('Telefone:', tel);
      console.log('Mensagem:', msg);
      console.log('Etapa atual:', this.etapas.get(tel) || 'INICIAL');
      console.log('==========================================\n');

      const agora = Date.now();
      const proximoPermitido = this.ultimoEnvio.get(tel) || 0;

      if (agora < proximoPermitido) {
        log.info('Muito r√°pido, ignorando');
        return null;
      }

      this.ultimoEnvio.set(tel, agora + 3000);

      const msgLower = msg.toLowerCase().trim();
      const etapaAtual = this.etapas.get(tel) || 'INICIO';
      const jaSeApresentou = this.jaSeApresentou.get(tel) || false;
      
      // ========== SAUDA√á√ÉO INICIAL (APENAS NA PRIMEIRA VEZ) ==========
if (etapaAtual === 'INICIO' && msgLower.match(/^(oi|ola|ol√°|hey|fala|bom dia|boa tarde|boa noite)$/i)) {
  this.etapas.set(tel, 'DESCOBERTA');
  this.jaSeApresentou.set(tel, true);

  // ‚ú® GERAR SAUDA√á√ÉO √öNICA E HUMANA COM IA
  log.info('‚ú® Gerando sauda√ß√£o personalizada com IA...');
  const resp = await this.gerarRespostaHumana('saudacao', {
    nome: nome,
    mensagem: msg
  });

  this.addHistorico(tel, 'Cliente', msg);
  this.addHistorico(tel, 'Aira', resp);
  return resp;
}

      // ========== DETECTAR PEDIDO DE FOTOS DO VE√çCULO DE INTERESSE ==========
      const veiculoInteresse = this.veiculoInteresse.get(tel);

      // Detec√ß√£o MAIS RESTRITIVA de pedido de fotos (evitar false positives)
      const pedidoFotos =
        // 1. Padr√µes EXPL√çCITOS com "foto/imagem" + verbo de requisi√ß√£o
        /\b(quero|queria|pode|manda|envia|envie|mande)\s+(ver\s+)?(as\s+|a\s+|outra?s?\s+|mais\s+)?(foto|imagem|imagens|fotos)/i.test(msg) ||
        // 2. "foto/imagem dele/dela/desse/dessa" (mais espec√≠fico)
        /\b(foto|fotos|imagem|imagens)\s+(dele|dela|desse|dessa|deste|desta|do\s+carro)\b/i.test(msg) ||
        // 3. Apenas "foto(s)" ou "imagem(ns)" ISOLADO (n√£o no meio da frase)
        /^(foto|fotos|imagem|imagens)\s*[.!?]?\s*$/i.test(msg) ||
        // 4. "tem foto?" espec√≠fico (com interroga√ß√£o ou "tem" expl√≠cito)
        /\b(tem|possui|h√°)\s+(foto|fotos|imagem|imagens)(\?|\s+\?|\s+dele|\s+desse|\s+do\s+carro)/i.test(msg);

      if (veiculoInteresse && pedidoFotos) {
        // ‚úÖ VERIFICAR SE FOTOS J√Å FORAM ENVIADAS PARA ESTE VE√çCULO
        const chaveFotos = `${tel}_${veiculoInteresse.id}`;
        const jaEnviou = this.fotosJaEnviadas.get(chaveFotos);

        if (jaEnviou) {
          log.info(`üì∏ Fotos do ${veiculoInteresse.nome} J√Å foram enviadas. Ignorando pedido duplicado.`);
          // N√£o retornar null, deixar a IA responder normalmente
        } else {
          log.info(`üì∏ Cliente pediu fotos do ve√≠culo de interesse: ${veiculoInteresse.nome}`);

          // Enviar fotos do ve√≠culo de interesse
          log.info('üì∏ Enviando fotos do ve√≠culo de interesse...');

          try {
            await this.enviarFotosVeiculo(veiculoInteresse, tel, sock);
            log.success(`‚úì Fotos do ${veiculoInteresse.nome} enviadas`);

            // ‚úÖ MARCAR FOTOS COMO ENVIADAS
            this.fotosJaEnviadas.set(chaveFotos, Date.now());

            // ‚úÖ LIMPAR LISTA DE OP√á√ïES ap√≥s enviar fotos
            // Evita que o bot continue tentando fazer match com a lista antiga
            this.clearListaOpcoes(tel);
          } catch (err) {
            log.error(`‚ùå Erro ao enviar fotos: ${err.message}`);
          }

          this.addHistorico(tel, 'Cliente', msg);
          this.addHistorico(tel, 'Aira', `[Enviou fotos do ${veiculoInteresse.nome}]`);

          // ‚úÖ RETORNAR STRING VAZIA para indicar sucesso (n√£o retornar null!)
          // Null dispara envio de mensagem de erro
          return '';
        }
      }

      // ========== VERIFICAR SE CLIENTE EST√Å PEDINDO NOVAMENTE UM CARRO DA LISTA ==========
      const listaObj = this.getListaOpcoes(tel);
      const lista = listaObj ? listaObj.veiculos : null;

      // ‚úÖ DETECTAR SE CLIENTE PEDIU NOVAMENTE UM MODELO QUE J√Å EST√Å NA LISTA
      if (lista && lista.length > 0 && veiculoInteresse) {
        const modeloPedido = msg.toLowerCase();
        const modeloAtual = (veiculoInteresse.nome || '').toLowerCase();

        // Verificar se est√° pedindo o mesmo modelo
        const pedindoMesmoModelo =
          modeloAtual.split(' ').some(palavra =>
            palavra.length > 3 && modeloPedido.includes(palavra)
          );

        if (pedindoMesmoModelo) {
          log.info(`üîÑ Cliente pediu novamente ${veiculoInteresse.nome} que j√° foi mostrado na lista`);

          // Verificar se fotos j√° foram enviadas
          const chaveFotos = `${tel}_${veiculoInteresse.id}`;
          const fotosJaEnviadas = this.fotosJaEnviadas.get(chaveFotos);

          if (fotosJaEnviadas) {
            // J√° enviou fotos, perguntar se quer mais informa√ß√µes
            log.info(`‚úÖ Fotos de ${veiculoInteresse.nome} j√° foram enviadas, oferecendo mais informa√ß√µes`);

            // N√ÉO adicionar ao hist√≥rico ainda, vai deixar o fluxo normal da IA responder
            // A IA vai detectar pelo contexto que j√° foi enviado
          } else {
            // Ainda n√£o enviou fotos, oferecer enviar
            log.info(`üì∏ Oferecendo enviar fotos de ${veiculoInteresse.nome}`);

            try {
              await this.enviarFotosVeiculo(veiculoInteresse, tel, sock);
              log.success(`‚úì Fotos do ${veiculoInteresse.nome} enviadas`);

              this.fotosJaEnviadas.set(chaveFotos, Date.now());
              this.clearListaOpcoes(tel);

              this.addHistorico(tel, 'Cliente', msg);
              this.addHistorico(tel, 'Aira', `[Enviou fotos do ${veiculoInteresse.nome}]`);

              return '';
            } catch (err) {
              log.error(`‚ùå Erro ao enviar fotos: ${err.message}`);
            }
          }
        }
      }

      // ‚Üê DETEC√á√ÉO DE ESCOLHA DE VE√çCULO (mais restritiva)
      if (lista && lista.length > 0) {
        let veiculoEscolhido = null;

        // Primeiro: verificar se √© um n√∫mero (1, 2, 3)
        const numeroMatch = msg.match(/^([123])$/);
        if (numeroMatch) {
          const indice = parseInt(numeroMatch[1]) - 1;
          veiculoEscolhido = lista[indice];
        }

        // Segundo: verificar se menciona marca/modelo espec√≠fico COM palavras-chave de interesse
        if (!veiculoEscolhido) {
          const palavrasInteresse = /\b(quero|gostei|adorei|escolho|esse|este|essa|esta|mostrar?|mostra|ver|fotos?|me\s+mostra|envia|manda)\b/i;

          // S√≥ busca match se houver palavra de interesse
          if (palavrasInteresse.test(msg)) {
            // ‚úÖ Extrair todas as palavras (incluindo n√∫meros como 2008, 208, etc)
            const palavrasCliente = msgLower.split(/\s+/).filter(p => p.length >= 2); // Aceita palavras com 2+ caracteres

            // ‚úÖ Tamb√©m extrair n√∫meros isolados que podem ser modelos (208, 2008, 3008, etc)
            const numerosModelo = msg.match(/\b(\d{3,4})\b/g) || [];

            // ‚úÖ DETECTAR COR na mensagem
            const coresComuns = {
              'preto': ['preto', 'preta', 'black'],
              'branco': ['branco', 'branca', 'white'],
              'prata': ['prata', 'silver', 'cinza'],
              'vermelho': ['vermelho', 'vermelha', 'red'],
              'azul': ['azul', 'blue'],
              'verde': ['verde', 'green'],
              'amarelo': ['amarelo', 'amarela', 'yellow'],
              'dourado': ['dourado', 'dourada', 'gold'],
              'marrom': ['marrom', 'brown'],
              'roxo': ['roxo', 'roxa', 'purple'],
              'laranja': ['laranja', 'orange'],
              'bege': ['bege', 'beige']
            };

            let corMencionada = null;
            for (const [corBase, variacoes] of Object.entries(coresComuns)) {
              if (variacoes.some(v => msgLower.includes(v))) {
                corMencionada = corBase;
                break;
              }
            }

            console.log(`üîç [DEBUG-VEICULO] Palavras cliente:`, palavrasCliente);
            console.log(`üîç [DEBUG-VEICULO] N√∫meros modelo:`, numerosModelo);
            console.log(`üîç [DEBUG-VEICULO] Cor mencionada:`, corMencionada || 'nenhuma');

            // ‚úÖ SISTEMA DE PONTUA√á√ÉO para escolher o melhor match
            let melhorMatch = null;
            let melhorPontuacao = 0;

            for (const veiculo of lista) {
              const nomeVeiculo = (veiculo.nome || '').toLowerCase();
              const marcaVeiculo = (veiculo.marca || '').toLowerCase();
              const anoVeiculo = (veiculo.ano || '').toString();
              const corVeiculo = (veiculo.cor || '').toLowerCase();

              let pontuacao = 0;

              // ‚úÖ PONTOS por palavras que fazem match
              const matchesPalavras = palavrasCliente.filter(palavra =>
                nomeVeiculo.includes(palavra) ||
                marcaVeiculo.includes(palavra)
              );
              pontuacao += matchesPalavras.length * 10; // 10 pontos por palavra

              // ‚úÖ PONTOS por n√∫mero de modelo (muito importante!)
              const matchNumero = numerosModelo.some(numero => nomeVeiculo.includes(numero));
              if (matchNumero) {
                pontuacao += 30; // 30 pontos por n√∫mero de modelo
              }

              // ‚úÖ PONTOS por ano mencionado
              const matchAno = palavrasCliente.includes(anoVeiculo);
              if (matchAno) {
                pontuacao += 15; // 15 pontos por ano
              }

              // ‚úÖ PONTOS EXTRAS por cor mencionada (DECISIVO em caso de empate!)
              if (corMencionada && corVeiculo.includes(corMencionada)) {
                pontuacao += 50; // 50 pontos extras por cor correta!
                console.log(`‚úÖ [DEBUG-VEICULO] Cor match! ${veiculo.nome} (${corVeiculo}) +50 pts`);
              }

              // ‚úÖ Se tem pontua√ß√£o, √© candidato
              if (pontuacao > 0) {
                console.log(`üîç [DEBUG-VEICULO] ${veiculo.nome} - Pontua√ß√£o: ${pontuacao}`);
                if (pontuacao > melhorPontuacao) {
                  melhorPontuacao = pontuacao;
                  melhorMatch = veiculo;
                }
              }
            }

            if (melhorMatch) {
              console.log(`‚úÖ [DEBUG-VEICULO] Melhor match: ${melhorMatch.nome} (${melhorPontuacao} pts)`);
              veiculoEscolhido = melhorMatch;
            }

            // ‚úÖ FALLBACK: Se n√£o encontrou mas tem palavra-chave, tentar busca fuzzy
            if (!veiculoEscolhido && palavrasCliente.length > 0) {
              const palavraChave = palavrasCliente.find(p =>
                p !== 'me' && p !== 'mostra' && p !== 'ver' && p !== 'quero' && p.length > 2
              );

              if (palavraChave) {
                for (const veiculo of lista) {
                  const nomeVeiculo = (veiculo.nome || '').toLowerCase();

                  // Busca parcial mais permissiva
                  if (nomeVeiculo.includes(palavraChave) || palavraChave.includes(nomeVeiculo.split(' ')[0])) {
                    console.log(`‚úÖ [DEBUG-VEICULO] Match fuzzy: ${veiculo.nome} via "${palavraChave}"`);
                    veiculoEscolhido = veiculo;
                    break;
                  }
                }
              }
            }
          }
        }
        
        if (veiculoEscolhido) {
        log.info(`Cliente escolheu: ${veiculoEscolhido.nome}`);

        // ‚úÖ ADICIONE ESTA LINHA:
        this.veiculoInteresse.set(tel, veiculoEscolhido);

        // ‚ùå REMOVIDO: N√£o enviar mensagem de texto de introdu√ß√£o
        // Ir direto para as fotos com √°udio persuasivo
        log.info('üì∏ Enviando fotos do ve√≠culo escolhido...');

        // Enviar fotos - AGUARDAR COMPLETAR
        try {
          await this.enviarFotosVeiculo(veiculoEscolhido, tel, sock);
          log.success(`‚úì Todas as fotos do ${veiculoEscolhido.nome} foram enviadas`);

          // ‚úÖ MARCAR FOTOS COMO ENVIADAS
          const chaveFotos = `${tel}_${veiculoEscolhido.id}`;
          this.fotosJaEnviadas.set(chaveFotos, Date.now());

          // ‚úÖ LIMPAR LISTA DE OP√á√ïES ap√≥s enviar fotos do ve√≠culo escolhido
          // Isso evita que o bot continue tentando fazer match com a lista antiga
          this.clearListaOpcoes(tel);
        } catch (err) {
          log.error(`‚ùå Erro ao enviar fotos: ${err.message}`);
        }

        this.addHistorico(tel, 'Cliente', msg);
        this.addHistorico(tel, 'Aira', `[Enviou fotos do ${veiculoEscolhido.nome}]`);

        // ‚úÖ RETORNAR STRING VAZIA para indicar sucesso (n√£o retornar null!)
        // Null dispara envio de mensagem de erro
        return '';
      }
    }



      const historico = this.getHistorico(tel);

log.info(`üì• ${nome} (${etapaAtual}): "${msg}"`);

// ========== DETECTAR FRASES DE INTERESSE FORTE ==========
const frasesInteresse = [
  /vamos comprar/i,
  /quero esse/i,
  /quero este/i,
  /quero ela/i,
  /quero ele/i,
  /fechado/i,
  /fechar neg√≥cio/i,
  /top essa/i,
  /top esse/i,
  /gostei desse/i,
  /gostei deste/i,
  /gostei dela/i,
  /gostei dele/i,
  /me interessa/i,
  /tenho interesse/i,
  /vou levar/i,
  /pode separar/i
];

const demonstrouInteresse = frasesInteresse.some(regex => regex.test(msg));

if (demonstrouInteresse) {
  const veiculoAtual = this.veiculoInteresse.get(tel);
  if (veiculoAtual) {
    log.success(`üíö Cliente demonstrou INTERESSE FORTE no ${veiculoAtual.nome}! Mantendo em mem√≥ria.`);
    // Refor√ßar que este √© o ve√≠culo de interesse
    this.veiculoInteresse.set(tel, veiculoAtual);
  } else {
    log.warning(`‚ö†Ô∏è Cliente demonstrou interesse mas n√£o h√° ve√≠culo em mem√≥ria`);
  }
}

// ========== INICIALIZAR CONTEXTO ==========
let contextoAdicional = `

üìå REGRA GERAL IMPORTANTE:
- Se o cliente perguntar algo FORA DO CONTEXTO DE VENDA (Instagram, telefone, hor√°rio, onde fica, etc):
  ‚úÖ RESPONDA de forma breve e natural
  ‚úÖ VOLTE para a venda sutilmente
  ‚úÖ Seja conversacional e persuasiva
  ‚ùå NUNCA diga "n√£o entendi", "n√£o posso responder", "n√£o sei"

EXEMPLOS:
Cliente: "voc√™ tem Instagram?"
Voc√™: "Tenho sim! Mas aqui no WhatsApp consigo te ajudar melhor! üòä E a√≠, qual carro te interessou?"

Cliente: "qual seu telefone?"
Voc√™: "Pode me chamar aqui mesmo pelo WhatsApp que respondo rapidinho! Vamos ver os carros? O que procura?"

Cliente: "onde fica a loja?"
Voc√™: "Estamos aqui no Feir√£o Show Car! Mas antes de vir, deixa eu te mostrar alguns modelos pra voc√™ j√° vir sabendo qual quer ver! Beleza?"
`;

// ‚úÖ ADICIONAR CONTEXTO SOBRE VE√çCULO DE INTERESSE (SE HOUVER)
const veiculoAtualInteresse = this.veiculoInteresse.get(tel);
if (veiculoAtualInteresse) {
  const chaveFotos = `${tel}_${veiculoAtualInteresse.id}`;
  const fotosForamEnviadas = this.fotosJaEnviadas.get(chaveFotos);

  if (fotosForamEnviadas) {
    contextoAdicional += `\n\nüìå VE√çCULO DE INTERESSE DO CLIENTE:
O cliente j√° visualizou e recebeu fotos do: ${veiculoAtualInteresse.nome}

‚ö†Ô∏è SE CLIENTE PEDIR NOVAMENTE ESTE MODELO:
- N√ÉO mostre a lista novamente
- N√ÉO envie fotos novamente (j√° foram enviadas)
- Confirme que j√° mostrou e pergunte se quer: simula√ß√£o de financiamento, mais detalhes t√©cnicos, ou agendar visita
- Exemplo: "Sim! J√° te mostrei o ${veiculoAtualInteresse.nome.split(' ').slice(0, 2).join(' ')}! Quer que eu simule um financiamento? Ou prefere agendar uma visita?"
`;
  }
}

// ========== VALIDAR SE √â PRIMEIRA INTERA√á√ÉO ==========
const ehPrimeiraMensagem = historico.length === 0 || !jaSeApresentou;

// Detectar se cliente j√° est√° pedindo ve√≠culo na primeira mensagem
const msgLowerInicial = msg.toLowerCase();
const pedindoVeiculoPrimeiraMensagem = ehPrimeiraMensagem && (
  /\b(procuro|quero|busco|preciso|tenho interesse|gostaria|me mostra|tem)\b.*(carro|ve√≠culo|veiculo|auto|pickup|picape|suv|sedan|hatch)/i.test(msg) ||
  /\b(gol|civic|corolla|onix|hb20|sandero|ka|uno|palio|fiesta|fox|voyage|prisma|celta|argo|mobi|kwid|duster|kicks|creta|tucson|sportage|hr-v|hrv|compass|hillux|hilux|s10|ranger|toro|strada|saveiro|montana|spin|cobalt|cruze|tracker|taos|nivus|t-cross|tcross|renegade|jeep|toyota|honda|chevrolet|gm|fiat|volkswagen|vw|ford|hyundai|nissan|renault|peugeot|citroen)/i.test(msgLowerInicial)
);

if (ehPrimeiraMensagem) {
  this.jaSeApresentou.set(tel, true);

  // ‚úÖ ANALISAR INTEN√á√ÉO DA PRIMEIRA MENSAGEM PARA RESPOSTA CONTEXTUAL
  const msgLower = msg.toLowerCase();

  const temSaudacao = /\b(oi|ol√°|ola|bom dia|boa tarde|boa noite|e ai|eai)\b/i.test(msg);
  const temPerguntaPreco = /\bquanto (custa|√©|ta|vale|sai)/i.test(msgLower) || /\bpre√ßo|valor\b/i.test(msgLower);
  const temPerguntaEstoque = /\b(tem|t√™m|possui|vende|trabalha com)\b/i.test(msgLower);
  const temInteresseModelo = /\b(gol|civic|corolla|onix|hb20|sandero|ka|uno|compass|hilux|s10|ranger)/i.test(msgLower);
  const temVeiculoEntrada = /\btenho um.*?(carro|ve√≠culo|veiculo)\b/i.test(msgLower) || /\bdar de entrada\b/i.test(msgLower);
  const temPerguntaLocal = /\b(onde|endere√ßo|localiza√ß√£o|fica|fica a loja)\b/i.test(msgLower);
  const temPerguntaFinanciamento = /\b(financ|parcela|entrada)\b/i.test(msgLower);

  if (pedindoVeiculoPrimeiraMensagem) {
    // Cliente chegou pedindo ve√≠culo espec√≠fico
    contextoAdicional += `\n\n‚ö†Ô∏è PRIMEIRA MENSAGEM + CLIENTE PEDINDO VE√çCULO!

üéØ RESPONDA DE FORMA CONTEXTUAL:
- Cumprimente brevemente
- Mencione "Feir√£o Show Car"
- Diga "Prazer, sou a Aira"
- RECONHE√áA ESPECIFICAMENTE o que ele pediu
- Mostre empolga√ß√£o e confirme que vai buscar
- Seja DIRETA e NATURAL

üí° Exemplos baseados no contexto:
- Se pediu "quero um civic": "Ol√°! Prazer, sou a Aira da Feir√£o Show Car! Civic √© √≥tima escolha! Deixa eu buscar os que temos!"
- Se pediu "tem gol?": "Oi! Prazer, me chamo Aira da Feir√£o Show Car! Temos sim, v√°rios Gol! Vou te mostrar!"
- Se pediu "procuro suv": "Ol√°! Prazer, sou a Aira da Feir√£o Show Car! SUV √© top! Temos v√°rios modelos, j√° te mostro!"`;

  } else if (temVeiculoEntrada) {
    contextoAdicional += `\n\n‚ö†Ô∏è PRIMEIRA MENSAGEM + VE√çCULO DE ENTRADA!

üéØ RESPONDA CONTEXTUALMENTE:
- Cumprimente com entusiasmo
- Mencione "Feir√£o Show Car"
- Diga "Prazer, sou a Aira"
- Mostre INTERESSE no ve√≠culo dele
- Pergunte modelo/ano (se n√£o informou)

üí° Exemplo: "Ol√°! Prazer, sou a Aira da Feir√£o Show Car! Que legal que voc√™ tem carro pra trocar! Qual modelo e ano √© o seu?"`;

  } else if (temPerguntaPreco) {
    contextoAdicional += `\n\n‚ö†Ô∏è PRIMEIRA MENSAGEM + PERGUNTA DE PRE√áO!

üéØ RESPONDA CONTEXTUALMENTE:
- Cumprimente
- Mencione "Feir√£o Show Car"
- Diga "Prazer, sou a Aira"
- Explique que tem v√°rias faixas
- Pergunte o or√ßamento dele

üí° Exemplo: "Ol√°! Prazer, sou a Aira da Feir√£o Show Car! Temos carros de v√°rias faixas! Qual seria seu or√ßamento? Assim te mostro op√ß√µes certinhas!"`;

  } else if (temPerguntaLocal) {
    contextoAdicional += `\n\n‚ö†Ô∏è PRIMEIRA MENSAGEM + PERGUNTA DE LOCAL!

üéØ RESPONDA CONTEXTUALMENTE:
- Cumprimente
- Mencione "Feir√£o Show Car"
- Diga "Prazer, sou a Aira"
- REDIRECIONE para mostrar estoque antes

üí° Exemplo: "Ol√°! Prazer, sou a Aira da Feir√£o Show Car! Antes de vir, deixa eu te mostrar nosso estoque? Assim voc√™ j√° vem sabendo qual quer ver!"`;

  } else if (temSaudacao && !temInteresseModelo) {
    contextoAdicional += `\n\n‚ö†Ô∏è PRIMEIRA MENSAGEM + SAUDA√á√ÉO SIMPLES!

üéØ RESPONDA CONTEXTUALMENTE:
- Retorne a sauda√ß√£o
- Mencione "Feir√£o Show Car"
- Diga "Prazer, sou a Aira"
- Pergunte NATURALMENTE o que trouxe ele

üí° Exemplo: "Oi! Prazer, me chamo Aira da Feir√£o Show Car! Tudo bem? O que te trouxe aqui? T√° buscando algum modelo?"`;

  } else {
    contextoAdicional += `\n\n‚ö†Ô∏è PRIMEIRA MENSAGEM - SEJA CONTEXTUAL!

üéØ ANALISE o que o cliente disse e responda ESPECIFICAMENTE:
- Mencione "Feir√£o Show Car"
- Diga "Prazer, sou a Aira"
- Responda de acordo com o contexto dele
- N√ÉO use resposta gen√©rica!`;
  }
} else {
  contextoAdicional += `\n\nüìã CONTEXTO DA CONVERSA:`;
  historico.slice(-3).forEach(h => {
    contextoAdicional += `\n${h.role}: "${h.msg}"`;
  });
  contextoAdicional += `\n\n‚ö†Ô∏è Continue a conversa naturalmente.`;
}

// ========== CONTEXTO POR ETAPA ==========
if (jaSeApresentou && !ehPrimeiraMensagem) {
  contextoAdicional += `\n\nIMPORTANTE: Voc√™ J√Å se apresentou. N√ÉO repita.`;
}


// ========== DETECTAR CONFIRMA√á√ÉO DE HOR√ÅRIO PARA VISITA ==========
const padraoHorario = /\b(\d{1,2})(h|:|\s*hora)/i;
const confirmacoes = ['pode ser', 'confirmo', 't√° bom', 'ta bom', 'ok', 'fechado', 'combinado', 'certo', 'beleza', 'perfeito', 'amanh√£', 'hoje', 'depois', 'ter√ßa', 'quarta', 'quinta', 'sexta', 's√°bado', 'sabado', 'domingo', 'segunda'];
const temHorario = padraoHorario.test(msgLower);
const temConfirmacao = confirmacoes.some(palavra => msgLower.includes(palavra));

// Se cliente confirmou hor√°rio espec√≠fico de visita/test drive
let agendamentoConfirmadoAgora = false;
if ((temHorario && temConfirmacao) || (temHorario && msg.length < 20)) {
  log.info('‚úÖ Cliente CONFIRMOU HOR√ÅRIO de visita! Venda fechada!');
  this.etapas.set(tel, 'AGENDAMENTO_CONFIRMADO');
  agendamentoConfirmadoAgora = true;
}

// ‚ö†Ô∏è CR√çTICO: Re-capturar etapa AP√ìS detec√ß√£o de agendamento
const etapaAtualFinal = this.etapas.get(tel) || etapaAtual;

switch(etapaAtualFinal) {
  case 'DESCOBERTA':
    contextoAdicional += `\n\nETAPA: DESCOBERTA - Pergunte sobre necessidade`;
    break;
  case 'APRESENTACAO':
    contextoAdicional += `\n\nETAPA: APRESENTA√á√ÉO - Liste 3 carros`;
    break;
  case 'APROFUNDAMENTO':
    contextoAdicional += `\n\nETAPA: APROFUNDAMENTO - Detalhes`;
    break;
  case 'FECHAMENTO':
    contextoAdicional += `\n\nETAPA: FECHAMENTO - Test drive`;
    break;
  case 'AGENDAMENTO_CONFIRMADO':
    contextoAdicional += `\n\n‚úÖ‚úÖ‚úÖ ETAPA: AGENDAMENTO CONFIRMADO - VENDA FECHADA! ‚úÖ‚úÖ‚úÖ

‚ö†Ô∏è CR√çTICO: Cliente CONFIRMOU o hor√°rio da visita/test drive!

üö´ REGRA ABSOLUTA - N√ÉO BUSCAR MAIS VE√çCULOS:
‚ùå NUNCA use a fun√ß√£o buscar_carros novamente
‚ùå NUNCA mostre outros ve√≠culos
‚ùå NUNCA envie fotos de outros carros
‚ùå Se cliente mencionar outros modelos, responda com COER√äNCIA sobre o ve√≠culo que ele J√Å ESCOLHEU

üí° SE CLIENTE MENCIONAR OUTROS VE√çCULOS AP√ìS FECHAR:
- Lembre gentilmente o ve√≠culo que ele escolheu: "${this.veiculoInteresse.get(tel)?.nome || 'o ve√≠culo'}"
- Reforce que ele j√° tem hor√°rio marcado para ver esse carro
- Seja natural: "Voc√™ j√° t√° com hor√°rio marcado pro [modelo] amanh√£! Vai adorar quando ver pessoalmente üòä"

VOC√ä DEVE:
‚úÖ Confirmar o hor√°rio com entusiasmo ("Perfeito! Amanh√£ √†s 15h est√° √≥timo!")
‚úÖ Dizer que vai aguard√°-lo(a) ("Vou te aguardar aqui no Feir√£o Show Car")
‚úÖ Ficar √† disposi√ß√£o ("Qualquer coisa antes, s√≥ me chamar!")
‚úÖ Despedir-se positivamente ("At√© amanh√£!")
‚úÖ Se perguntar de outro carro, lembre o que J√Å foi escolhido

VOC√ä N√ÉO DEVE:
‚ùå N√ÉO busque ou mostre outros ve√≠culos (VENDA J√Å FECHADA!)
‚ùå N√ÉO use buscar_carros
‚ùå N√ÉO envie fotos de outros carros
‚ùå N√ÉO continue vendendo ou oferecendo coisas
‚ùå N√ÉO pergunte "tem algum modelo espec√≠fico que quer ver?"

EXEMPLO CORRETO:
"Perfeito, ${nome}! Amanh√£ √†s 15h est√° √≥timo! üòä
Vou te aguardar aqui no Feir√£o Show Car.
Qualquer coisa antes disso, √© s√≥ me chamar! At√© amanh√£!"`;
    break;
}

// ‚ö†Ô∏è SUPER CR√çTICO: Se agendamento foi confirmado AGORA (nesta mensagem)
if (agendamentoConfirmadoAgora) {
  contextoAdicional += `

üéâüéâüéâ ATEN√á√ÉO M√ÅXIMA! CLIENTE ACABOU DE CONFIRMAR O HOR√ÅRIO AGORA! üéâüéâüéâ

‚ö†Ô∏è ESTA √â A MENSAGEM MAIS IMPORTANTE DA CONVERSA!

VOC√ä DEVE:
‚úÖ Confirmar o hor√°rio com ENTUSIASMO ("Perfeito! [hor√°rio] est√° √≥timo!")
‚úÖ Dizer que vai aguard√°-lo(a) no Feir√£o Show Car
‚úÖ Ficar √† disposi√ß√£o ("Qualquer coisa antes, s√≥ me chamar!")
‚úÖ Despedir-se POSITIVAMENTE ("At√© [dia]!" ou "Te espero aqui!")

VOC√ä N√ÉO DEVE:
‚ùå N√ÉO continue a conversa
‚ùå N√ÉO fa√ßa mais perguntas sobre ve√≠culos
‚ùå N√ÉO ofere√ßa nada
‚ùå N√ÉO busque carros
‚ùå N√ÉO pergunte "tem algum modelo que quer ver?"

ESTA √â A √öLTIMA MENSAGEM DO FUNIL! ENCERRE COM CLASSE!

FORMATO IDEAL:
"[Confirma√ß√£o entusiasmada do hor√°rio] + [Aguardo no Feir√£o Show Car] + [Disponibilidade] + [Despedida positiva]"

EXEMPLO:
"Perfeito, ${nome}! [Hor√°rio que ele mencionou] est√° √≥timo! üòä
Vou te aguardar aqui no Feir√£o Show Car.
Qualquer coisa antes disso, √© s√≥ me chamar! At√© [dia]!"`;
}





// ========== DETECTAR ENTRADA EM DINHEIRO (ANTES DE TROCA) ==========
const entradaDinheiro = this.detectarEntradaDinheiro(msg);
if (entradaDinheiro) {
  const valorEntrada = this.extrairValorEntradaDinheiro(msg);
  log.info(`üí∞ Cliente mencionou entrada em DINHEIRO: R$ ${valorEntrada ? valorEntrada.toLocaleString('pt-BR') : 'n√£o identificado'}`);

  // Adicionar contexto para IA saber
  contextoAdicional += `

üí∞ INFORMA√á√ÉO IMPORTANTE: Cliente mencionou entrada em DINHEIRO!
${valorEntrada ? `Valor: R$ ${valorEntrada.toLocaleString('pt-BR')}` : 'Valor n√£o identificado claramente'}

‚ö†Ô∏è ISSO N√ÉO √â TROCA DE VE√çCULO! √â DINHEIRO EM ESP√âCIE/TRANSFER√äNCIA!

INSTRU√á√ïES:
‚úÖ Reconhe√ßa a entrada em dinheiro positivamente
‚úÖ Se n√£o entendeu o valor exato, confirme: "Voc√™ disse ${valorEntrada ? (valorEntrada/1000) + ' mil' : 'quanto'} de entrada, certo?"
‚úÖ Use essa informa√ß√£o para buscar ve√≠culos dentro do or√ßamento dele
‚úÖ Mencione que com essa entrada as parcelas ficam menores

EXEMPLO:
"√ìtimo! Com ${valorEntrada ? (valorEntrada/1000) + ' mil' : 'essa entrada'} de entrada as parcelas ficam bem tranquilas! Vou buscar as melhores op√ß√µes pra voc√™! Qual faixa de pre√ßo total t√° pensando?"`;
}

// ========== DETECTAR INTERESSE EM TROCA ==========
if (this.detectarIntencaoTroca(msg) && !entradaDinheiro) {
  log.info('üîÑ Cliente demonstrou interesse em troca');

  // ‚úÖ PRIMEIRO: Tentar extrair dados do ve√≠culo J√Å FORNECIDOS na mensagem
  const dadosExtraidos = this.extrairDadosVeiculo(msg);

  if (dadosExtraidos.modelo && dadosExtraidos.ano) {
    // ‚úÖ Cliente J√Å passou modelo + ano! Consultar FIPE imediatamente
    log.info(`üìã Dados da troca EXTRA√çDOS na primeira mensagem: ${JSON.stringify(dadosExtraidos)}`);

    this.veiculoTroca.set(tel, dadosExtraidos);
    this.etapas.set(tel, 'TROCA');

    // Consultar valor FIPE
    const valorFipe = await this.consultarFIPE(dadosExtraidos.modelo, dadosExtraidos.ano);

    if (valorFipe) {
      dadosExtraidos.valorFipe = valorFipe;
      this.veiculoTroca.set(tel, dadosExtraidos);

      const resposta = `Perfeito! Vi aqui que voc√™ tem um ${dadosExtraidos.modelo.toUpperCase()} ${dadosExtraidos.ano} üöó\n\nConsultei na Tabela FIPE e o valor m√©dio dele √© de *${this.formatarMoeda(valorFipe)}*.\n\nEsse valor pode ser usado como entrada! Quer que eu busque os carros do estoque que cabem no seu or√ßamento? üòä`;

      this.addHistorico(tel, 'Cliente', msg);
      this.addHistorico(tel, 'Aira', resposta);

      return resposta;
    } else {
      // N√£o conseguiu consultar FIPE, pedir mais detalhes
      const resposta = `Entendi! Voc√™ tem um ${dadosExtraidos.modelo.toUpperCase()} ${dadosExtraidos.ano}! üöó\n\nPra eu avaliar certinho, me conta: qual a vers√£o dele? Por exemplo: 1.0, 1.6, autom√°tico, manual...`;

      this.addHistorico(tel, 'Cliente', msg);
      this.addHistorico(tel, 'Aira', resposta);

      return resposta;
    }
  } else {
    // ‚ùå N√£o conseguiu extrair dados completos, perguntar
    log.info('‚ú® Gerando resposta de troca personalizada com IA...');
    const resposta = await this.gerarRespostaHumana('troca', {
      mensagem: msg
    });

    this.addHistorico(tel, 'Cliente', msg);
    this.addHistorico(tel, 'Aira', resposta);
    this.etapas.set(tel, 'TROCA');

    return resposta;
  }
}


// ========== DETECTAR DADOS DO VE√çCULO DE TROCA (se ainda n√£o completo) ==========
if (this.etapas.get(tel) === 'TROCA') {
  const dadosAtuais = this.veiculoTroca.get(tel) || {};

  // Se J√Å tem modelo + ano + valor FIPE, pular
  if (dadosAtuais.modelo && dadosAtuais.ano && dadosAtuais.valorFipe) {
    log.info('‚úÖ Dados da troca j√° completos, continuando fluxo...');
  } else {
    // Tentar extrair novos dados
    const dadosExtraidos = this.extrairDadosVeiculo(msg);

    if (dadosExtraidos.modelo || dadosExtraidos.ano || dadosExtraidos.km) {
      // Mesclar com dados existentes
      const dadosMesclados = { ...dadosAtuais, ...dadosExtraidos };
      this.veiculoTroca.set(tel, dadosMesclados);

      log.info(`üìã Dados da troca atualizados: ${JSON.stringify(dadosMesclados)}`);

      // Se agora tem modelo E ano, consultar FIPE
      if (dadosMesclados.modelo && dadosMesclados.ano && !dadosMesclados.valorFipe) {
        const valorFipe = await this.consultarFIPE(dadosMesclados.modelo, dadosMesclados.ano);

        if (valorFipe) {
          dadosMesclados.valorFipe = valorFipe;
          this.veiculoTroca.set(tel, dadosMesclados);
          this.etapas.set(tel, 'NEGOCIACAO');
        }
      }
    }
  }
}


switch(etapaAtual) {
  case 'DESCOBERTA':
    contextoAdicional += `\n\nETAPA: DESCOBERTA - Pergunte sobre necessidade`;
    break;
  case 'APRESENTACAO':
    contextoAdicional += `\n\nETAPA: APRESENTA√á√ÉO - Liste 3 carros`;
    break;
  case 'TROCA': // ‚Üê ADICIONE ISSO
    contextoAdicional += `\n\nETAPA: TROCA - Cliente quer usar carro como entrada. Pergunte: marca, modelo, ano, estado, km. N√ÉO mostre carros do estoque.`;
    break;
  case 'APROFUNDAMENTO':
    contextoAdicional += `\n\nETAPA: APROFUNDAMENTO - Detalhes`;
    break;
  case 'FECHAMENTO':
    contextoAdicional += `\n\nETAPA: FECHAMENTO - Test drive`;
    break;
}

// ‚úÖ ADICIONAR INFORMA√á√ïES DO VE√çCULO DE TROCA (se dispon√≠vel)
const dadosTrocaGPT = this.veiculoTroca.get(tel);
if (dadosTrocaGPT && dadosTrocaGPT.modelo && dadosTrocaGPT.ano) {
  contextoAdicional += `\n\nüöó VE√çCULO DE ENTRADA DO CLIENTE:`;
  contextoAdicional += `\n   Modelo: ${dadosTrocaGPT.modelo.toUpperCase()} ${dadosTrocaGPT.ano}`;

  if (dadosTrocaGPT.valorFipe) {
    contextoAdicional += `\n   Valor FIPE: R$ ${this.formatarMoeda(dadosTrocaGPT.valorFipe)}`;
    contextoAdicional += `\n   ‚úÖ Este valor ser√° usado automaticamente como entrada no financiamento!`;
    contextoAdicional += `\n   üí° Quando simular financiamento, mencione que o ${dadosTrocaGPT.modelo} dele vai ser a entrada.`;
  }

  if (dadosTrocaGPT.km) {
    contextoAdicional += `\n   Quilometragem: ${dadosTrocaGPT.km} km`;
  }
}

// ‚úÖ DETECTAR RISADAS DO CLIENTE
const temRisada = /\b(k{2,}|rs{2,}|ha{2,}|he{2,}|hi{2,}|ho{2,}|kkk+|rsrs+|haha+|hehe+|hihi+|hoho+|keke+)\b/i.test(msg);
if (temRisada) {
  contextoAdicional += `\n\nüòÇ CLIENTE EST√Å RINDO!`;
  contextoAdicional += `\n‚ö†Ô∏è RIA JUNTO! Use "kkkkk", "hahaha", "rsrsrs" de forma natural na sua resposta.`;
  contextoAdicional += `\nüí° Isso cria conex√£o emocional e mostra que voc√™ est√° sintonizada com ele!`;
}

// ‚úÖ DETECTAR INTEN√á√ÉO DE VISITAR A LOJA
const temVisitaLoja = /\b(vou (a√≠|ai|l√°|la)|pass[oa]r (a√≠|ai|l√°|la)|ir (a√≠|ai|l√°|la)|aparecer|visitar|de manh√£|de tarde|amanh√£|hoje|daqui a pouco)\b/i.test(msg);
if (temVisitaLoja) {
  contextoAdicional += `\n\n‚òï CLIENTE MENCIONOU VISITAR A LOJA!`;
  contextoAdicional += `\n‚ö†Ô∏è OFERE√áA CAFEZINHO! Use a estrat√©gia do caf√© de forma acolhedora e natural.`;
  contextoAdicional += `\nüí° Exemplos: "Vem que a gente toma um cafezinho!", "Passa aqui que preparo um caf√© pra gente!", "Tomo um caf√© com voc√™ enquanto v√™ os carros!"`;
}

// ========== PROCESSAR COM GPT ==========
// Se for primeira mensagem + pedindo ve√≠culo, N√ÉO usar fun√ß√µes (s√≥ cumprimentar)
const usarFuncoes = !pedindoVeiculoPrimeiraMensagem;

const resultado = await this.motorGPT.processarComFuncoes(
  msg,
  historico,
  etapaAtual,
  contextoAdicional,
  this,
  tel,
  sock,
  usarFuncoes // Passa false se for cumprimento inicial
);

// ‚úÖ VERIFICA√á√ÉO SE LISTA FOI ENVIADA
if (resultado.lista_enviada) {
    log.success('‚úÖ Lista com fotos j√° enviada pelo enviarListaComFotos, bloqueando texto');
    this.addHistorico(tel, 'Cliente', msg);
    this.addHistorico(tel, 'Aira', '[Lista com fotos enviada via buscar_carros]');
    return null; // ‚Üê BLOQUEIA O ENVIO DE TEXTO
}

let respostaFinal = String(resultado.resposta)
        .replace(/\[object Object\]/g, '')
        .replace(/undefined/g, '')
        .trim();

      // ========== VALIDA√á√ÉO P√ìS-GPT: REMOVER APRESENTA√á√ïES DUPLICADAS ==========
      if (jaSeApresentou) {
        // Lista de frases proibidas ap√≥s primeira apresenta√ß√£o
        const frasesProibidas = [
          /sou a Aira/i,
          /feir√£o showcar/i,
          /como posso ajudar/i,
          /em que posso ajudar/i,
          /posso te ajudar/i
        ];

        // Se detectar alguma frase proibida, limpar
        frasesProibidas.forEach(regex => {
          if (regex.test(respostaFinal)) {
            log.error(`‚ö†Ô∏è GPT tentou repetir apresenta√ß√£o! Removendo...`);
            
            // Remover a linha inteira que cont√©m a frase proibida
            respostaFinal = respostaFinal
              .split('\n')
              .filter(linha => !regex.test(linha))
              .join('\n')
              .trim();
          }
        });

        // Se removeu tudo e ficou vazio, chamar GPT novamente com instru√ß√£o espec√≠fica
        if (!respostaFinal) {
          log.warning('‚ö†Ô∏è Resposta ficou vazia ap√≥s limpeza, gerando nova resposta...');

          const historico = this.getHistorico(tel);
          const promptRecuperacao = `Voc√™ √© Aira, vendedora REAL e HUMANA do Feir√£o Showcar h√° 15 anos.

‚ö†Ô∏è SITUA√á√ÉO ESPECIAL:
O cliente disse: "${msg}"

Voc√™ J√Å se apresentou antes, ent√£o N√ÉO repita sua apresenta√ß√£o.

INSTRU√á√ÉO:
1. Leia o que o cliente disse
2. Responda de forma natural e coerente
3. Se for pergunta pessoal (Instagram, telefone, etc), responda brevemente e volte para a venda
4. Se for sobre ve√≠culos, ajude diretamente
5. SEMPRE seja conversacional e persuasiva

EXEMPLOS:

Cliente: "voc√™ tem Instagram?"
Aira: "Tenho sim! Mas aqui no WhatsApp consigo te ajudar melhor e mais r√°pido! üòä E a√≠, j√° decidiu qual carro quer conhecer?"

Cliente: "qual seu hor√°rio?"
Aira: "Estou aqui todos os dias das 8h √†s 18h! Mas se quiser, posso te atender agora mesmo pelo WhatsApp. Vamos ver os carros?"

Cliente: "onde fica a loja?"
Aira: "Estamos na [endere√ßo]. Mas antes de vir, que tal eu te mostrar alguns modelos que temos? Assim voc√™ j√° vem sabendo qual quer ver! O que acha?"

Sua resposta natural (m√°ximo 3 linhas):`;

          const messages = [
            { role: 'system', content: promptRecuperacao },
            ...historico.slice(-5).map(h => ({ role: h.role === 'Cliente' ? 'user' : 'assistant', content: h.msg })),
            { role: 'user', content: msg }
          ];

          // ‚úÖ USAR CLAUDE EM VEZ DE OPENAI
          respostaFinal = await callClaudeInsteadOfOpenAI(this.anthropic, {
            messages: messages,
            temperature: 0.8,
            max_tokens: 200
          });

          log.info(`‚úÖ Nova resposta gerada: "${respostaFinal}"`);
        }
      }

      this.addHistorico(tel, 'Cliente', msg);
      this.addHistorico(tel, 'Aira', respostaFinal);

      log.success(`Fun√ß√µes: ${resultado.funcoes_chamadas?.join(', ') || 'nenhuma'}`);

      // ========== BUSCAR VE√çCULOS AUTOMATICAMENTE (se foi cumprimento inicial) ==========
      if (pedindoVeiculoPrimeiraMensagem) {
        log.info('üöó Cumprimento enviado! Buscando ve√≠culos automaticamente...');

        return {
          resposta: respostaFinal,
          buscar_veiculos_automaticamente: true,
          mensagem_original: msg  // Passar a mensagem original para extrair crit√©rios
        };
      }

      // ========== ENVIAR PERGUNTA SOBRE DOCUMENTA√á√ÉO (se foi financiamento) ==========
      if (resultado.enviar_pergunta_documentacao) {
        log.info('üìÑ Financiamento detectado! Gerando pergunta sobre documenta√ß√£o...');

        try {
          // Gerar pergunta personalizada com IA
          const perguntaDoc = await this.gerarRespostaHumana('pergunta_documentacao', {
            mensagem_anterior: respostaFinal
          });

          // Adicionar ao hist√≥rico
          this.addHistorico(tel, 'Aira', perguntaDoc);

          // Retornar objeto com resposta e mensagem adicional
          return {
            resposta: respostaFinal,
            mensagem_adicional: perguntaDoc,
            delay_adicional: 2500 // aguardar 2.5s antes de enviar
          };
        } catch (docError) {
          // ‚úÖ FALLBACK: Se IA falhar, usar pergunta padr√£o simples
          log.warning(`[DOC] Erro ao gerar pergunta personalizada: ${docError.message}, usando fallback`);

          const perguntaFallback = "Voc√™ j√° tem tudo certo da documenta√ß√£o a√≠? üòä";
          this.addHistorico(tel, 'Aira', perguntaFallback);

          return {
            resposta: respostaFinal,
            mensagem_adicional: perguntaFallback,
            delay_adicional: 2500
          };
        }
      }

      return respostaFinal;

    } catch (error) {
    console.error('‚ùå ERRO NA CHAMADA OPENAI:');
    console.error('Mensagem:', error.message);
    console.error('Status:', error.status);
    console.error('Detalhes:', error.response?.data);
    throw error;
  }
}
}


// =====================================================
// WHATSAPP
// =====================================================
async function conectar() {
  console.log('\nüîå Iniciando conex√£o WhatsApp...');

  const { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys');
  const { version } = await fetchLatestBaileysVersion();

  console.log('üì± Vers√£o Baileys:', version.join('.'));
  console.log('üîë Credenciais carregadas:', !!state.creds);
  console.log('üîê Keys carregadas:', Object.keys(state.keys).length);

  const sock = makeWASocket({
    version,
    logger: pino({ level: 'silent' }),
    auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, pino({ level: 'silent' })) },
    browser: ['Bot Aira v10.0', 'Chrome', '10.0'],
    markOnlineOnConnect: true,
  });

  console.log('‚úÖ Socket WhatsApp criado com sucesso\n');

  // ========== WRAPPER SEGURO PARA ENVIO DE MENSAGENS ==========
  // Adicionado em: 2025-01-13 por Helix AI Developer
  // Prop√≥sito: Interceptar todas as mensagens e adicionar tracking/retry/rate-limit
  const originalSendMessage = sock.sendMessage.bind(sock);

  sock.sendMessage = async function(jid, content, options = {}) {
    // Se options.skipTracking === true, usa m√©todo original (para casos especiais)
    if (options.skipTracking) {
      delete options.skipTracking;
      return originalSendMessage(jid, content, options);
    }

    // Determinar tipo de mensagem
    let messageType = 'unknown';
    if (content.text) messageType = 'text';
    else if (content.image) messageType = 'image';
    else if (content.audio) messageType = 'audio';
    else if (content.video) messageType = 'video';
    else if (content.document) messageType = 'document';

    // Usar messageTracker para envio seguro
    // Criar proxy do sock que usa o m√©todo original
    const sockProxy = {
      ...sock,
      sendMessage: originalSendMessage,
      user: sock.user
    };

    const result = await messageTracker.sendWithTracking(
      sockProxy,
      jid,
      content,
      messageType,
      {
        onSuccess: (res) => {
          console.log(`‚úÖ [WRAPPER] Mensagem ${messageType} enviada para ${jid}`);
        },
        onError: (err) => {
          console.error(`‚ùå [WRAPPER] Falha ao enviar ${messageType} para ${jid}:`, err.message);
        }
      }
    );

    // Retornar resultado no formato esperado pelo Baileys
    return result.success ? result.result : Promise.reject(new Error(result.error));
  };

  // Adicionar m√©todo de verifica√ß√£o de conex√£o
  sock.isConnected = function() {
    return sock.user && sock.ws && sock.ws.readyState === 1; // WebSocket.OPEN = 1
  };

  // Wrapper para sendPresenceUpdate (tamb√©m pode falhar silenciosamente)
  const originalSendPresenceUpdate = sock.sendPresenceUpdate.bind(sock);
  sock.sendPresenceUpdate = async function(type, jid) {
    try {
      if (!sock.isConnected()) {
        console.warn(`‚ö†Ô∏è [PRESENCE] Socket desconectado, ignorando presence update: ${type}`);
        return;
      }
      return await originalSendPresenceUpdate(type, jid);
    } catch (error) {
      console.warn(`‚ö†Ô∏è [PRESENCE] Erro ao enviar presence update (${type}):`, error.message);
      // N√£o propagar erro - presence update √© n√£o-cr√≠tico
    }
  };

  console.log('‚úÖ Wrapper de envio com tracking ativado\n');

  const repo = new VeiculosRepository();
  const lucas = new LucasVendedor(repo);

  await repo.buscarVeiculos();

  // ‚úÖ INICIALIZAR GERENCIADOR DE AGENDAMENTOS
  if (db && sock) {
    gerenciadorAgendamentos = new GerenciadorAgendamentos(db, sock);
    console.log('‚úÖ [AGENDAMENTOS] Gerenciador de agendamentos inicializado');
  }


  sock.ev.on('connection.update', async (update) => {
  const { connection, lastDisconnect, qr } = update;

  // Log completo do update para debug
  console.log('\nüîÑ [DEBUG] Connection Update:', JSON.stringify({
    connection,
    hasQR: !!qr,
    hasError: !!lastDisconnect?.error,
    errorMsg: lastDisconnect?.error?.message,
    statusCode: lastDisconnect?.error?.output?.statusCode
  }, null, 2));

  if (qr) {
    console.log('\nüì± QR CODE\n');
    qrcode.generate(qr, { small: true });
  }

  if (connection === 'close') {
    const shouldReconnect = (lastDisconnect?.error instanceof Boom)
      && lastDisconnect.error.output.statusCode !== DisconnectReason.loggedOut;

    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('‚ùå CONEX√ÉO WHATSAPP FECHADA');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìä Erro:', lastDisconnect?.error?.message || 'Desconhecido');
    console.log('üìä Status Code:', lastDisconnect?.error?.output?.statusCode || 'N/A');
    console.log('üìä Tipo do erro:', lastDisconnect?.error?.name || 'N/A');
    console.log('üìä Deve reconectar?', shouldReconnect);
    console.log('üìä Stack trace:', lastDisconnect?.error?.stack);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

    if (shouldReconnect) {
      console.log('üîÑ Reconectando em 3 segundos...');
      setTimeout(conectar, 3000);
    } else {
      console.log('üõë N√£o foi poss√≠vel reconectar. Sess√£o pode estar expirada.');
      console.log('üí° Solu√ß√£o: Delete a pasta auth_info_baileys e leia o QR Code novamente.');
    }
  } else if (connection === 'open') {
    console.log('\n‚úÖ BOT CONECTADO\n');

    // Inicializar integra√ß√£o com backend Flask (OPCIONAL)
    const myNumber = sock.user?.id;
    if (myNumber) {
      try {
        const initialized = await botAdapter.initialize(myNumber);
        if (initialized) {
          console.log('‚úÖ Integra√ß√£o com backend Flask ativa');
        } else {
          console.log('‚ÑπÔ∏è  Integra√ß√£o com backend Flask n√£o dispon√≠vel (continuando sem ela)');
        }
      } catch (error) {
        console.log('‚ÑπÔ∏è  Backend Flask n√£o dispon√≠vel, bot funcionar√° no modo standalone');
      }
    }
  }
});
  
  sock.ev.on('creds.update', saveCreds);
  
 let ultimoMsgID = null;

sock.ev.on('messages.upsert', async ({ messages, type }) => {
  console.log('\nüîµ ========== NOVA MENSAGEM ==========');
  console.log('üìä Type:', type);
  console.log('üìä Total de mensagens:', messages.length);
  console.log('üìä Mensagens:', JSON.stringify(messages, null, 2));
  console.log('=====================================\n');

  if (type !== 'notify') {
    console.log('‚ö†Ô∏è Type n√£o √© notify, ignorando');
    return;
  }

  // ‚úÖ PROCESSAMENTO PARALELO: Todas as mensagens s√£o processadas simultaneamente
  const processingPromises = messages.map(async (msg) => {
    try {
      console.log('\n--- [DEBUG] Processando nova mensagem ---');

      if (!msg.message) {
        console.log('‚ö†Ô∏è [DEBUG] Mensagem sem conte√∫do');
        return; // Mudado de continue para return (dentro de map)
      }

      if (msg.key.fromMe) {
        console.log('‚ö†Ô∏è [DEBUG] Mensagem enviada por mim, ignorando');
        return; // Mudado de continue para return
      }

      console.log('‚úÖ [DEBUG] Mensagem v√°lida para processar');

      if (ultimoMsgID && msg.key.id === ultimoMsgID) {
        log.info('‚ö†Ô∏è Mensagem repetida ignorada');
        return; // Mudado de continue para return
      }
      ultimoMsgID = msg.key.id;

      // Pegar o n√∫mero real (pode vir como @lid ou @s.whatsapp.net)
      let tel = msg.key.remoteJid;

    // Se vier com @lid, usar o senderPn que tem o n√∫mero real
    if (tel.includes('@lid') && msg.key.senderPn) {
      tel = msg.key.senderPn;
      console.log(`üì± [DEBUG] N√∫mero LID detectado, usando senderPn: ${tel}`);
    }

    const nome = (msg.pushName || 'amigo').split(' ')[0];

    console.log(`üì± [DEBUG] Tel final: ${tel}`);
    console.log(`üë§ [DEBUG] Nome: ${nome}`);

    // ========== üîí VERIFICA√á√ÉO DE WHITELIST (MODO TESTE) ==========
    if (!numeroEstaAutorizado(tel)) {
      console.log(`üö´ [WHITELIST] Ignorando mensagem de n√∫mero n√£o autorizado: ${tel}`);
      console.log(`üîí [WHITELIST] MODO_TESTE=${MODO_TESTE}, N√∫mero limpo: ${tel.split('@')[0]}`);
      return; // Mudado de continue para return
    }
    console.log(`‚úÖ [WHITELIST] N√∫mero autorizado: ${tel.split('@')[0]}`);
    // ========== FIM DA VERIFICA√á√ÉO ==========

    // ========== COMANDO ESPECIAL: ESTAT√çSTICAS DE ENVIO ==========
    const mensagemTexto = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';

    if (mensagemTexto.toLowerCase().trim() === '/stats' || mensagemTexto.toLowerCase().trim() === '/estatisticas') {
      console.log('üìä [STATS] Comando de estat√≠sticas recebido');

      const stats = messageTracker.getStats();
      const statsMessage = `üìä *ESTAT√çSTICAS DE ENVIO*\n\n` +
        `üì® Total de envios: ${stats.total}\n` +
        `‚úÖ Sucessos: ${stats.sucessos}\n` +
        `‚ùå Falhas: ${stats.falhas}\n` +
        `üìà Taxa de sucesso: ${stats.taxaSucesso}\n\n` +
        `üíæ Logs completos em: bot_engine/logs/envios.log`;

      await sock.sendMessage(tel, { text: statsMessage });
      console.log('‚úÖ [STATS] Estat√≠sticas enviadas');
      return; // Mudado de continue para return
    }

    // Comando para limpar logs antigos
    if (mensagemTexto.toLowerCase().trim() === '/cleanlogs') {
      console.log('üßπ [STATS] Comando de limpeza de logs recebido');
      messageTracker.cleanOldLogs(7);
      await sock.sendMessage(tel, { text: 'üßπ Logs antigos (>7 dias) limpos com sucesso!' });
      return; // Mudado de continue para return
    }
    // ========== FIM DOS COMANDOS ESPECIAIS ==========

    // ========== PROCESSAR √ÅUDIO COM ELEVENLABS AGENT ==========
if (msg.message?.audioMessage) {
  try {
    log.info(`üé§ ${nome} enviou √°udio`);
    
    const buffer = await downloadMediaMessage(
      msg,
      'buffer',
      {},
      {
        logger: pino({ level: 'silent' }),
        reuploadRequest: sock.updateMediaMessage
      }
    );

    await sock.sendPresenceUpdate('recording', tel);
    
    // ========== TENTAR USAR AGENT ELEVENLABS PRIMEIRO ==========
    try {
      log.info('[AGENT] Processando √°udio com ElevenLabs Agent...');
      
      const audioResposta = await lucas.agentElevenLabs.enviarAudio(tel, buffer);
      
      const audioPath = path.join(__dirname, `temp_agent_resposta_${Date.now()}.mp3`);
      fs.writeFileSync(audioPath, audioResposta);


      await sock.sendMessage(tel, {
        audio: { url: audioPath },
        mimetype: 'audio/ogg; codecs=opus',
        ptt: true
      });

      log.success(`üîä Resposta do Agent enviada para ${nome}`);
      fs.unlinkSync(audioPath);

      // ‚úÖ Limpar status "gravando"
      await sock.sendPresenceUpdate('paused', tel);

      return; // Mudado de continue para return
      
    } catch (agentError) {
      // ========== FALLBACK: SE AGENT FALHAR, USAR M√âTODO ANTIGO ==========
      log.error(`[AGENT] Falhou: ${agentError.message}, usando fallback...`);
      
      const elevenLabs = new ElevenLabsService();

      await sock.sendPresenceUpdate('recording', tel);
      const textoTranscrito = await elevenLabs.transcribeAudio(buffer);

      if (!textoTranscrito) {
        // ‚úÖ Limpar status "recording" antes de enviar desculpa
        await sock.sendPresenceUpdate('paused', tel);
        const historico = lucas.getHistorico(tel);
        await lucas.enviarDesculpaEmAudio('', historico, 'nao_entendeu', tel, sock);
        return; // Mudado de continue para return
      }

      // ‚úÖ Limpar status "recording" ap√≥s transcri√ß√£o bem-sucedida
      await sock.sendPresenceUpdate('paused', tel);
      
      log.info(`üìù Transcri√ß√£o: "${textoTranscrito}"`);

      const respostaTexto = await lucas.processar(tel, textoTranscrito, sock, nome);

      if (!respostaTexto || typeof respostaTexto !== 'string') {
        // ‚ùå PROBLEMA: Estava fazendo continue sem enviar resposta!
        // ‚úÖ CORRE√á√ÉO: Sempre enviar mensagem de fallback
        log.error(`[AUDIO] lucas.processar retornou valor inv√°lido: ${typeof respostaTexto}`);
        await lucas.enviarDesculpaEmAudio('', lucas.getHistorico(tel), 'erro_sistema', tel, sock);
        return; // Mudado de continue para return
      }

      // Detectar se tem lista de ve√≠culos
      const temLista = /^\d+\./m.test(respostaTexto);

      // ========== SE TEM LISTA: S√ì √ÅUDIO INTRODUT√ìRIO ==========
      if (temLista) {
        console.log('üìã [DEBUG] Lista detectada, enviando s√≥ √°udio introdut√≥rio');
        
        const msgIntro = respostaTexto.split('\n')[0];
        
        try {
          await sock.sendPresenceUpdate('recording', tel);
          const audioIntro = await elevenLabs.textToSpeech(msgIntro);
          
          const audioIntroPath = path.join(__dirname, `temp_intro_${Date.now()}.mp3`);
          fs.writeFileSync(audioIntroPath, audioIntro);


          await sock.sendMessage(tel, {
            audio: { url: audioIntroPath },
            mimetype: 'audio/ogg; codecs=opus',
            ptt: true
          });

          log.success('üîä √Åudio introdut√≥rio enviado (lista j√° foi enviada antes)');
          fs.unlinkSync(audioIntroPath);

          // ‚úÖ Limpar status "gravando"
          await sock.sendPresenceUpdate('paused', tel);

        } catch (audioError) {
          log.error(`[√ÅUDIO-INTRO] Falhou: ${audioError.message}`);
          await sock.sendPresenceUpdate('paused', tel);
        }

        return; // Mudado de continue para return - Lista j√° enviada
      }

      // ========== RESPOSTA NORMAL EM √ÅUDIO (SEM LISTA) ==========
      console.log('üîä [DEBUG] Gerando √°udio de resposta...');

      // ‚úÖ DETECTAR SE √â RESPOSTA SOBRE FINANCIAMENTO E ADICIONAR OFERTA DE PLANILHA
      // ‚ö†Ô∏è IMPORTANTE: S√≥ oferecer planilha se tem ve√≠culo espec√≠fico E fala de valores/parcelas
      const veiculoAtual = lucas.veiculoInteresse.get(tel);
      const temValoresEspecificos = /\b(parcela.*r\$|financ.*\d+|r\$\s*\d+.*mensal|vezes.*r\$|\d+x de r\$)\b/i.test(respostaTexto);
      const jaMencionaPlanilha = /\b(planilha|tabelinha|tabela|spreadsheet)\b/i.test(respostaTexto);

      let textoParaAudio = respostaTexto;
      const temFinanciamento = veiculoAtual && temValoresEspecificos && !jaMencionaPlanilha;

      if (temFinanciamento) {
        // Gerar frase de planilha aleat√≥ria para variar
        const frasesComPlanilha = [
          " Pera√≠ que vou te mandar uma planilha aqui pra facilitar!",
          " Deixa eu te enviar uma planilhinha com tudo detalhado!",
          " √ì, vou te passar uma planilha agora pra voc√™ ver melhor!",
          " Espera que vou mandar uma tabelinha aqui pra voc√™!",
          " Vou te enviar uma planilha agora pra ficar mais claro!",
          " J√° te mando uma planilha com tudo organizadinho!"
        ];
        const fraseAleatoria = frasesComPlanilha[Math.floor(Math.random() * frasesComPlanilha.length)];
        textoParaAudio = respostaTexto + fraseAleatoria;
        log.info(`üìä [FINANCIAMENTO] Adicionada oferta de planilha ao √°udio: "${fraseAleatoria}"`);
      }

      try {
        await sock.sendPresenceUpdate('recording', tel);
        const audioResposta = await elevenLabs.textToSpeech(textoParaAudio);

        const audioPath = path.join(__dirname, `temp_audio_${Date.now()}.mp3`);
        fs.writeFileSync(audioPath, audioResposta);

        await sock.sendMessage(tel, {
          audio: { url: audioPath },
          mimetype: 'audio/ogg; codecs=opus',
          ptt: true
        });

        log.success(`üîä √Åudio enviado para ${nome}`);
        fs.unlinkSync(audioPath);

        // ‚úÖ Limpar status "gravando"
        await sock.sendPresenceUpdate('paused', tel);

        // ‚úÖ SE MENCIONOU PLANILHA, ENVIAR PLANILHA FORMATADA LOGO AP√ìS O √ÅUDIO
        if (temFinanciamento) {
          try {
            // Extrair valor do ve√≠culo do contexto ou hist√≥rico
            const veiculoAtual = lucas.veiculoInteresse.get(tel);

            if (veiculoAtual && veiculoAtual.preco) {
              log.info(`üìä [PLANILHA] Gerando e enviando planilha de financiamento...`);

              // Pequeno delay para parecer mais natural (como se estivesse montando a planilha)
              await lucas.aguardar(2000);

              await sock.sendPresenceUpdate('composing', tel);

              // ‚ö†Ô∏è CORRIGIDO: Chamar atrav√©s de lucas.funcoes
              const planilha = await lucas.funcoes.gerarPlanilhaFinanciamento(veiculoAtual.preco, tel);

              await sock.sendMessage(tel, { text: planilha });

              // ‚úÖ Limpar status "digitando"
              await sock.sendPresenceUpdate('paused', tel);

              log.success(`üìä [PLANILHA] Planilha enviada com sucesso!`);
            }
          } catch (planilhaError) {
            log.error(`[PLANILHA] Erro ao enviar: ${planilhaError.message}`);
            await sock.sendPresenceUpdate('paused', tel);
          }
        }

      } catch (audioError) {
        log.error(`[√ÅUDIO] Falhou, enviando texto: ${audioError.message}`);
        await sock.sendMessage(tel, { text: respostaTexto });
        await sock.sendPresenceUpdate('paused', tel);
      }

      return; // Mudado de continue para return
    }

  } catch (error) {
    console.error('‚ùå [DEBUG] ERRO no processamento de √°udio:');
    console.error('Mensagem:', error.message);
    console.error('Stack:', error.stack);

    log.error(`Erro processar √°udio: ${error.message}`);
    const historico = lucas.getHistorico(tel);
    await lucas.enviarDesculpaEmAudio('', historico, 'nao_entendeu', tel, sock);
    return; // Mudado de continue para return
  }
}


    // ========== PROCESSAR TEXTO ==========
    console.log('üìù [DEBUG] Processando como texto...');
    const txt = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';

    console.log('üìù [DEBUG] Texto extra√≠do:', txt);

    if (!txt) {
      console.log('‚ö†Ô∏è [DEBUG] Texto vazio, ignorando');
      return; // Mudado de continue para return
    }

    console.log('‚úÖ [DEBUG] Texto v√°lido, iniciando processamento');

    // ========== VERIFICAR SE √â RESPOSTA DE LOJISTA ==========
    if (gerenciadorAgendamentos) {
      try {
        const respostaLojista = await gerenciadorAgendamentos.processarRespostaLojista(tel, txt);

        if (respostaLojista) {
          console.log('‚úÖ [AGENDAMENTOS] Resposta de lojista processada:', respostaLojista.mensagem);

          // Enviar confirma√ß√£o ao lojista
          await sock.sendMessage(tel, { text: respostaLojista.mensagem });

          // Se foi aprova√ß√£o, cliente j√° foi notificado pelo gerenciador
          // Se foi recusa, nada √© enviado ao cliente
          return; // Mudado de continue para return - Pular processamento normal
        }
      } catch (err) {
        console.error('‚ùå [AGENDAMENTOS] Erro ao processar resposta de lojista:', err);
      }
    }

    // ========== AGREGA√á√ÉO DE MENSAGENS ==========
    // Em vez de processar imediatamente, adicionar √† fila e aguardar mais mensagens
    lucas.adicionarMensagemPendente(tel, txt, async (mensagemCompleta) => {
      console.log('\nüéØ ========== PROCESSANDO MENSAGEM AGREGADA ==========');
      console.log(`üì± Cliente: ${nome}`);
      console.log(`üìù Mensagem: "${mensagemCompleta}"`);
      console.log('='.repeat(70));

      try {
        await sock.readMessages([msg.key]);

        console.log('ü§ñ [DEBUG] Chamando aira.processar...');
        const resp = await lucas.processar(tel, mensagemCompleta, sock, nome);
        console.log('‚úÖ [DEBUG] Aira retornou:', typeof resp, typeof resp === 'object' ? JSON.stringify(resp).substring(0, 100) : resp?.substring(0, 100));

        // ‚úÖ PERMITIR string vazia (indica que fotos foram enviadas com sucesso)
        // S√≥ enviar erro se for null ou undefined (n√£o string vazia)
        if (resp === null || resp === undefined) {
          log.error('[TEXTO] lucas.processar retornou null/undefined');
          await lucas.enviarDesculpaEmAudio('', lucas.getHistorico(tel), 'erro_sistema', tel, sock);
          return;
        }

        // ‚úÖ Se retornou string vazia, significa que a a√ß√£o foi conclu√≠da (ex: fotos enviadas)
        if (resp === '') {
          log.info('[TEXTO] ‚úÖ A√ß√£o conclu√≠da sem necessidade de resposta adicional (fotos enviadas)');
          return;
        }

        // Verificar se retornou objeto (com mensagem adicional) ou string
        let respostaLimpa;
        let mensagemAdicional = null;
        let delayAdicional = 0;

        if (typeof resp === 'object' && resp.resposta) {
          // Retornou objeto com mensagem adicional
          respostaLimpa = resp.resposta.replace(/\[object Object\]/g, '').replace(/undefined/g, '').trim();
          mensagemAdicional = resp.mensagem_adicional;
          delayAdicional = resp.delay_adicional || 0;
          log.info(`üìÑ Mensagem adicional detectada (ser√° enviada ap√≥s ${delayAdicional}ms)`);
        } else if (typeof resp === 'string') {
          // Retornou string simples
          respostaLimpa = resp.replace(/\[object Object\]/g, '').replace(/undefined/g, '').trim();
        } else {
          // ‚ùå PROBLEMA: Tipo inv√°lido mas n√£o envia resposta
          // ‚úÖ CORRE√á√ÉO: Enviar mensagem de fallback
          log.error(`‚ùå Resposta com tipo inv√°lido (tipo: ${typeof resp})`);
          await lucas.enviarDesculpaEmAudio('', lucas.getHistorico(tel), 'erro_sistema', tel, sock);
          return;
        }

        if (!respostaLimpa) {
          // ‚ùå PROBLEMA: Resposta vazia mas n√£o envia nada
          // ‚úÖ CORRE√á√ÉO: Enviar mensagem de fallback
          log.error('‚ùå Resposta vazia ap√≥s limpeza');
          await lucas.enviarDesculpaEmAudio('', lucas.getHistorico(tel), 'erro_sistema', tel, sock);
          return;
        }

        // ========== DELAY NATURAL ANTES DE RESPONDER ==========
        const delayNatural = lucas.calcularDelayNatural(respostaLimpa);
        log.info(`‚è±Ô∏è Aguardando ${delayNatural}ms (delay natural)`);
        await lucas.aguardar(delayNatural);

        // ========== ENVIAR COMO √ÅUDIO ==========
        try {
          log.info('üîä [TTS] Gerando √°udio da resposta...');

          const elevenLabs = new ElevenLabsService();

          // ‚úÖ Mostrar "gravando" apenas quando for enviar √°udio
          await sock.sendPresenceUpdate('recording', tel);

          // ‚úÖ DETECTAR SE √â RESPOSTA SOBRE FINANCIAMENTO E ADICIONAR OFERTA DE PLANILHA
          // ‚ö†Ô∏è IMPORTANTE: S√≥ oferecer planilha se tem ve√≠culo espec√≠fico E fala de valores/parcelas
          const veiculoAtual = lucas.veiculoInteresse.get(tel);
          const temValoresEspecificos = /\b(parcela.*r\$|financ.*\d+|r\$\s*\d+.*mensal|vezes.*r\$|\d+x de r\$)\b/i.test(respostaLimpa);
          const jaMencionaPlanilha = /\b(planilha|tabelinha|tabela|spreadsheet)\b/i.test(respostaLimpa);

          let textoComPlanilha = respostaLimpa;
          const temFinanciamento = veiculoAtual && temValoresEspecificos && !jaMencionaPlanilha;

          if (temFinanciamento) {
            // Gerar frase de planilha aleat√≥ria para variar
            const frasesComPlanilha = [
              " Pera√≠ que vou te mandar uma planilha aqui pra facilitar!",
              " Deixa eu te enviar uma planilhinha com tudo detalhado!",
              " √ì, vou te passar uma planilha agora pra voc√™ ver melhor!",
              " Espera que vou mandar uma tabelinha aqui pra voc√™!",
              " Vou te enviar uma planilha agora pra ficar mais claro!",
              " J√° te mando uma planilha com tudo organizadinho!"
            ];
            const fraseAleatoria = frasesComPlanilha[Math.floor(Math.random() * frasesComPlanilha.length)];
            textoComPlanilha = respostaLimpa + fraseAleatoria;
            log.info(`üìä [FINANCIAMENTO] Adicionada oferta de planilha ao √°udio: "${fraseAleatoria}"`);
          }

          // Formatar texto para TTS
          const textoFormatado = FormatadorFala.prepararParaTTS(textoComPlanilha);
          log.info(`üìù [TTS] Texto formatado: "${textoFormatado}"`);

          // Gerar √°udio
          const audioBuffer = await elevenLabs.textToSpeech(textoFormatado);

          // Salvar temporariamente
          const audioPath = path.join(__dirname, `temp_resposta_${Date.now()}.mp3`);
          fs.writeFileSync(audioPath, audioBuffer);

          // Enviar √°udio
          await sock.sendMessage(tel, {
            audio: { url: audioPath },
            mimetype: 'audio/ogg; codecs=opus',
            ptt: true
          });

          log.success(`‚úì √Åudio enviado para ${nome}`);

          // Limpar arquivo tempor√°rio
          fs.unlinkSync(audioPath);

          // ‚úÖ Limpar status "gravando" para evitar "Aguardando mensagem"
          await sock.sendPresenceUpdate('paused', tel);

          // ‚úÖ SE MENCIONOU PLANILHA, ENVIAR PLANILHA FORMATADA LOGO AP√ìS O √ÅUDIO
          if (temFinanciamento) {
            try {
              // Extrair valor do ve√≠culo do contexto ou hist√≥rico
              const veiculoAtual = lucas.veiculoInteresse.get(tel);

              if (veiculoAtual && veiculoAtual.preco) {
                log.info(`üìä [PLANILHA] Gerando e enviando planilha de financiamento...`);

                // Pequeno delay para parecer mais natural (como se estivesse montando a planilha)
                await lucas.aguardar(2000);

                await sock.sendPresenceUpdate('composing', tel);

                // ‚ö†Ô∏è CORRIGIDO: Chamar atrav√©s de lucas.funcoes
                const planilha = await lucas.funcoes.gerarPlanilhaFinanciamento(veiculoAtual.preco, tel);

                await sock.sendMessage(tel, { text: planilha });

                // ‚úÖ Limpar status "digitando"
                await sock.sendPresenceUpdate('paused', tel);

                log.success(`üìä [PLANILHA] Planilha enviada com sucesso!`);
              }
            } catch (planilhaError) {
              log.error(`[PLANILHA] Erro ao enviar: ${planilhaError.message}`);
              // ‚úÖ Limpar status em caso de erro
              await sock.sendPresenceUpdate('paused', tel);
            }
          }

        } catch (audioError) {
          // FALLBACK: Se falhar, enviar como texto com delay entre frases
          log.error(`[TTS] Erro ao gerar √°udio: ${audioError.message}`);
          log.info('üì§ Enviando como texto (fallback)');

          const frases = respostaLimpa
            .split(/(?<=[.!?])\s+/)
            .map(f => f.trim())
            .filter(f => f.length > 0);

          console.log(`üí¨ Aira vai enviar ${frases.length} frase(s)`);

          for (let j = 0; j < frases.length; j++) {
            console.log(`üì§ Frase ${j+1}/${frases.length}: "${frases[j]}"`);

            // Delay antes de cada frase
            const delayFrase = lucas.calcularDelayNatural(frases[j]);
            await lucas.aguardar(delayFrase);

            await sock.sendMessage(tel, { text: frases[j] });

            // Pequeno delay entre frases
            if (j < frases.length - 1) {
              await lucas.aguardar(800);
            }
          }
        }

        // ========== ENVIAR MENSAGEM ADICIONAL (DOCUMENTA√á√ÉO) ==========
        if (mensagemAdicional) {
          log.info(`üìÑ Enviando mensagem adicional sobre documenta√ß√£o ap√≥s ${delayAdicional}ms...`);

          // Aguardar delay adicional
          await lucas.aguardar(delayAdicional);

          try {
            await sock.sendPresenceUpdate('recording', tel);

            const elevenLabs = new ElevenLabsService();
            const textoFormatadoDoc = FormatadorFala.prepararParaTTS(mensagemAdicional);

            const audioBufferDoc = await elevenLabs.textToSpeech(textoFormatadoDoc);
            const audioPathDoc = path.join(__dirname, `temp_doc_${Date.now()}.mp3`);
            fs.writeFileSync(audioPathDoc, audioBufferDoc);

            await sock.sendMessage(tel, {
              audio: { url: audioPathDoc },
              mimetype: 'audio/ogg; codecs=opus',
              ptt: true
            });

            log.success(`‚úì Pergunta sobre documenta√ß√£o enviada`);
            fs.unlinkSync(audioPathDoc);

            // ‚úÖ Limpar status "gravando"
            await sock.sendPresenceUpdate('paused', tel);

          } catch (docError) {
            // Fallback: enviar como texto
            log.error(`[TTS] Erro ao gerar √°udio da documenta√ß√£o: ${docError.message}`);
            await sock.sendMessage(tel, { text: mensagemAdicional });
            await sock.sendPresenceUpdate('paused', tel);
          }
        }

        // ========== BUSCA AUTOM√ÅTICA REMOVIDA ==========
        // A busca de ve√≠culos j√° √© feita automaticamente via processarComFuncoes()
        // quando a IA chama a function buscar_carros. N√£o h√° necessidade de
        // chamar buscar_carros() novamente aqui, pois isso duplica o envio das fotos.

      } catch (error) {
        console.error('‚ùå [DEBUG] ERRO no processamento:');
        console.error('Mensagem:', error.message);
        console.error('Stack:', error.stack);

        const historico = lucas.getHistorico(tel);
        await lucas.enviarDesculpaEmAudio(mensagemCompleta, historico, 'geral', tel, sock);
      }
    });

      // Pular o processamento antigo (j√° est√° sendo feito via callback)
      return; // Mudado de continue para return

    } catch (error) {
      // ‚úÖ ERRO NO PROCESSAMENTO DE UMA MENSAGEM INDIVIDUAL
      console.error('‚ùå [PARALELO] Erro ao processar mensagem:', error.message);
      console.error('Stack:', error.stack);
      log.error(`‚ùå Erro ao processar mensagem: ${error.message}`);
    }

    // ========== C√ìDIGO ANTIGO (SER√Å IGNORADO) ==========
    // ========== DIVIDIR POR LINHAS ==========
    const linhas = txt.split('\n').map(l => l.trim()).filter(l => l.length > 0);

    console.log(`üì± ${nome} enviou ${linhas.length} linha(s)`);

    for (let i = 0; i < linhas.length; i++) {
      const linhaAtual = linhas[i];
      
      console.log(`\n${'='.repeat(70)}`);
      console.log(`üì± ${nome} [Linha ${i+1}/${linhas.length}]: "${linhaAtual}"`);
      console.log('='.repeat(70));
      
      try {
        await sock.readMessages([msg.key]);

        console.log('ü§ñ [DEBUG] Chamando aira.processar...');
        const resp = await lucas.processar(tel, linhaAtual, sock, nome);
        console.log('‚úÖ [DEBUG] Aira retornou:', typeof resp, resp?.substring(0, 100));
        
        if (!resp) {
          log.info('‚úÖ Processado sem resposta textual');
          continue;
        }
        
        if (typeof resp !== 'string') {
          log.error(`‚ùå Resposta n√£o √© string (tipo: ${typeof resp})`);
          continue;
        }
        
        const respostaLimpa = resp
          .replace(/\[object Object\]/g, '')
          .replace(/undefined/g, '')
          .trim();
        
        if (!respostaLimpa) {
          log.error('‚ùå Resposta vazia ap√≥s limpeza');
          continue;
        }
        
        // ========== NOVO: ENVIAR COMO √ÅUDIO ==========
try {
  log.info('üîä [TTS] Gerando √°udio da resposta...');
  
  const elevenLabs = new ElevenLabsService();
  
  // Formatar texto para TTS
  const textoFormatado = FormatadorFala.prepararParaTTS(respostaLimpa);
  log.info(`üìù [TTS] Texto formatado: "${textoFormatado}"`);
  
  // Mostrar "gravando √°udio"
  await sock.sendPresenceUpdate('recording', tel);
  
  // Gerar √°udio
  const audioBuffer = await elevenLabs.textToSpeech(textoFormatado);
  
  // Salvar temporariamente
  const audioPath = path.join(__dirname, `temp_resposta_${Date.now()}.mp3`);
  fs.writeFileSync(audioPath, audioBuffer);

  // Enviar √°udio
  await sock.sendMessage(tel, {
    audio: { url: audioPath },
    mimetype: 'audio/ogg; codecs=opus',
    ptt: true
  });

  log.success(`‚úì √Åudio enviado para ${nome}`);

  // Limpar arquivo tempor√°rio
  fs.unlinkSync(audioPath);

  // ‚úÖ Limpar status "gravando"
  await sock.sendPresenceUpdate('paused', tel);

} catch (audioError) {
  // FALLBACK: Se falhar, enviar como texto
  log.error(`[TTS] Erro ao gerar √°udio: ${audioError.message}`);
  log.info('üì§ Enviando como texto (fallback)');
  
  const frases = respostaLimpa
    .split(/(?<=[.!?])\s+/)
    .map(f => f.trim())
    .filter(f => f.length > 0);

  for (let j = 0; j < frases.length; j++) {
    await new Promise(r => setTimeout(r, 1200));
    await sock.sendMessage(tel, { text: frases[j] });

    if (j < frases.length - 1) {
      await new Promise(r => setTimeout(r, 800));
    }
  }

  // ‚úÖ Limpar status ap√≥s fallback
  await sock.sendPresenceUpdate('paused', tel);
}

console.log('='.repeat(70) + '\n');

if (i < linhas.length - 1) {
  await new Promise(r => setTimeout(r, 2000));
}

        console.log('üì§ ENVIANDO:', respostaLimpa);
        
        const frases = respostaLimpa
          .split(/(?<=[.!?])\s+/)
          .map(f => f.trim())
          .filter(f => f.length > 0);

        console.log(`üí¨ Aira vai enviar ${frases.length} frase(s)`);

        for (let j = 0; j < frases.length; j++) {
          console.log(`üì§ Frase ${j+1}/${frases.length}: "${frases[j]}"`);
          
          await new Promise(r => setTimeout(r, 1200));
          await sock.sendMessage(tel, { text: frases[j] });
          
          console.log(`‚úì Enviada`);
          
          if (j < frases.length - 1) {
            await new Promise(r => setTimeout(r, 800 + Math.random() * 400));
          }
        }

        console.log('='.repeat(70) + '\n');
                
        if (i < linhas.length - 1) {
          await new Promise(r => setTimeout(r, 2000));
        }
        
      } catch (error) {
        console.error('‚ùå [DEBUG] ERRO no processamento:');
        console.error('Mensagem:', error.message);
        console.error('Stack:', error.stack);
        log.error(`‚ùå Erro no processamento: ${error.message}`);
      }
    }
  }); // Fecha a fun√ß√£o map

  // ‚úÖ AGUARDAR TODAS AS MENSAGENS SEREM PROCESSADAS EM PARALELO
  // Usar Promise.allSettled para n√£o falhar se uma mensagem der erro
  await Promise.allSettled(processingPromises);
  console.log(`\n‚úÖ [PARALELO] ${messages.length} mensagem(ns) processada(s) simultaneamente\n`);
});
  
return new Promise(() => {});
}
// =====================================================
// INICIALIZA√á√ÉO
// =====================================================
(async () => {
  const dbOk = await conectarDB();
  if (!dbOk) process.exit(1);
  await conectar();
})();