"""
Webhook para processamento de mensagens WhatsApp - VendeAI
Recebe mensagens do servi√ßo Baileys e processa com IA
"""

from flask import Blueprint, request, jsonify
from flask_login import login_required
from datetime import datetime
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent.parent))
from database.models import Empresa, ConfiguracaoBot, Lead, Conversa, Mensagem, TipoMensagem, Produto
from backend import db_manager
import requests
import json

webhook_bp = Blueprint('webhook', __name__, url_prefix='/api/webhook')


@webhook_bp.route('/whatsapp/message', methods=['POST'])
def receber_mensagem():
    """
    Webhook chamado pelo servi√ßo Node.js quando uma mensagem √© recebida

    Payload esperado:
    {
        "empresaId": 2,
        "from": "5567999887766@s.whatsapp.net",
        "text": "Ol√°, quero saber sobre produtos",
        "timestamp": 1234567890,
        "messageId": "ABC123"
    }
    """
    session = db_manager.get_session()

    try:
        data = request.get_json()
        print(f"\nüì• [WEBHOOK] Mensagem recebida: {data}")

        empresa_id = data.get('empresaId')
        telefone_completo = data.get('from')  # Ex: 5567999887766@s.whatsapp.net
        texto = data.get('text', '')
        timestamp = data.get('timestamp')
        message_id = data.get('messageId')

        # Extrair n√∫mero limpo
        telefone = telefone_completo.split('@')[0] if '@' in telefone_completo else telefone_completo

        # Buscar empresa
        empresa = session.query(Empresa).filter_by(id=empresa_id).first()
        if not empresa:
            return jsonify({'success': False, 'error': 'Empresa n√£o encontrada'}), 404

        # Verificar se bot est√° ativo
        if not empresa.bot_ativo:
            print(f"[WEBHOOK] Bot desativado para empresa {empresa_id}")
            return jsonify({'success': True, 'message': 'Bot desativado'}), 200

        # Ignorar mensagens de status/broadcast
        if 'status@broadcast' in telefone_completo or 'broadcast' in telefone_completo:
            print(f"[WEBHOOK] Ignorando mensagem de broadcast")
            return jsonify({'success': True, 'message': 'Broadcast ignorado'}), 200

        # Buscar ou criar lead
        lead = session.query(Lead).filter_by(
            empresa_id=empresa_id,
            telefone=telefone
        ).first()

        if not lead:
            lead = Lead(
                empresa_id=empresa_id,
                telefone=telefone,
                origem='whatsapp'
            )
            session.add(lead)
            session.flush()
            print(f"[WEBHOOK] Lead criado: {telefone}")

        # Buscar ou criar conversa
        conversa = session.query(Conversa).filter_by(
            empresa_id=empresa_id,
            lead_id=lead.id,
            ativa=True
        ).first()

        if not conversa:
            conversa = Conversa(
                empresa_id=empresa_id,
                lead_id=lead.id,
                telefone=telefone,
                ativa=True,
                bot_ativo=True
            )
            session.add(conversa)
            session.flush()
            print(f"[WEBHOOK] Conversa criada para lead {lead.id}")

        # Salvar mensagem recebida
        mensagem = Mensagem(
            conversa_id=conversa.id,
            tipo=TipoMensagem.TEXTO,
            conteudo=texto,
            enviada_por_bot=False,
            whatsapp_id=message_id
        )
        session.add(mensagem)

        # Atualizar estat√≠sticas
        conversa.total_mensagens += 1
        conversa.mensagens_recebidas += 1
        conversa.ultima_mensagem = datetime.utcnow()
        lead.ultima_interacao = datetime.utcnow()

        session.commit()

        print(f"[WEBHOOK] Mensagem salva no banco. Processando resposta...")

        # Processar com IA
        resposta = processar_mensagem_com_ia(
            empresa=empresa,
            lead=lead,
            conversa=conversa,
            texto=texto,
            session=session
        )

        if resposta:
            # Enviar resposta via WhatsApp
            enviar_resposta_whatsapp(
                empresa_id=empresa_id,
                telefone=telefone_completo,
                texto=resposta['texto']
            )

            print(f"[WEBHOOK] ‚úÖ Resposta enviada com sucesso!")

        return jsonify({
            'success': True,
            'message': 'Mensagem processada',
            'lead_id': lead.id,
            'conversa_id': conversa.id
        })

    except Exception as e:
        session.rollback()
        print(f"[WEBHOOK] ‚ùå Erro: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        session.close()


def processar_mensagem_com_ia(empresa, lead, conversa, texto, session):
    """
    Processa mensagem com IA e gera resposta
    """
    try:
        # Buscar configura√ß√£o do bot
        config_bot = session.query(ConfiguracaoBot).filter_by(
            empresa_id=empresa.id
        ).first()

        if not config_bot or not config_bot.auto_resposta_ativa:
            print("[IA] Auto-resposta desativada")
            return None

        # Buscar produtos da empresa para contexto
        produtos = session.query(Produto).filter_by(
            empresa_id=empresa.id,
            ativo=True
        ).limit(10).all()

        produtos_contexto = []
        for p in produtos:
            produtos_contexto.append({
                'nome': p.nome,
                'preco': p.preco,
                'descricao': p.descricao,
                'categoria': p.categoria
            })

        # Buscar hist√≥rico da conversa (√∫ltimas 10 mensagens)
        historico = session.query(Mensagem).filter_by(
            conversa_id=conversa.id
        ).order_by(Mensagem.enviada_em.desc()).limit(10).all()

        historico_formatado = []
        for msg in reversed(historico):
            historico_formatado.append({
                'role': 'assistant' if msg.enviada_por_bot else 'user',
                'content': msg.conteudo
            })

        # Construir prompt para IA
        prompt_sistema = construir_prompt_sistema(config_bot, produtos_contexto)

        # Chamar IA (OpenAI, Groq, ou ElevenLabs)
        resposta_ia = None

        # Tentar OpenAI primeiro
        if config_bot.openai_api_key:
            resposta_ia = chamar_openai(
                api_key=config_bot.openai_api_key,
                model=config_bot.openai_model or 'gpt-4-turbo',
                prompt_sistema=prompt_sistema,
                historico=historico_formatado,
                mensagem=texto
            )

        # Fallback para Groq
        elif config_bot.groq_api_key:
            resposta_ia = chamar_groq(
                api_key=config_bot.groq_api_key,
                prompt_sistema=prompt_sistema,
                historico=historico_formatado,
                mensagem=texto
            )

        if not resposta_ia:
            # Resposta padr√£o se IA n√£o dispon√≠vel
            resposta_ia = f"Ol√°! Recebi sua mensagem sobre: {texto[:50]}... Vou analisar e j√° te respondo!"

        # Salvar resposta no banco
        mensagem_bot = Mensagem(
            conversa_id=conversa.id,
            tipo=TipoMensagem.TEXTO,
            conteudo=resposta_ia,
            enviada_por_bot=True
        )
        session.add(mensagem_bot)

        # Atualizar estat√≠sticas
        conversa.total_mensagens += 1
        conversa.mensagens_enviadas += 1

        session.commit()

        return {
            'texto': resposta_ia,
            'usar_audio': config_bot.enviar_audio and config_bot.elevenlabs_api_key
        }

    except Exception as e:
        print(f"[IA] Erro ao processar: {str(e)}")
        import traceback
        traceback.print_exc()
        return None


def construir_prompt_sistema(config_bot, produtos):
    """
    Constr√≥i prompt do sistema para a IA
    """
    prompt = f"""Voc√™ √© um assistente de vendas inteligente da empresa {config_bot.empresa.nome}.

INFORMA√á√ïES DA EMPRESA:
{config_bot.descricao_empresa or 'N√£o informado'}

PRODUTOS/SERVI√áOS:
{config_bot.produtos_servicos or 'N√£o informado'}

P√öBLICO-ALVO:
{config_bot.publico_alvo or 'N√£o informado'}

DIFERENCIAIS:
{config_bot.diferenciais or 'N√£o informado'}

HOR√ÅRIO DE ATENDIMENTO:
{config_bot.horario_atendimento or 'Segunda a Sexta, 9h √†s 18h'}

TOM DE CONVERSA:
Use um tom {config_bot.tom_conversa or 'profissional'}.

PRODUTOS DISPON√çVEIS:
"""

    if produtos:
        for p in produtos[:5]:
            prompt += f"\n- {p['nome']}: {p['descricao'][:100] if p['descricao'] else 'Sem descri√ß√£o'} (R$ {p['preco']:.2f})"
    else:
        prompt += "\nNenhum produto cadastrado no momento."

    prompt += f"""

INSTRU√á√ïES:
1. Seja prestativo e responda de forma objetiva
2. Se perguntarem sobre produtos, use a lista acima
3. Se precisar de informa√ß√µes que n√£o tem, pergunte educadamente
4. Qualifique o lead perguntando sobre necessidades
5. Mantenha respostas curtas (m√°ximo 2-3 linhas para WhatsApp)
6. Use emojis moderadamente para ser mais amig√°vel
7. Se receberem uma resposta vaga como "oi" ou "opa", se apresente e pergunte como pode ajudar

MENSAGEM DE BOAS-VINDAS (use quando for o primeiro contato):
{config_bot.mensagem_boas_vindas or 'Ol√°! Como posso ajudar voc√™ hoje?'}
"""

    return prompt


def chamar_openai(api_key, model, prompt_sistema, historico, mensagem):
    """
    Chama API da OpenAI
    """
    try:
        url = 'https://api.openai.com/v1/chat/completions'
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }

        messages = [
            {'role': 'system', 'content': prompt_sistema}
        ]

        # Adicionar hist√≥rico
        if historico:
            messages.extend(historico[-5:])  # √öltimas 5 mensagens

        # Adicionar mensagem atual
        messages.append({'role': 'user', 'content': mensagem})

        payload = {
            'model': model,
            'messages': messages,
            'max_tokens': 300,
            'temperature': 0.7
        }

        response = requests.post(url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()

        result = response.json()
        resposta = result['choices'][0]['message']['content']

        print(f"[OPENAI] Resposta gerada: {resposta[:100]}...")
        return resposta

    except Exception as e:
        print(f"[OPENAI] Erro: {str(e)}")
        return None


def chamar_groq(api_key, prompt_sistema, historico, mensagem):
    """
    Chama API da Groq (LLMs r√°pidos)
    """
    try:
        url = 'https://api.groq.com/openai/v1/chat/completions'
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }

        messages = [
            {'role': 'system', 'content': prompt_sistema}
        ]

        if historico:
            messages.extend(historico[-5:])

        messages.append({'role': 'user', 'content': mensagem})

        payload = {
            'model': 'llama-3.1-70b-versatile',  # Modelo r√°pido da Groq
            'messages': messages,
            'max_tokens': 300,
            'temperature': 0.7
        }

        response = requests.post(url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()

        result = response.json()
        resposta = result['choices'][0]['message']['content']

        print(f"[GROQ] Resposta gerada: {resposta[:100]}...")
        return resposta

    except Exception as e:
        print(f"[GROQ] Erro: {str(e)}")
        return None


def enviar_resposta_whatsapp(empresa_id, telefone, texto):
    """
    Envia resposta via servi√ßo WhatsApp (Baileys)
    """
    try:
        url = 'http://localhost:3001/api/message/send'
        payload = {
            'empresaId': empresa_id,
            'to': telefone,
            'text': texto
        }

        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status()

        print(f"[WHATSAPP] Mensagem enviada para {telefone}")
        return True

    except Exception as e:
        print(f"[WHATSAPP] Erro ao enviar: {str(e)}")
        return False


@webhook_bp.route('/whatsapp/connection', methods=['POST'])
def webhook_conexao():
    """
    Webhook chamado quando WhatsApp conecta/desconecta
    """
    session = db_manager.get_session()

    try:
        data = request.get_json()
        print(f"\nüì° [WEBHOOK] Evento de conex√£o: {data}")

        empresa_id = data.get('empresaId')
        event = data.get('event')  # 'connected' ou 'disconnected'
        numero = data.get('numero')

        empresa = session.query(Empresa).filter_by(id=empresa_id).first()
        if empresa:
            if event == 'connected':
                empresa.whatsapp_conectado = True
                empresa.whatsapp_numero = numero
                empresa.whatsapp_qr_code = None
                print(f"[WEBHOOK] ‚úÖ WhatsApp conectado: {numero}")
            elif event == 'disconnected':
                empresa.whatsapp_conectado = False
                empresa.bot_ativo = False
                print(f"[WEBHOOK] ‚ùå WhatsApp desconectado")

            session.commit()

        return jsonify({'success': True})

    except Exception as e:
        session.rollback()
        print(f"[WEBHOOK] Erro: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        session.close()


@webhook_bp.route('/test', methods=['GET', 'POST'])
def test_webhook():
    """
    Endpoint de teste do webhook
    """
    return jsonify({
        'status': 'online',
        'message': 'Webhook VendeAI funcionando!',
        'timestamp': datetime.utcnow().isoformat()
    })


@webhook_bp.route('/elevenlabs', methods=['GET', 'POST'])
def webhook_elevenlabs():
    """
    Webhook para receber eventos do ElevenLabs Agent

    Este endpoint recebe callbacks do agente de voz do ElevenLabs
    quando uma chamada √© finalizada ou quando h√° eventos importantes.

    URL p√∫blica (LocalTunnel): https://meuapp.loca.lt/api/webhook/elevenlabs
    """
    try:
        # GET √© usado pelo ElevenLabs para verificar se o webhook est√° online
        if request.method == 'GET':
            return jsonify({
                'status': 'online',
                'service': 'ElevenLabs Webhook',
                'message': 'Webhook ElevenLabs pronto para receber eventos',
                'timestamp': datetime.utcnow().isoformat()
            })

        # POST √© usado para receber eventos do agente
        data = request.get_json()
        print(f"\nüéôÔ∏è [ELEVENLABS-WEBHOOK] Evento recebido: {json.dumps(data, indent=2)}")

        event_type = data.get('event_type') or data.get('type')

        # Processar diferentes tipos de eventos
        if event_type == 'call.ended':
            print(f"[ELEVENLABS] Chamada finalizada")
            call_id = data.get('call_id')
            duration = data.get('duration')
            transcript = data.get('transcript')

            print(f"  Call ID: {call_id}")
            print(f"  Dura√ß√£o: {duration}s")
            if transcript:
                print(f"  Transcri√ß√£o: {transcript[:200]}...")

            # Aqui voc√™ pode salvar os dados no banco se necess√°rio

        elif event_type == 'call.started':
            print(f"[ELEVENLABS] Chamada iniciada")

        elif event_type == 'agent.message':
            print(f"[ELEVENLABS] Mensagem do agente: {data.get('message')}")

        else:
            print(f"[ELEVENLABS] Evento desconhecido: {event_type}")

        # Sempre retornar sucesso para o ElevenLabs
        return jsonify({
            'success': True,
            'message': 'Evento processado com sucesso',
            'timestamp': datetime.utcnow().isoformat()
        }), 200

    except Exception as e:
        print(f"[ELEVENLABS-WEBHOOK] ‚ùå Erro: {str(e)}")
        import traceback
        traceback.print_exc()

        # Retornar erro mas com status 200 para n√£o bloquear o ElevenLabs
        return jsonify({
            'success': False,
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 200


# ========== FUN√á√ïES PARA O AGENTE ELEVENLABS ==========

@webhook_bp.route('/elevenlabs/buscar-carros', methods=['POST'])
def buscar_carros():
    """
    API para o agente ElevenLabs buscar carros dispon√≠veis

    Payload esperado:
    {
        "marca": "Honda",
        "modelo": "City",
        "ano_min": 2020,
        "ano_max": 2023,
        "preco_max": 100000,
        "tipo": "sedan"
    }
    """
    try:
        import mysql.connector
        from os import environ

        data = request.get_json() or {}
        print(f"\nüöó [ELEVENLABS-BUSCAR] Par√¢metros recebidos: {data}")

        # Conectar ao banco MySQL
        db = mysql.connector.connect(
            host=environ.get('DB_HOST', 'localhost'),
            port=int(environ.get('DB_PORT', 3306)),
            user=environ.get('DB_USER', 'root'),
            password=environ.get('DB_PASSWORD', ''),
            database=environ.get('DB_NAME', 'u161861600_feiraoshow')
        )
        cursor = db.cursor(dictionary=True)

        # Construir query din√¢mica
        query = """
            SELECT
                c.id,
                cc.title as nome,
                b.name as marca,
                cm.name as modelo,
                c.price as preco,
                c.year as ano,
                c.mileage as km,
                c.feature_image as foto,
                bd.name as tipo_carroceria
            FROM cars c
            LEFT JOIN car_contents cc ON c.id = cc.car_id
            LEFT JOIN brands b ON cc.brand_id = b.id
            LEFT JOIN car_models cm ON cc.car_model_id = cm.id
            LEFT JOIN body_types bd ON cc.body_type_id = bd.id
            WHERE c.status = '1' AND c.price > 0
        """

        params = []

        # Filtros opcionais
        if data.get('marca'):
            query += " AND b.name LIKE %s"
            params.append(f"%{data['marca']}%")

        if data.get('modelo'):
            query += " AND cm.name LIKE %s"
            params.append(f"%{data['modelo']}%")

        if data.get('ano_min'):
            query += " AND c.year >= %s"
            params.append(data['ano_min'])

        if data.get('ano_max'):
            query += " AND c.year <= %s"
            params.append(data['ano_max'])

        if data.get('preco_max'):
            # Incluir ve√≠culos at√© 10% acima do pre√ßo (para oferecer op√ß√µes melhores)
            preco_com_margem = float(data['preco_max']) * 1.1
            query += " AND c.price <= %s"
            params.append(preco_com_margem)

        if data.get('tipo'):
            query += " AND bd.name LIKE %s"
            params.append(f"%{data['tipo']}%")

        # Ordenar por pre√ßo DECRESCENTE (mais caro primeiro, come√ßando pelo limite)
        # Mostra ve√≠culos pr√≥ximos ao valor m√°ximo que o cliente pode pagar
        query += " ORDER BY c.price DESC LIMIT 5"

        cursor.execute(query, params)
        veiculos = cursor.fetchall()

        # Formatar resposta
        resultado = []
        for v in veiculos:
            resultado.append({
                'id': v['id'],
                'nome': v['nome'] or 'Sem nome',
                'marca': v['marca'] or 'N/A',
                'modelo': v['modelo'] or 'N/A',
                'preco': float(v['preco'] or 0),
                'ano': v['ano'] or 'N/A',
                'km': v['km'] or '0',
                'tipo': v['tipo_carroceria'] or 'N/A',
                'foto': v['foto']  # ‚Üê CAMPO ADICIONADO!
            })

        cursor.close()
        db.close()

        print(f"[ELEVENLABS-BUSCAR] ‚úÖ Encontrados {len(resultado)} ve√≠culos")

        return jsonify({
            'success': True,
            'total': len(resultado),
            'veiculos': resultado
        }), 200

    except Exception as e:
        print(f"[ELEVENLABS-BUSCAR] ‚ùå Erro: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e),
            'veiculos': []
        }), 200


@webhook_bp.route('/elevenlabs/detalhes-veiculo', methods=['POST'])
def detalhes_veiculo():
    """
    API para o agente ElevenLabs buscar detalhes de um ve√≠culo espec√≠fico

    Payload esperado (ElevenLabs):
    {
        "veiculo_id": 123
    }
    """
    try:
        import mysql.connector
        from os import environ

        data = request.get_json() or {}
        # Aceitar ambos os formatos: 'veiculo_id' (ElevenLabs) e 'id' (legado)
        veiculo_id = data.get('veiculo_id') or data.get('id')

        print(f"\nüîç [ELEVENLABS-DETALHES] Buscando ve√≠culo ID: {veiculo_id}")

        if not veiculo_id:
            return jsonify({
                'success': False,
                'error': 'ID do ve√≠culo n√£o fornecido'
            }), 400

        # Conectar ao banco MySQL
        db = mysql.connector.connect(
            host=environ.get('DB_HOST', 'localhost'),
            port=int(environ.get('DB_PORT', 3306)),
            user=environ.get('DB_USER', 'root'),
            password=environ.get('DB_PASSWORD', ''),
            database=environ.get('DB_NAME', 'u161861600_feiraoshow')
        )
        cursor = db.cursor(dictionary=True)

        # Buscar detalhes completos
        query = """
            SELECT
                c.id,
                cc.title as nome,
                b.name as marca,
                cm.name as modelo,
                c.price as preco,
                c.year as ano,
                c.mileage as km,
                c.feature_image as foto,
                bd.name as tipo_carroceria,
                fc.name as cor,
                ft.name as tipo_combustivel,
                trans.name as transmissao,
                cc.description as descricao,
                c.doors as portas,
                c.engine_capacity as motor
            FROM cars c
            LEFT JOIN car_contents cc ON c.id = cc.car_id
            LEFT JOIN brands b ON cc.brand_id = b.id
            LEFT JOIN car_models cm ON cc.car_model_id = cm.id
            LEFT JOIN body_types bd ON cc.body_type_id = bd.id
            LEFT JOIN fuel_types ft ON cc.fuel_type_id = ft.id
            LEFT JOIN transmission_types trans ON cc.transmission_type_id = trans.id
            LEFT JOIN car_colors fc ON cc.car_color_id = fc.id
            WHERE c.id = %s AND c.status = '1'
        """

        cursor.execute(query, (veiculo_id,))
        veiculo = cursor.fetchone()

        if not veiculo:
            cursor.close()
            db.close()
            return jsonify({
                'success': False,
                'error': 'Ve√≠culo n√£o encontrado'
            }), 404

        # Buscar fotos adicionais
        cursor.execute("SELECT image FROM car_images WHERE car_id = %s LIMIT 5", (veiculo_id,))
        fotos = [f['image'] for f in cursor.fetchall()]

        cursor.close()
        db.close()

        # Formatar resposta
        resultado = {
            'id': veiculo['id'],
            'nome': veiculo['nome'] or 'Sem nome',
            'marca': veiculo['marca'] or 'N/A',
            'modelo': veiculo['modelo'] or 'N/A',
            'preco': float(veiculo['preco'] or 0),
            'ano': veiculo['ano'] or 'N/A',
            'km': veiculo['km'] or '0',
            'tipo': veiculo['tipo_carroceria'] or 'N/A',
            'cor': veiculo['cor'] or 'N/A',
            'combustivel': veiculo['tipo_combustivel'] or 'N/A',
            'cambio': veiculo['transmissao'] or 'N/A',
            'portas': veiculo['portas'] or 'N/A',
            'motor': veiculo['motor'] or 'N/A',
            'descricao': veiculo['descricao'] or 'Sem descri√ß√£o',
            'fotos': fotos
        }

        print(f"[ELEVENLABS-DETALHES] ‚úÖ Detalhes do ve√≠culo {veiculo_id} encontrados")

        return jsonify({
            'success': True,
            'veiculo': resultado
        }), 200

    except Exception as e:
        print(f"[ELEVENLABS-DETALHES] ‚ùå Erro: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 200


@webhook_bp.route('/elevenlabs/calcular-financiamento', methods=['POST'])
def calcular_financiamento():
    """
    API para o agente ElevenLabs calcular financiamento

    Payload esperado (ElevenLabs):
    {
        "valor_veiculo": 50000,
        "entrada": 10000,
        "parcelas": 48,
        "taxa_juros": 1.99
    }
    """
    try:
        data = request.get_json() or {}

        # Aceitar ambos os formatos (novo ElevenLabs e antigo)
        valor_total = float(data.get('valor_veiculo') or data.get('valor', 0))
        entrada = float(data.get('entrada', 0))
        num_parcelas = int(data.get('parcelas', 48))
        taxa_juros_param = float(data.get('taxa_juros', 1.99))

        print(f"\nüí∞ [ELEVENLABS-FINANCIAMENTO] Calculando: Valor={valor_total}, Entrada={entrada}, Parcelas={num_parcelas}, Taxa={taxa_juros_param}%")

        if valor_total <= 0 or num_parcelas <= 0:
            return jsonify({
                'success': False,
                'error': 'Valor ou n√∫mero de parcelas inv√°lido'
            }), 400

        # C√°lculo do financiamento
        valor_financiado = valor_total - entrada
        taxa_mensal = taxa_juros_param / 100  # Converter % para decimal (ex: 1.99 -> 0.0199)

        # F√≥rmula: PMT = PV * (i * (1+i)^n) / ((1+i)^n - 1)
        if valor_financiado > 0:
            taxa_fator = (1 + taxa_mensal) ** num_parcelas
            valor_parcela = valor_financiado * (taxa_mensal * taxa_fator) / (taxa_fator - 1)
            valor_total_pago = entrada + (valor_parcela * num_parcelas)
            juros_total = valor_total_pago - valor_total
        else:
            valor_parcela = 0
            valor_total_pago = entrada
            juros_total = 0

        resultado = {
            'valor_veiculo': valor_total,
            'entrada': entrada,
            'valor_financiado': valor_financiado,
            'num_parcelas': num_parcelas,
            'valor_parcela': round(valor_parcela, 2),
            'valor_total_pago': round(valor_total_pago, 2),
            'juros_total': round(juros_total, 2),
            'taxa_mensal': taxa_mensal * 100  # em %
        }

        print(f"[ELEVENLABS-FINANCIAMENTO] ‚úÖ Parcela calculada: R$ {resultado['valor_parcela']:.2f}")

        return jsonify({
            'success': True,
            'financiamento': resultado
        }), 200

    except Exception as e:
        print(f"[ELEVENLABS-FINANCIAMENTO] ‚ùå Erro: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 200


@webhook_bp.route('/elevenlabs/agendar-visita', methods=['POST'])
def agendar_visita():
    """
    API para o agente ElevenLabs agendar visita do cliente

    Payload esperado (ElevenLabs):
    {
        "cliente_nome": "Jo√£o Silva",
        "cliente_telefone": 67999887766,
        "data_preferida": "2025-10-15",
        "horario_preferido": "14:00",
        "veiculo_id": 123
    }
    """
    session = db_manager.get_session()

    try:
        data = request.get_json() or {}

        # Aceitar ambos os formatos: ElevenLabs (cliente_nome, data_preferida, etc) e legado (nome, data, etc)
        nome = data.get('cliente_nome') or data.get('nome')
        telefone = str(data.get('cliente_telefone') or data.get('telefone', ''))
        data_visita = data.get('data_preferida') or data.get('data')
        horario = data.get('horario_preferido') or data.get('horario')
        veiculo_id = data.get('veiculo_id')

        print(f"\nüìÖ [ELEVENLABS-AGENDAR] Agendando visita: {nome} - {data_visita} {horario}")
        print(f"[ELEVENLABS-AGENDAR] Dados recebidos: {data}")

        if not all([nome, telefone, data_visita, horario]):
            return jsonify({
                'success': False,
                'error': 'Dados incompletos para agendamento'
            }), 400

        # Buscar ou criar lead
        lead = session.query(Lead).filter_by(
            telefone=telefone
        ).first()

        if not lead:
            # Criar lead se n√£o existir
            lead = Lead(
                empresa_id=1,  # ID da empresa padr√£o
                nome=nome,
                telefone=telefone,
                origem='elevenlabs'
            )
            session.add(lead)
            session.flush()
        else:
            # Atualizar nome se veio vazio
            if not lead.nome or lead.nome == 'N√£o informado':
                lead.nome = nome

        # Criar agendamento (voc√™ pode criar uma tabela 'agendamentos' se quiser)
        # Por enquanto, vou salvar como uma conversa especial
        conversa = Conversa(
            empresa_id=1,
            lead_id=lead.id,
            telefone=telefone,
            ativa=True,
            bot_ativo=False,  # Desativar bot ap√≥s agendamento
            observacoes=f"AGENDAMENTO: {data_visita} √†s {horario} - Ve√≠culo ID: {veiculo_id or 'N√£o especificado'}"
        )
        session.add(conversa)

        # Salvar mensagem de agendamento
        mensagem = Mensagem(
            conversa_id=conversa.id,
            tipo=TipoMensagem.TEXTO,
            conteudo=f"Visita agendada para {data_visita} √†s {horario}",
            enviada_por_bot=True
        )
        session.add(mensagem)

        session.commit()

        resultado = {
            'agendamento_id': conversa.id,
            'nome': nome,
            'telefone': telefone,
            'data': data_visita,
            'horario': horario,
            'veiculo_id': veiculo_id,
            'mensagem': f'Visita agendada com sucesso para {data_visita} √†s {horario}!'
        }

        print(f"[ELEVENLABS-AGENDAR] ‚úÖ Visita agendada ID: {conversa.id}")

        return jsonify({
            'success': True,
            'agendamento': resultado
        }), 200

    except Exception as e:
        session.rollback()
        print(f"[ELEVENLABS-AGENDAR] ‚ùå Erro: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 200
    finally:
        session.close()
